<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowCode</title>

    <!-- FONTS -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <!-- BOOTSTRAP 5 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- FONT AWESOME -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- SKULPT (Python Engine) -->
    <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt-stdlib.js"></script>

    <style>
        :root {
            --bg-canvas: #f8f9fa;
            --grid-color: #dee2e6;
            --node-bg: #ffffff;
            --node-border: #212529;
            --node-text: #212529;
            --accent: #0d6efd;
            --console-bg: #1e1e1e;
        }

body { 
    font-family: 'Inter', sans-serif; 
    height: 100vh; 
    overflow-y: auto; /* Change from hidden to auto */
    overflow-x: hidden; /* Keep horizontal hidden if needed */
    background-color: #fff;
    margin: 0;
}

        .wrapper { height: 100vh; display: flex; flex-direction: column; }
        .main-area { flex: 1; display: flex; overflow: hidden; }

        /* --- SIDEBAR --- */
        #palette {
            width: 260px;
            background: #fff;
            border-right: 1px solid #dee2e6;
            padding: 20px;
            z-index: 10;
            overflow-y: auto;
            display: flex; flex-direction: column;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
        }
        .palette-header {
            font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px;
            color: #adb5bd; font-weight: 700; margin-top: 20px; margin-bottom: 10px;
        }
       .palette-item {
    cursor: move; /* Better browser support than grab */
    user-select: none;
    margin-bottom: 10px;
    padding: 12px; /* Slightly more padding */
    border: 2px solid #dee2e6; /* Thicker border */
    border-radius: 8px; /* Slightly more rounded */
    background: white;
    transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.9rem;
    color: #495057;
    font-weight: 600;
    box-sizing: border-box;
    position: relative;
}

.palette-item:hover {
    border-color: var(--accent);
    box-shadow: 0 6px 12px rgba(13, 110, 253, 0.15); /* Blue-tinted shadow */
    color: var(--accent);
    cursor: move;
    top: -1px; /* Subtle lift instead of transform */
}

.palette-item:active {
    cursor: move;
    border-color: #0a58ca; /* Darker blue for active state */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    top: 0; /* Reset position when clicking */
}

.palette-item i { 
    width: 20px; 
    text-align: center; 
    color: #6c757d;
    transition: color 0.2s ease; /* Smooth icon color transition */
}

.palette-item:hover i { 
    color: var(--accent); 
}
        /* --- CANVAS --- */
        #canvas {
            flex: 1; background-color: var(--bg-canvas); position: relative; overflow: hidden;
            background-image: radial-gradient(#ced4da 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* --- RIGHT PANEL --- */
        #output-panel {
            width: 480px; display: flex; flex-direction: column;
            border-left: 1px solid #dee2e6; background: #fff;
            box-shadow: -4px 0 15px rgba(0,0,0,0.05);
            z-index: 10;
            height: 100%;
        }
        .panel-toolbar {
            padding: 10px 15px; background: #f8f9fa; border-bottom: 1px solid #dee2e6;
            display: flex; justify-content: space-between; align-items: center;
            flex-shrink: 0;
        }
        .panel-title { color: #212529; font-weight: 700; font-size: 0.9rem; display: flex; align-items: center; gap: 8px;}
        
        .code-display {
            flex: 1; 
            padding: 15px; font-family: 'JetBrains Mono', monospace;
            font-size: 13px; color: #212529; overflow-y: auto;
            background: #fff;
            border-bottom: 1px solid #dee2e6; line-height: 1.6;
            min-height: 100px; 
            white-space: pre; 
        }
        
        .keyword { color: #d63384; font-weight: bold; }
        .func { color: #0d6efd; }
        .string { color: #198754; }
        .comment { color: #6c757d; font-style: italic; }
        .number { color: #fd7e14; }

        /* Fixed Console Layout */
        #console-container {
            height: 250px; 
            background: var(--console-bg); 
            display: flex; flex-direction: column;
            flex-shrink: 0;
        }
        #console-header {
            padding: 5px 10px; background: #000; color: #fff; font-size: 11px; font-weight: bold;
            border-top: 1px solid #444; display: flex; justify-content: space-between;
            flex-shrink: 0;
        }
        #console {
            flex: 1; 
            color: #f8f9fa;
            padding: 10px; 
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px; 
            overflow-y: auto;
            padding-bottom: 40px;
        }

        /* --- NODES --- */
        .node {
            position: absolute; background: var(--node-bg); 
            border: 2px solid var(--node-border);
            text-align: center; font-size: 13px; font-weight: 600; 
            color: var(--node-text);
            user-select: none; cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1); 
            z-index: 2;
            display: flex; align-items: center; justify-content: center; padding: 5px;
        }
        
        .node:hover { border-color: var(--accent); }
        .node.selected { border-color: #dc3545; box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.2); }

        
.node.running { 
    background-color: #d1e7dd;      /* Light Green Background */
    border-color: #198754;          /* Dark Green Border */
    color: #0f5132;                 /* Dark Green Text */
    box-shadow: 0 0 15px rgba(25, 135, 84, 0.6); /* Green Glow */
    transform: scale(1.05);         /* Slight Zoom effect */
    z-index: 100; 
    transition: all 0.2s ease-in-out;
}

        /* --- SHAPES --- */
        .shape-start, .shape-end { width: 120px; height: 50px; border-radius: 25px; }
        .shape-process { width: 140px; height: 60px; border-radius: 4px; }
        .shape-var { 
    width: 140px; 
    height: 60px; 
    border-radius: 4px; 
}

        .shape-decision { 
            width: 100px; height: 100px; 
            border-radius: 0px; 
            transform: rotate(45deg);
        }
        .shape-decision .inner-text { 
            transform: rotate(-45deg); 
            width: 140%; pointer-events: none; 
            font-size: 12px; line-height: 1.2;
        }

        .shape-io, .shape-input, .shape-output { 
            width: 140px; height: 60px; 
            transform: skew(-20deg); 
            border-radius: 2px;
            margin-left: 10px; 
        }
        .shape-io .inner-text, .shape-input .inner-text, .shape-output .inner-text { 
            transform: skew(20deg); width: 100%; pointer-events: none;
        }

        /* Dots/Ports */
        .dot { 
            width: 10px; height: 10px; background: #fff; border: 2px solid #495057;
            border-radius: 50%; position: absolute; cursor: crosshair; z-index: 5; transition: transform 0.2s; 
        }
        .dot:hover { background: var(--accent); border-color: var(--accent); transform: scale(1.5); }

        .shape-process .dot.in, .shape-start .dot.in, .shape-end .dot.in { top: -6px; left: 50%; transform: translateX(-50%); }
        .shape-process .dot.out, .shape-start .dot.out, .shape-end .dot.out { bottom: -6px; left: 50%; transform: translateX(-50%); }

        .shape-input .dot, .shape-output .dot { transform: skew(20deg); }
        .shape-input .dot:hover, .shape-output .dot:hover { transform: skew(20deg) scale(1.5); }
        .shape-input .dot.in, .shape-output .dot.in { top: -6px; left: 50%; margin-left: -5px; } 
        .shape-input .dot.out, .shape-output .dot.out { bottom: -6px; left: 50%; margin-left: -5px; }

        .shape-decision .dot.in { top: -6px; left: -6px; } 
        .shape-decision .dot.out-yes { bottom: -6px; right: -6px; background: #198754; border-color: #198754; } 
        .shape-decision .dot.out-no { top: -6px; right: -6px; background: #dc3545; border-color: #dc3545; }

        svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        .conn-label { font-family: 'Inter'; font-size: 11px; font-weight: 700; background: white; padding: 2px 6px; border-radius: 4px; border: 1px solid #dee2e6; pointer-events: none; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }

        /* Node Badges */
        .node-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #6c757d;
            color: white;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 10px;
            z-index: 10;
            font-weight: bold;
        }
        .node-badge.int { background: #fd7e14; }
        .node-badge.str { background: #198754; }
.node .inner-text {
    font-family: 'Inter', sans-serif !important;
    font-size: 14px;
    font-weight: 600;
}
.shape-var .dot.in {
    top: -6px;
    left: 50%;
    transform: translateX(-50%);
}

.shape-var .dot.out {
    bottom: -6px;
    left: 50%;
    transform: translateX(-50%);
}
nav.navbar {
    position: sticky;      
    top: 0;
    z-index: 9999;         
}
    </style>
</head>
<body>

<nav class="navbar navbar-dark bg-dark border-bottom border-secondary">
    <div class="container-fluid">
        <a class="navbar-brand d-flex align-items-center gap-2" href="#">
            <i class="fa-solid fa-diagram-project text-white"></i>
            <span class="text-white fw-bold">FlowCode</span> <span class="badge bg-warning text-dark rounded-pill" style="font-size:0.6rem;">v0.2</span>
        </a>
        <div class="d-flex gap-2">
            <button class="btn btn-outline-light btn-sm" onclick="clearCanvas()">
                <i class="fa-solid fa-trash"></i> Clear
            </button>
        </div>
    </div>
</nav>

<div class="wrapper">
    <div class="main-area">
        <div id="palette">
            <div class="palette-header">Start / End</div>
            <div class="palette-item" draggable="true" data-type="start"><i class="fa-regular fa-circle-play"></i> Start</div>
            <div class="palette-item" draggable="true" data-type="end"><i class="fa-regular fa-circle-stop"></i> End</div>

            <div class="palette-header">Variables</div>
<div class="palette-item" draggable="true" data-type="var">
    <i class="fa-solid fa-pen"></i> Variable
</div>
            
            <div class="palette-header">I/O</div>
            <div class="palette-item" draggable="true" data-type="input"><i class="fa-solid fa-keyboard"></i> Input</div>
            <div class="palette-item" draggable="true" data-type="output"><i class="fa-solid fa-terminal"></i> Print</div>
            <div class="palette-header">Logic</div>
            <div class="palette-item" draggable="true" data-type="process"><i class="fa-solid fa-gear"></i> Process</div>
            <div class="palette-item" draggable="true" data-type="decision"><i class="fa-solid fa-diamond"></i> Decision</div>
            

        </div>

        <div id="canvas">
            <svg id="connections-layer">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#555" /></marker>
                </defs>
            </svg>
            <div id="nodes-layer"></div>
        </div>

        <div id="output-panel">
            <div class="panel-toolbar">
                <span class="panel-title"><i class="fa-brands fa-python"></i> Python 3</span>
                
                <!-- CONTROLS GROUP -->
                <div class="d-flex align-items-center gap-2">
                    <!-- Speed Slider -->
                    <label class="small text-muted fw-bold" style="font-size: 10px;">SPEED</label>
                    <input type="range" class="form-range" id="speed-slider" min="100" max="2000" value="800" style="width: 80px;">
                    
                    <div class="vr mx-2"></div> <!-- Vertical Divider -->
            
                    <!-- Run/Stop Buttons -->
                    <button id="btn-run" class="btn btn-success btn-sm fw-bold" onclick="runSimulation()">
                        <i class="fa-solid fa-play me-1"></i> RUN
                    </button>
                    <button id="btn-stop" class="btn btn-danger btn-sm fw-bold" onclick="stopSimulation()" style="display:none;">
                        <i class="fa-solid fa-stop me-1"></i> STOP
                    </button>
                </div>
            </div>

            <div id="code-python" class="code-display"></div>
            
            <div id="console-container">
                <div id="console-header">
                    <span>TERMINAL</span>
                    <i class="fa-solid fa-terminal"></i>
                </div>
                <div id="console"></div>
            </div>
        </div>
    </div>
</div>

<!-- RUNTIME INPUT MODAL (Used by Skulpt) -->
<div class="modal fade" id="inputModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-light">
                <h5 class="modal-title"><i class="fa-solid fa-keyboard text-primary"></i> User Input</h5>
            </div>
            <div class="modal-body">
                <p id="modal-prompt" class="fw-bold mb-2">Enter value:</p>
                <input type="text" id="modal-input" class="form-control" autocomplete="off" autofocus>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary w-100" id="modal-submit">Submit</button>
            </div>
        </div>
    </div>
</div>

<!-- EDIT NODE MODAL -->
<div class="modal fade" id="editNodeModal" tabindex="-1" data-bs-backdrop="static">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-light py-2">
                <h6 class="modal-title fw-bold" id="editNodeTitle">Edit Node</h6>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="editNodeBody">
                <!-- Dynamic Content Injected Here -->
            </div>
            <div class="modal-footer py-1">
                <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary btn-sm" onclick="saveNodeEdit()">Save Changes</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
    // --- 1. SETUP & DATA ---
    let nodes = [];
    let connections = [];
    let nextId = 1;
    let isRunning = false;
    let editingNodeId = null;

    const canvas = document.getElementById('canvas');
    const nodesLayer = document.getElementById('nodes-layer');
    const svgLayer = document.getElementById('connections-layer');
    const consoleDiv = document.getElementById('console');

    // --- 2. SKULPT CONFIGURATION ---
    function builtinRead(x) {
        if (Sk.builtinFiles === undefined || Sk.builtinFiles["files"][x] === undefined)
            throw "File not found: '" + x + "'";
        return Sk.builtinFiles["files"][x];
    }

    Sk.configure({
        output: function(text) { if(text !== '\n') log(text); },
        read: builtinRead,
        inputfun: function(promptText) {        
            return new Promise(function(resolve) {
                const msg = promptText || "Input required:";
                log(msg, "input"); 
                showInputModal(msg).then(function(result) {
                    log(result, "input"); 
                    resolve(result);      
                });
            });
        },
        inputfunTakesPrompt: true               
    });

    // --- 3. MODAL LOGIC ---
    function showInputModal(msg) {
        return new Promise(resolve => {
            const modalEl = document.getElementById('inputModal');
            const promptEl = document.getElementById('modal-prompt');
            const inputEl = document.getElementById('modal-input');
            const submitEl = document.getElementById('modal-submit');
            
            promptEl.textContent = msg;
            inputEl.value = "";
            let bsModal = bootstrap.Modal.getOrCreateInstance(modalEl);
            
            const finish = () => {
                const val = inputEl.value;
                bsModal.hide();
                resolve(val);
                cleanup(); 
            };
            const handleKey = (e) => { if(e.key === 'Enter') finish(); }
            const cleanup = () => {
                submitEl.removeEventListener('click', finish);
                inputEl.removeEventListener('keydown', handleKey);
                document.body.focus();
            };
            submitEl.addEventListener('click', finish);
            inputEl.addEventListener('keydown', handleKey);
            bsModal.show();
            setTimeout(() => inputEl.focus(), 500);
        });
    }

    // --- 4. DRAG & DROP & EDIT LOGIC ---
    document.querySelectorAll('.palette-item').forEach(item => {
        item.addEventListener('dragstart', (e) => e.dataTransfer.setData('type', item.dataset.type));
    });

    canvas.addEventListener('dragover', (e) => e.preventDefault());
    canvas.addEventListener('drop', (e) => {
        e.preventDefault();
        const type = e.dataTransfer.getData('type');
        if(!type) return;
        const rect = canvas.getBoundingClientRect();
        createNode(type, e.clientX - rect.left - 50, e.clientY - rect.top - 25);
    });

    function createNode(type, x, y) {
        const id = `node-${nextId++}`;
        let text = "";
        let dataType = "str"; 
        
        if(type==='start') text="Start";
        else if(type==='end') text="End";
        else if (type === 'var') {
            text = "x = 0";
            dataType = "int"; // default
        }
        else if(type==='process') text="x = x + 1"; 
        else if(type==='decision') text="x < 5";
        else if(type==='input') { text="Input x = \"Enter Value\""; dataType = "str"; }
        else if(type==='output') text="Print x";

        const node = { id, type, x, y, text, dataType };
        nodes.push(node);
        renderNode(node);
        updateCode();
    }

    function renderNode(node) {
        const el = document.createElement('div');
        el.className = `node shape-${node.type}`;
        el.id = node.id;
        el.style.left = node.x + 'px';
        el.style.top = node.y + 'px';

            
                    let innerHtml = node.text;
            
            if (node.type === 'input') {
                const parts = node.text.split('=');
                innerHtml = `<div class="inner-text">${parts[0].trim()}</div>`;
            }
            else if (node.type === 'var') {
                innerHtml = `<div class="inner-text">${node.text}</div>`;
            }
            else if (['decision','output'].includes(node.type)) {
                innerHtml = `<div class="inner-text">${node.text}</div>`;
            }
            
            el.innerHTML = innerHtml;

        
        if(node.type === 'input' && node.dataType) {
            const badge = document.createElement('div');
            badge.className = `node-badge ${node.dataType}`;
            badge.textContent = node.dataType === 'int' ? 'INT' : 'STR';
            el.appendChild(badge);
        }
        
        el.onmousedown = (e) => startDragNode(e, node.id);
        el.ondblclick = () => editNode(node.id);
        el.onclick = (e) => { e.stopPropagation(); selectNode(node.id); };
        addPorts(el, node);
        nodesLayer.appendChild(el);
    }

function addPorts(el, node) {
    if (node.type === 'start') {
        // Start has only OUT
        addDot(el, 'out', node.id, 'next');
    } 
    else if (node.type === 'end') {
        // End has only IN
        addDot(el, 'in', node.id, 'in');
    }
    else if (node.type === 'decision') {
        // Decision has 1 IN and 2 OUTs (yes/no)
        addDot(el, 'in', node.id, 'in');
        addDot(el, 'out-yes', node.id, 'yes');
        addDot(el, 'out-no', node.id, 'no');
    } 
    else if (
        node.type === 'process' ||
        node.type === 'var' ||
        node.type === 'input' ||
        node.type === 'output'
    ) {
        // Standard blocks: IN + OUT
        addDot(el, 'in', node.id, 'in');
        addDot(el, 'out', node.id, 'next');
    }
}


    function addDot(parent, className, nodeId, portType) {
        const dot = document.createElement('div');
        dot.className = `dot ${className}`;
        dot.title = portType === 'next' ? 'Connect' : portType; 
        dot.onmousedown = (e) => { e.stopPropagation(); startConnection(nodeId, portType); };
        dot.onmouseup = (e) => { e.stopPropagation(); finishConnection(nodeId); };
        parent.appendChild(dot);
    }

    // --- EDIT MODAL ---
    function editNode(id) {
        const node = nodes.find(n => n.id === id);
        if(!node) return;
        editingNodeId = id;
        const modalTitle = document.getElementById('editNodeTitle');
        const modalBody = document.getElementById('editNodeBody');
        let html = '';

        if(node.type === 'input') {
            modalTitle.innerText = "Edit Input Node";
            let currentText = node.text.replace(/^Input\s+/i, ''); 
            let varName = currentText; 
            let promptText = "";
            if(currentText.includes('=')) {
                const parts = currentText.split('=');
                varName = parts[0].trim();
                promptText = parts.slice(1).join('=').trim();
                if ((promptText.startsWith('"') && promptText.endsWith('"')) || (promptText.startsWith("'") && promptText.endsWith("'"))) {
                    promptText = promptText.substring(1, promptText.length - 1);
                }
            }
            html = `<div class="mb-3">
                        <label class="form-label fw-bold small">Variable Name</label>
                        <input type="text" id="edit-input-var" class="form-control" value="${varName}">
                    </div>
                    <div class="mb-3">
                        <label class="form-label fw-bold small">Prompt Message</label>
                        <input type="text" id="edit-input-prompt" class="form-control" value="${promptText}">
                    </div>
                    <div class="mb-3">
                        <label class="form-label fw-bold small">Data Type</label>
                        <select id="edit-input-type" class="form-select">
                            <option value="str" ${node.dataType === 'str' ? 'selected' : ''}>String (Text)</option>
                            <option value="int" ${node.dataType === 'int' ? 'selected' : ''}>Integer (Number)</option>
                            <option value="float" ${node.dataType === 'float' ? 'selected' : ''}>Float (Decimal)</option>

                        </select>
                        <small class="text-muted">Select "Integer" to convert input to number</small>
                    </div>`;
        } 
        
        else if (node.type === 'var') {
    modalTitle.innerText = "Edit Variable";

    let parts = node.text.split('=');
    let varName = parts[0].trim();
    let value = parts[1].trim();

    html = `
        <label class="form-label fw-bold small">Variable Name</label>
        <input id="edit-var-name" class="form-control" value="${varName}">

        <label class="form-label fw-bold small mt-2">Initial Value</label>
        <input id="edit-var-value" class="form-control" value="${value}">

        <label class="form-label fw-bold small mt-2">Type</label>
        <select id="edit-var-type" class="form-select">
            <option value="str" ${node.dataType==="str" ? "selected":""}>String</option>
            <option value="int" ${node.dataType==="int" ? "selected":""}>Integer</option>
            <option value="float" ${node.dataType==="float" ? "selected":""}>Float</option>
        </select>
    `;
}

        
        else if(node.type === 'output') {
            modalTitle.innerText = "Edit Output Node";
            let val = node.text.replace(/^Print\s*/i, '').trim();
            html = `<label class="form-label fw-bold small">Value to Print</label>
                    <div class="d-flex align-items-center gap-2 p-2 border rounded bg-light">
                        <span class="font-monospace fw-bold text-primary">print(</span>
                        <input type="text" id="edit-output-val" class="form-control form-control-sm border-0 shadow-none font-monospace" value="${val}" style="background:transparent;" autofocus>
                        <span class="font-monospace fw-bold text-primary">)</span>
                    </div>`;
        } else {
            modalTitle.innerText = "Edit " + (node.type.charAt(0).toUpperCase() + node.type.slice(1));
            html = `<div class="mb-3">
                        <label class="form-label fw-bold small">Code / Condition</label>
                        <textarea id="edit-generic-text" class="form-control font-monospace" rows="3">${node.text}</textarea>
                    </div>`;
        }
        modalBody.innerHTML = html;
        const bsModal = new bootstrap.Modal(document.getElementById('editNodeModal'));
        bsModal.show();
        setTimeout(() => {
            if(document.getElementById('edit-input-var')) document.getElementById('edit-input-var').focus();
            else if(document.getElementById('edit-output-val')) document.getElementById('edit-output-val').focus();
            else if(document.getElementById('edit-generic-text')) document.getElementById('edit-generic-text').focus();
        }, 500);
    }


function saveNodeEdit() {
    if (!editingNodeId) return;

    const node = nodes.find(n => n.id === editingNodeId);
    let newText = "";

    if (node.type === 'input') {
        const v = document.getElementById('edit-input-var').value.trim();
        const p = document.getElementById('edit-input-prompt').value.trim();
        const dataType = document.getElementById('edit-input-type').value;

        if (!v) return alert("Variable name required");

        newText = `Input ${v} = "${p}"`;
        node.dataType = dataType;
    }
    else if (node.type === 'output') {
        const v = document.getElementById('edit-output-val').value.trim();
        if (!v) return alert("Value required");
        newText = `Print ${v}`;
    }
else if (node.type === 'var') {
    const newName = document.getElementById("edit-var-name").value.trim();
    let newValue = document.getElementById("edit-var-value").value.trim();
    const dtype = document.getElementById("edit-var-type").value;

    if (dtype === "str" && !newValue.startsWith('"'))
        newValue = `"${newValue}"`;

    node.dataType = dtype;
    newText = `${newName} = ${newValue}`;
}


        
    else {
        newText = document.getElementById('edit-generic-text').value;
    }

    // Save
    node.text = newText;

    // Update element
    const el = document.getElementById(node.id);
    el.innerHTML = "";

    // Remove ALL existing ports (fixes duplication)
    el.querySelectorAll('.dot').forEach(dot => dot.remove());

    // Recreate label
if (node.type === 'input') {
    const label = node.text.split('=')[0].trim();
    el.innerHTML = `<div class="inner-text">${label}</div>`;
} 
else if (node.type === 'var') {
    el.innerHTML = `<div class="inner-text">${node.text}</div>`;
}
else if (['decision', 'output'].includes(node.type)) {
    el.innerHTML = `<div class="inner-text">${node.text}</div>`;
} 
else {
    el.innerHTML = `<div class="inner-text">${node.text}</div>`;
}


    // Re-add badge for input types
    if (node.type === 'input') {
        const badge = document.createElement('div');
        badge.className = `node-badge ${node.dataType}`;
        badge.textContent = node.dataType.toUpperCase();
        el.appendChild(badge);
    }

    // Re-add ports (SAFE)
    addPorts(el, node);

    updateCode();

    bootstrap.Modal.getInstance(document.getElementById('editNodeModal')).hide();
    editingNodeId = null;
}



    
    document.getElementById('editNodeModal').addEventListener('keydown', (e) => { 
        if(e.key==='Enter' && !e.shiftKey) { 
            e.preventDefault(); 
            saveNodeEdit(); 
        }
    });

    // --- 5. CONNECTIONS ---
    function selectNode(id) {
        document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
        document.getElementById(id).classList.add('selected');
    }
    
    function clearCanvas() {
        if(confirm("Clear all nodes?")) {
            nodes = []; connections = []; nodesLayer.innerHTML = ''; drawConnections(); updateCode();
        }
    }
    
    let dragLine = null; let isConnecting = false; let connStart = null;
    
    function startConnection(nodeId, portType) {
        isConnecting = true; connStart = { nodeId, portType };
        dragLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        dragLine.setAttribute('stroke', '#0d6efd'); dragLine.setAttribute('stroke-width', '2'); dragLine.setAttribute('stroke-dasharray', '5,5'); dragLine.setAttribute('fill', 'none');
        svgLayer.appendChild(dragLine);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', abortConnection);
    }
    
    function onMouseMove(e) {
        if(isConnecting) {
            const rect = canvas.getBoundingClientRect();
            const pt1 = getPortPosition(connStart.nodeId, connStart.portType);
            dragLine.setAttribute('d', `M ${pt1.x} ${pt1.y} L ${e.clientX - rect.left} ${e.clientY - rect.top}`);
        } else if (dragNodeId) {
            const node = nodes.find(n=>n.id === dragNodeId);
            const rect = canvas.getBoundingClientRect();
            node.x = e.clientX - rect.left - dragOffset.x;
            node.y = e.clientY - rect.top - dragOffset.y;
            const el = document.getElementById(dragNodeId);
            el.style.left = node.x+'px'; el.style.top = node.y+'px';
            drawConnections();
        }
    }
    
    function finishConnection(targetId) {
        if(isConnecting && connStart.nodeId !== targetId) {
            if(connStart.portType !== 'in') connections = connections.filter(c => !(c.from === connStart.nodeId && c.port === connStart.portType));
            connections.push({ from: connStart.nodeId, port: connStart.portType, to: targetId });
            drawConnections(); updateCode();
        }
        abortConnection();
    }
    
    function abortConnection() {
        isConnecting = false; if(dragLine) dragLine.remove();
        document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', abortConnection);
    }
    
    function getPortPosition(nodeId, type) {
        const node = nodes.find(n=>n.id===nodeId);
        const el = document.getElementById(nodeId);
        const w = el.offsetWidth; const h = el.offsetHeight;
        if(node.type === 'decision') {
            const dotClass = (type==='yes'?'out-yes':(type==='no'?'out-no':(type==='next'?'out':'in')));
            const dot = el.querySelector(`.dot.${dotClass}`);
            if(!dot) return {x: node.x+w/2, y: node.y+h/2};
            const r = dot.getBoundingClientRect(); const c = canvas.getBoundingClientRect();
            return { x: r.left - c.left + 5, y: r.top - c.top + 5 }; 
        } 
        return { x: node.x + w/2, y: type === 'in' ? node.y : node.y + h };
    }
    
    function drawConnections() {
        document.querySelectorAll('.conn-label').forEach(e => e.remove());
const defs = svgLayer.querySelector('defs');
svgLayer.innerHTML = "";
svgLayer.appendChild(defs.cloneNode(true));
        connections.forEach(c => {
            const p1 = getPortPosition(c.from, c.port);
            const p2 = getPortPosition(c.to, 'in');
            let color = c.port === 'yes' ? '#198754' : (c.port === 'no' ? '#dc3545' : '#555');
            const d = getOrthogonalPath(p1, p2, c.port);
            const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            p.setAttribute('d', d); p.setAttribute('stroke', color); p.setAttribute('stroke-width', '2'); p.setAttribute('marker-end', 'url(#arrowhead)'); p.setAttribute('fill', 'none');
            const cp = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            cp.setAttribute('d', d); cp.setAttribute('stroke', 'transparent'); cp.setAttribute('stroke-width', '15'); cp.style.cursor='pointer'; cp.setAttribute('fill', 'none');
            cp.onclick = (e) => { e.stopPropagation(); if(confirm("Delete?")) { connections = connections.filter(x=>x!==c); drawConnections(); updateCode(); } };
            svgLayer.appendChild(p); svgLayer.appendChild(cp);
            if(['yes','no'].includes(c.port)) {
                const lbl = document.createElement('div'); lbl.className='conn-label'; lbl.innerText=c.port==='yes'?'Yes':'No'; lbl.style.position='absolute'; lbl.style.color=color;
                lbl.style.left = (c.port==='yes' ? p1.x+10 : p1.x+10) + 'px';
                lbl.style.top = (c.port==='yes' ? p1.y+10 : p1.y-20) + 'px';
                nodesLayer.appendChild(lbl);
            }
        });
    }
    
    function getOrthogonalPath(p1, p2, portType) {
        let d = `M ${p1.x} ${p1.y}`;
        const midY = (p1.y + p2.y) / 2;
        if(p2.y > p1.y + 30) {
            if(portType === 'no') { d += ` L ${p2.x + 40} ${p1.y} L ${p2.x + 40} ${midY} L ${p2.x} ${midY} L ${p2.x} ${p2.y}`; } 
            else { d += ` L ${p1.x} ${midY} L ${p2.x} ${midY} L ${p2.x} ${p2.y}`; }
        } else {
            const buffer = 80;
            if(portType === 'no') { const rx = Math.max(p1.x, p2.x) + buffer; d += ` L ${rx} ${p1.y} L ${rx} ${p2.y - 40} L ${p2.x} ${p2.y - 40} L ${p2.x} ${p2.y}`; } 
            else { const lx = Math.min(p1.x, p2.x) - buffer; d += ` L ${p1.x} ${p1.y + 20} L ${lx} ${p1.y + 20} L ${lx} ${p2.y - 40} L ${p2.x} ${p2.y - 40} L ${p2.x} ${p2.y}`; }
        }
        return d;
    }
    
    let dragNodeId = null; let dragOffset = {x:0, y:0};
    
    function startDragNode(e, id) {
        if(e.target.classList.contains('dot')) return;
        dragNodeId = id;
        const node = nodes.find(n=>n.id===id);
        dragOffset.x = e.clientX - node.x - canvas.getBoundingClientRect().left;
        dragOffset.y = e.clientY - node.y - canvas.getBoundingClientRect().top;
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', () => { dragNodeId = null; document.removeEventListener('mousemove', onMouseMove); updateCode(); });
        selectNode(id);
    }
    
    window.addEventListener('keydown', (e) => {
        if((e.key === 'Delete' || e.key === 'Backspace') && !['INPUT','TEXTAREA'].includes(e.target.tagName)) {
            const s = document.querySelector('.node.selected');
            if(s) { nodes=nodes.filter(n=>n.id!==s.id); connections=connections.filter(c=>c.from!==s.id && c.to!==s.id); s.remove(); drawConnections(); updateCode(); }
        }
    });


let generatedCode = "";

    /* ---------------------------------------------------------
   MAIN UPDATE FUNCTION â€” RUNS AFTER ANY CANVAS CHANGE
--------------------------------------------------------- */
function updateCode() {

    const pyBox = document.getElementById("code-python");
    let execCode = ["import time", "import sys", ""];
    let displayHtml = [];

    const startNode = nodes.find(n => n.type === "start");
    if (!startNode) {
        pyBox.innerHTML = '<span class="comment"># Drag a Start block to begin</span>';
        return;
    }

    // Build adjacency lists
    const adj = {}, revAdj = {};
    nodes.forEach(n => {
        adj[n.id] = [];
        revAdj[n.id] = [];
    });

    connections.forEach(c => {
        adj[c.from].push({ to: c.to, port: c.port });
        revAdj[c.to].push({ from: c.from, port: c.port });
    });

    // -----------------------------------------------------------
    // IMPROVED LOOP DETECTION (FIXED)
    // -----------------------------------------------------------
    function detectLoops() {
        const loops = new Map();
        const visited = new Set();
        const stack = new Set();
        const backEdges = [];

        // Find all back edges
        function findBackEdges(nodeId) {
            if (!nodeId) return;
            
            visited.add(nodeId);
            stack.add(nodeId);

            for (const edge of (adj[nodeId] || [])) {
                if (!edge || !edge.to) continue;
                
                if (stack.has(edge.to)) {
                    backEdges.push({
                        from: nodeId,
                        to: edge.to,
                        port: edge.port
                    });
                } else if (!visited.has(edge.to)) {
                    findBackEdges(edge.to);
                }
            }
            
            stack.delete(nodeId);
        }

        findBackEdges(startNode.id);

        // Analyze each loop
        for (const be of backEdges) {
            const loopEntry = be.to;
            if (loops.has(loopEntry)) continue;

            // Find all nodes in this loop
            const loopNodes = new Set([loopEntry]);
            const queue = [be.from];
            const seen = new Set([be.from, loopEntry]);

            while (queue.length) {
                const current = queue.shift();
                loopNodes.add(current);
                
                // Add predecessors
                (revAdj[current] || []).forEach(e => {
                    if (e && e.from && !seen.has(e.from)) {
                        seen.add(e.from);
                        queue.push(e.from);
                    }
                });
                
                // Add successors
                (adj[current] || []).forEach(e => {
                    if (e && e.to && !seen.has(e.to)) {
                        seen.add(e.to);
                        queue.push(e.to);
                    }
                });
            }

            // Find exits
            const exits = [];
            loopNodes.forEach(id => {
                (adj[id] || []).forEach(edge => {
                    if (edge && edge.to && !loopNodes.has(edge.to)) {
                        exits.push({
                            from: id,
                            to: edge.to,
                            port: edge.port
                        });
                    }
                });
            });

            // Find decision nodes in loop
            const decisionNodes = [];
            loopNodes.forEach(id => {
                const node = nodes.find(n => n.id === id);
                if (node && node.type === "decision") {
                    decisionNodes.push(id);
                }
            });

            // Find controller (decision with exit)
            let controller = null;
            for (const decisionId of decisionNodes) {
                const hasExit = exits.some(e => e.from === decisionId);
                if (hasExit) {
                    controller = decisionId;
                    break;
                }
            }

            // If no decision with exit, use first exit node
            if (!controller && exits.length > 0) {
                controller = exits[0].from;
            }

            // Determine loop type
            let loopType = "while-true";
            let forLoopDetails = null;
            
            // FIRST: Check for for-loop (most specific pattern)
            forLoopDetails = detectForLoop(loopEntry, loopNodes);
            if (forLoopDetails) {
                loopType = "for";
            }
            // SECOND: Check for while loop
            else if (controller && controller === loopEntry) {
                loopType = "while";
            }
            // THIRD: Check for do-while
            else if (controller && controller !== loopEntry) {
                // Check if controller is reachable from entry (executes after)
                const canReach = isReachable(loopEntry, controller, adj);
                if (canReach) {
                    loopType = "do-while";
                }
            }

            loops.set(loopEntry, {
                type: loopType,
                header: loopEntry,
                controller,
                loopNodes,
                exits,
                forLoopDetails
            });
        }

        return loops;
    }

    // Proper for-loop detection (from your original but fixed)
    function detectForLoop(headerId, loopNodes) {
        const headerNode = nodes.find(n => n.id === headerId);
        if (!headerNode || headerNode.type !== "decision") return null;

        // Match condition like: i < 10, count <= 5, x > 0
        const condMatch = headerNode.text.match(/^\s*([a-z_]\w*)\s*([<>]=?|[!=]=)\s*(\S+)\s*$/i);
        if (!condMatch) return null;

        const [, varName, op, limit] = condMatch;

        // Find initialization before header (outside loop)
        let initNode = null;
        const preds = revAdj[headerId] || [];
        for (const pred of preds) {
            if (pred && pred.from && !loopNodes.has(pred.from)) {
                const node = nodes.find(n => n.id === pred.from);
                if (node && (node.type === "var" || node.type === "process")) {
                    const initMatch = node.text.match(new RegExp(`^\\s*${varName}\\s*=\\s*(\\S+)\\s*$`));
                    if (initMatch) {
                        initNode = { id: node.id, value: initMatch[1].trim() };
                        break;
                    }
                }
            }
        }

        if (!initNode) return null;

        // Find increment inside loop (should point back to header)
        let incrementNode = null;
        let step = "1";
        
        for (const nodeId of loopNodes) {
            if (nodeId === headerId) continue;
            
            const node = nodes.find(n => n.id === nodeId);
            if (node && (node.type === "var" || node.type === "process")) {
                // Patterns: i = i + 1, i += 1, i = i - 1, i -= 1
                const patterns = [
                    new RegExp(`^\\s*${varName}\\s*=\\s*${varName}\\s*([+-])\\s*(\\d+)\\s*$`),
                    new RegExp(`^\\s*${varName}\\s*([+-])=\\s*(\\d+)\\s*$`)
                ];
                
                for (const pattern of patterns) {
                    const match = node.text.match(pattern);
                    if (match) {
                        incrementNode = { id: node.id };
                        step = match[2] || "1";
                        if (match[1] === "-") step = "-" + step;
                        break;
                    }
                }
                
                if (incrementNode) break;
            }
        }

        if (!incrementNode) return null;

        // Verify increment connects back to header
        const connectsToHeader = isReachable(incrementNode.id, headerId, adj);
        if (!connectsToHeader) return null;

        return {
            varName,
            start: initNode.value,
            limit,
            op,
            step,
            initNodeId: initNode.id,
            incrementNodeId: incrementNode.id,
            conditionNodeId: headerId
        };
    }

    function isReachable(start, target, adj) {
        if (start === target) return true;
        
        const visited = new Set();
        const queue = [start];
        
        while (queue.length) {
            const current = queue.shift();
            if (current === target) return true;
            if (visited.has(current)) continue;
            visited.add(current);
            
            (adj[current] || []).forEach(e => {
                if (e && e.to) queue.push(e.to);
            });
        }
        return false;
    }

    // -----------------------------------------------------------
    // CODE GENERATION (FIXED)
    // -----------------------------------------------------------


    

    function generateNodeCode(node, sp) {
        // Highlight
        if (node.type !== 'start' && node.type !== 'end') {
            execCode.push(`${sp}highlight_node('${node.id}')`);
        }

        switch (node.type) {
            case "start":
                displayHtml.push(`<div class="code-line"><span class="comment"># Start</span></div>`);
                break;
            case "end":
                execCode.push(`${sp}exit()`);
                displayHtml.push(`<div class="code-line">${sp}exit()</div>`);
                break;
            case "var":
            case "process":
                execCode.push(`${sp}${node.text}`);
                displayHtml.push(`<div class="code-line">${sp}${node.text}</div>`);
                break;
            case "output": {
                let val = node.text.replace(/^Print\s*/i, "").trim();
                execCode.push(`${sp}print(${val})`);
                displayHtml.push(`<div class="code-line">${sp}print(${val})</div>`);
                break;
            }
            case "input": {
                let raw = node.text.replace(/^Input\s+/i, "").trim();
                let [v, p] = raw.split("=").map(x => x.trim());
                if (!p) p = `"${v}"`;
                if (!(p.startsWith('"') || p.startsWith("'"))) p = `"${p}"`;
                
                let pythonCode;
                if (node.dataType === "int") {
                    pythonCode = `${v} = int(input(${p}))`;
                } else if (node.dataType === "float") {
                    pythonCode = `${v} = float(input(${p}))`;
                } else {
                    pythonCode = `${v} = input(${p})`;
                }
                
                execCode.push(`${sp}${pythonCode}`);
                displayHtml.push(`<div class="code-line">${sp}${pythonCode}</div>`);
                break;
            }
            case "decision":
                // Simple if/else for now
                generateDecisionCode(node, sp);
                break;
        }
    }

       // -----------------------------------------------------------
    // SIMPLIFIED CODE GENERATION
    // -----------------------------------------------------------
    const loops = detectLoops();
    const processed = new Set();

    function generateBlock(startId, indent, stopAt = null, inLoop = false) {
        let current = startId;
        
        while (current && current !== stopAt && !processed.has(current)) {
            const node = nodes.find(n => n.id === current);
            if (!node) break;
            
            // Check if this starts a loop
            if (loops.has(current) && !inLoop) {
                generateLoopBlock(current, indent);
                return; // Loop generation handles what comes after
            }
            
            processed.add(current);
            const sp = "    ".repeat(indent);
            
            // Generate node code
            generateNodeCode(node, sp);
            
            // Handle decision nodes specially
            if (node.type === "decision") {
                generateDecisionBlock(node, indent, stopAt, inLoop);
                return;
            }
            
            // Get next node
            const edges = adj[current] || [];
            if (edges.length === 0) break;
            
            // For non-decision nodes, take first edge
            current = edges[0].to;
        }
    }

    function generateNodeCode(node, sp) {
        // Highlight
        if (node.type !== 'start' && node.type !== 'end') {
            execCode.push(`${sp}highlight_node('${node.id}')`);
        }

        switch (node.type) {
            case "start":
                displayHtml.push(`<div class="code-line"><span class="comment"># Start</span></div>`);
                break;
            case "end":
                execCode.push(`${sp}exit()`);
                displayHtml.push(`<div class="code-line">${sp}exit()</div>`);
                break;
            case "var":
            case "process":
                execCode.push(`${sp}${node.text}`);
                displayHtml.push(`<div class="code-line">${sp}${node.text}</div>`);
                break;
            case "output": {
                let val = node.text.replace(/^Print\s*/i, "").trim();
                execCode.push(`${sp}print(${val})`);
                displayHtml.push(`<div class="code-line">${sp}print(${val})</div>`);
                break;
            }
            case "input": {
                let raw = node.text.replace(/^Input\s+/i, "").trim();
                let [v, p] = raw.split("=").map(x => x.trim());
                if (!p) p = `"${v}"`;
                if (!(p.startsWith('"') || p.startsWith("'"))) p = `"${p}"`;
                
                let pythonCode;
                if (node.dataType === "int") {
                    pythonCode = `${v} = int(input(${p}))`;
                } else if (node.dataType === "float") {
                    pythonCode = `${v} = float(input(${p}))`;
                } else {
                    pythonCode = `${v} = input(${p})`;
                }
                
                execCode.push(`${sp}${pythonCode}`);
                displayHtml.push(`<div class="code-line">${sp}${pythonCode}</div>`);
                break;
            }
            case "decision":
                // Decision nodes are handled in generateDecisionBlock
                break;
        }
    }

    function generateDecisionBlock(decisionNode, indent, stopAt, inLoop) {
        const sp = "    ".repeat(indent);
        const condition = decisionNode.text.replace(/=/g, "==");
        const edges = adj[decisionNode.id] || [];
        const yesEdge = edges.find(e => e.port === "yes");
        const noEdge = edges.find(e => e.port === "no");
        
        // Check if this decision is part of a loop
        const loopForDecision = Array.from(loops.entries()).find(([header, loop]) => 
            loop.loopNodes.has(decisionNode.id)
        );
        
        if (loopForDecision && loopForDecision[1].controller === decisionNode.id) {
            // This decision controls a loop - handle it in loop generation
            generateLoopBlock(loopForDecision[0], indent);
            return;
        }
        
        // Regular if/else
        execCode.push(`${sp}if ${condition}:`);
        displayHtml.push(`<div class="code-line">${sp}if ${condition}:</div>`);
        
        if (yesEdge && yesEdge.to) {
            generateBlock(yesEdge.to, indent + 1, stopAt, inLoop);
        } else {
            execCode.push(`${sp}    pass`);
            displayHtml.push(`<div class="code-line">${sp}    pass</div>`);
        }
        
        if (noEdge && noEdge.to) {
            execCode.push(`${sp}else:`);
            displayHtml.push(`<div class="code-line">${sp}else:</div>`);
            generateBlock(noEdge.to, indent + 1, stopAt, inLoop);
        }
    }

    function generateLoopBlock(headerId, indent) {
        const loop = loops.get(headerId);
        if (!loop) return;
        
        processed.add(headerId);
        const sp = "    ".repeat(indent);
        const headerNode = nodes.find(n => n.id === headerId);
        
        // Generate any code before the loop that connects to header
        const externalPreds = (revAdj[headerId] || []).filter(e => 
            e && e.from && !loop.loopNodes.has(e.from) && !processed.has(e.from)
        );
        
        for (const pred of externalPreds) {
            generateBlock(pred.from, indent, headerId, false);
        }
        
        // Generate the loop based on type
        switch (loop.type) {
            case "for":
                generateForLoopCode(loop, indent);
                break;
            case "while":
                generateWhileLoopCode(loop, indent);
                break;
            case "do-while":
                generateDoWhileLoopCode(loop, indent);
                break;
            default:
                generateWhileTrueLoopCode(loop, indent);
                break;
        }
    }

    // Keep your existing generateForLoopCode, generateWhileLoopCode, etc. functions
    // but make sure generateWhileLoopCode looks like this:

    function generateWhileLoopCode(loop, indent) {
        const sp = "    ".repeat(indent);
        const controllerNode = nodes.find(n => n.id === loop.controller);
        
        if (!controllerNode) {
            generateWhileTrueLoopCode(loop, indent);
            return;
        }

        const condition = controllerNode.text.replace(/=/g, "==");
        
        // Find exit port
        const exitEdge = loop.exits.find(e => e.from === loop.controller);
        const exitPort = exitEdge ? exitEdge.port : "yes";
        
        // Determine loop condition
        let loopCondition;
        if (exitPort === "yes") {
            // Exit when condition is true, so loop while condition is false
            loopCondition = `not (${condition})`;
        } else {
            // Exit when condition is false, so loop while condition is true
            loopCondition = condition;
        }

        execCode.push(`${sp}while ${loopCondition}:`);
        displayHtml.push(`<div class="code-line">${sp}while ${loopCondition}:</div>`);

        // Highlight controller
        execCode.push(`${sp}    highlight_node('${loop.controller}')`);

        // Generate loop body (non-exit branch)
        const bodyEdge = (adj[loop.controller] || []).find(e => e.port !== exitPort);
        if (bodyEdge && bodyEdge.to) {
            generateLoopBody(bodyEdge.to, loop, indent + 1);
        } else {
            execCode.push(`${sp}    pass`);
            displayHtml.push(`<div class="code-line">${sp}    pass</div>`);
        }

        // Continue after loop (exit branch)
        if (exitEdge && exitEdge.to) {
            generateBlock(exitEdge.to, indent, null, false);
        }
    }

    function generateLoopBody(startId, loop, indent) {
        let current = startId;
        const visitedInLoop = new Set();
        
        while (current && loop.loopNodes.has(current) && !visitedInLoop.has(current)) {
            if (processed.has(current)) break;
            
            visitedInLoop.add(current);
            const node = nodes.find(n => n.id === current);
            if (!node) break;
            
            // Don't process the loop header again
            if (current === loop.header) {
                // Find next node in loop
                const edges = adj[current] || [];
                const loopEdge = edges.find(e => 
                    e && e.to && loop.loopNodes.has(e.to) && !visitedInLoop.has(e.to)
                );
                current = loopEdge ? loopEdge.to : null;
                continue;
            }
            
            processed.add(current);
            const sp = "    ".repeat(indent);
            
            // Handle decision nodes in loop body
            if (node.type === "decision") {
                // Check if this is the loop controller
                if (current === loop.controller) {
                    // Already handled in while loop condition
                    break;
                }
                // Regular decision in loop body
                generateDecisionBlock(node, indent, null, true);
                return;
            }
            
            // Regular node in loop
            generateNodeCode(node, sp);
            
            // Get next node in loop
            const edges = adj[current] || [];
            const loopEdge = edges.find(e => 
                e && e.to && loop.loopNodes.has(e.to) && !visitedInLoop.has(e.to)
            );
            current = loopEdge ? loopEdge.to : null;
        }
    }

    // -----------------------------------------------------------
    // START GENERATION
    // -----------------------------------------------------------
    generateBlock(startNode.id, 0);
    // -----------------------------------------------------------
    // LOOP CODE GENERATORS
    // -----------------------------------------------------------
    function generateForLoopCode(loop, indent) {
        const sp = "    ".repeat(indent);
        const details = loop.forLoopDetails;
        
        if (!details) {
            generateWhileLoopCode(loop, indent);
            return;
        }

        // Generate initialization (outside loop)
        const initNode = nodes.find(n => n.id === details.initNodeId);
        if (initNode && !processed.has(details.initNodeId)) {
            generateNodeCode(initNode, sp);
            processed.add(details.initNodeId);
        }

        // Build range expression
        let limit = details.limit;
        if (details.op === "<=" && /^\d+$/.test(details.limit)) {
            limit = String(Number(details.limit) + 1);
        }

        let rangeArgs = `${details.start}, ${limit}`;
        if (details.step !== "1") rangeArgs += `, ${details.step}`;

        // Generate for loop
        execCode.push(`${sp}for ${details.varName} in range(${rangeArgs}):`);
        displayHtml.push(`<div class="code-line">${sp}for ${details.varName} in range(${rangeArgs}):</div>`);

        // Highlight condition
        execCode.push(`${sp}    highlight_node('${details.conditionNodeId}')`);

        // Generate loop body
        const bodyStart = (adj[details.conditionNodeId] || []).find(e => 
            e && e.to && e.to !== details.incrementNodeId
        );
        
        if (bodyStart && bodyStart.to) {
            generateCode(bodyStart.to, indent + 1, details.incrementNodeId);
        } else {
            execCode.push(`${sp}    pass`);
            displayHtml.push(`<div class="code-line">${sp}    pass</div>`);
        }

        // Highlight increment
        const incrementNode = nodes.find(n => n.id === details.incrementNodeId);
        if (incrementNode) {
            execCode.push(`${sp}    highlight_node('${details.incrementNodeId}')`);
        }

        // Continue after loop
        if (loop.exits.length > 0) {
            generateCode(loop.exits[0].to, indent);
        }
    }

    function generateWhileLoopCode(loop, indent) {
        const sp = "    ".repeat(indent);
        const controllerNode = nodes.find(n => n.id === loop.controller);
        
        if (!controllerNode) {
            generateWhileTrueLoopCode(loop, indent);
            return;
        }

        const condition = controllerNode.text.replace(/=/g, "==");
        
        // Find exit port
        const exitEdge = loop.exits.find(e => e.from === loop.controller);
        const exitPort = exitEdge ? exitEdge.port : "yes";
        
        // For while loop, we loop while condition is true (or false if exit is yes)
        let loopCondition = exitPort === "yes" ? `not (${condition})` : condition;

        execCode.push(`${sp}while ${loopCondition}:`);
        displayHtml.push(`<div class="code-line">${sp}while ${loopCondition}:</div>`);

        // Highlight controller
        execCode.push(`${sp}    highlight_node('${loop.controller}')`);

        // Generate loop body (non-exit branch)
        const bodyEdge = (adj[loop.controller] || []).find(e => e.port !== exitPort);
        if (bodyEdge && bodyEdge.to) {
            generateLoopBody(bodyEdge.to, loop, indent + 1);
        } else {
            execCode.push(`${sp}    pass`);
            displayHtml.push(`<div class="code-line">${sp}    pass</div>`);
        }

        // Continue after loop
        if (exitEdge && exitEdge.to) {
            generateCode(exitEdge.to, indent);
        }
    }

    function generateLoopBody(startNodeId, loop, indent) {
        let current = startNodeId;
        const sp = "    ".repeat(indent);
        
        while (current && loop.loopNodes.has(current) && current !== loop.header) {
            if (processed.has(current)) break;
            
            const node = nodes.find(n => n.id === current);
            if (!node) break;
            
            processed.add(current);
            generateNodeCode(node, sp);
            
            // Get next node in loop
            const edges = adj[current] || [];
            const loopEdge = edges.find(e => e.to && loop.loopNodes.has(e.to) && e.to !== loop.header);
            current = loopEdge ? loopEdge.to : null;
        }
    }

    function generateDoWhileLoopCode(loop, indent) {
        const sp = "    ".repeat(indent);
        
        execCode.push(`${sp}while True:`);
        displayHtml.push(`<div class="code-line">${sp}while True:</div>`);

        // Generate loop body (starting from header)
        const bodyStart = (adj[loop.header] || []).find(e => e && e.to);
        if (bodyStart && bodyStart.to) {
            generateLoopBody(bodyStart.to, loop, indent + 1);
        }

        // Generate condition check at end
        if (loop.controller) {
            const controllerNode = nodes.find(n => n.id === loop.controller);
            if (controllerNode) {
                const sp2 = "    ".repeat(indent + 1);
                const condition = controllerNode.text.replace(/=/g, "==");
                const exitEdge = loop.exits.find(e => e.from === loop.controller);
                const exitPort = exitEdge ? exitEdge.port : "yes";
                
                let breakCondition = exitPort === "yes" ? condition : `not (${condition})`;
                execCode.push(`${sp2}if ${breakCondition}: break`);
                displayHtml.push(`<div class="code-line">${sp2}if ${breakCondition}: break</div>`);
            }
        }

        // Continue after loop
        if (loop.exits.length > 0) {
            generateCode(loop.exits[0].to, indent);
        }
    }

    function generateWhileTrueLoopCode(loop, indent) {
        const sp = "    ".repeat(indent);
        
        execCode.push(`${sp}while True:`);
        displayHtml.push(`<div class="code-line">${sp}while True:</div>`);

        // Generate loop body
        const bodyStart = (adj[loop.header] || []).find(e => e && e.to);
        if (bodyStart && bodyStart.to) {
            generateLoopBody(bodyStart.to, loop, indent + 1);
        } else {
            const sp2 = "    ".repeat(indent + 1);
            execCode.push(`${sp2}pass`);
            displayHtml.push(`<div class="code-line">${sp2}pass</div>`);
        }

        // Add break if there's a controller
        if (loop.controller) {
            const controllerNode = nodes.find(n => n.id === loop.controller);
            if (controllerNode) {
                const sp2 = "    ".repeat(indent + 1);
                const condition = controllerNode.text.replace(/=/g, "==");
                const exitEdge = loop.exits.find(e => e.from === loop.controller);
                const exitPort = exitEdge ? exitEdge.port : "yes";
                
                let breakCondition = exitPort === "yes" ? condition : `not (${condition})`;
                execCode.push(`${sp2}if ${breakCondition}: break`);
                displayHtml.push(`<div class="code-line">${sp2}if ${breakCondition}: break</div>`);
            }
        }

        // Continue after loop
        if (loop.exits.length > 0) {
            generateCode(loop.exits[0].to, indent);
        }
    }

    // -----------------------------------------------------------
    // START GENERATION
    // -----------------------------------------------------------
    generateCode(startNode.id, 0);

    // Final output
    pyBox.innerHTML = displayHtml.join("");
    generatedCode = execCode.join("\n");
}
    
    // --- 7. RUNTIME (UPDATED FOR DELAY) ---
function log(msg, type='info') {
    const div = document.createElement('div');
    div.style.marginBottom = '4px';
    
    // Color coding based on severity
    if (type === 'error') {
        div.style.color = '#ff6b6b';
        div.style.fontWeight = 'bold';
    } else if (type === 'warning') {
        div.style.color = '#ffc107';
        div.style.fontWeight = 'bold';
    } else if (type === 'input') {
        div.style.color = '#74c0fc';
    } else {
        div.style.color = '#b2f2bb';
    }
    
    div.textContent = msg; 
    consoleDiv.appendChild(div); 
    consoleDiv.scrollTop = consoleDiv.scrollHeight;
}
    
    function highlightNode(nodeId) {
        document.querySelectorAll('.node').forEach(n => n.classList.remove('running'));
        const el = document.getElementById(nodeId);
        if (el) {
            el.classList.add('running');
            el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
        }
    }
    
async function runSimulation() {
    if(isRunning) return;
    
    // Run updateCode first to build the graph structure and generate code
    updateCode(); 
    
    // Now build a simplified version of the graph to check for TRULY INFINITE loops
    const adj = {}, revAdj = {};
    nodes.forEach(n => { adj[n.id] = []; revAdj[n.id] = []; });
    connections.forEach(c => {
        adj[c.from].push({ to: c.to, port: c.port });
        revAdj[c.to].push({ from: c.from, port: c.port });
    });
    
    // Improved loop detection - only warn about TRULY infinite loops
    const warnings = [];
    const startNode = nodes.find(n => n.type === "start");
    
    if (startNode) {
        // Check for cycles that have NO exit path (truly infinite)
        const visited = new Set();
        const stack = new Set();
        
        // FIXED: Complete function with proper parameters
        function analyzeLoopSafety(nodeId) {
            if (!nodeId) return { hasExit: false, isInfinite: false };
            if (visited.has(nodeId)) return { hasExit: false, isInfinite: false };
            
            visited.add(nodeId);
            stack.add(nodeId);
            
            const edges = adj[nodeId] || [];
            
            // If no outgoing edges, it's not an infinite loop
            if (edges.length === 0) {
                stack.delete(nodeId);
                return { hasExit: true, isInfinite: false };
            }
            
            let hasExit = false;
            let isPotentiallyInfinite = false;
            
            for (const edge of edges) {
                if (!edge || !edge.to) continue;
                
                if (stack.has(edge.to)) {
                    // Found a cycle
                    const node = nodes.find(n => n.id === edge.to);
                    
                    if (node && node.type === "decision") {
                        // Decision nodes have conditional exits - check if there's a non-loop exit
                        const outgoingEdges = adj[edge.to] || [];
                        const hasNonLoopExit = outgoingEdges.some(e => !stack.has(e.to));
                        
                        if (hasNonLoopExit) {
                            hasExit = true;
                        } else {
                            // Decision loop with no exit
                            isPotentiallyInfinite = true;
                            warnings.push({
                                nodeId: edge.to,
                                message: `Loop at "${node.text}" has no exit condition`,
                                severity: "warning"
                            });
                        }
                    } else {
                        // Non-decision node in cycle - might be infinite
                        isPotentiallyInfinite = true;
                        const cycleNode = nodes.find(n => n.id === edge.to);
                        warnings.push({
                            nodeId: edge.to,
                            message: `Loop detected at "${cycleNode ? cycleNode.text : edge.to}"`,
                            severity: "warning"
                        });
                    }
                } else if (!visited.has(edge.to)) {
                    const result = analyzeLoopSafety(edge.to);
                    if (result.hasExit) {
                        hasExit = true;
                    }
                    if (result.isInfinite) {
                        isPotentiallyInfinite = true;
                    }
                }
            }
            
            stack.delete(nodeId);
            return { hasExit, isInfinite: isPotentiallyInfinite && !hasExit };
        }
        
        // Run the analysis from start
        analyzeLoopSafety(startNode.id);
        
        // Check for nodes with no outgoing connections (except end)
        nodes.forEach(node => {
            if (node.type !== "end" && adj[node.id] && adj[node.id].length === 0) {
                warnings.push({
                    nodeId: node.id,
                    message: `"${node.text}" has no outgoing connections`,
                    severity: "info"
                });
            }
        });
        
        // Show warnings if any (but only ask for confirmation on severe warnings)
        const severeWarnings = warnings.filter(w => w.severity === "error");
        const regularWarnings = warnings.filter(w => w.severity === "warning");
        
        if (severeWarnings.length > 0) {
            // Show severe warnings and ask for confirmation
            severeWarnings.forEach(w => {
                log(`ERROR: ${w.message}`, "error");
                const el = document.getElementById(w.nodeId);
                if (el) el.style.borderColor = '#ff6b6b';
            });
            
            if (!confirm(`${severeWarnings.length} error(s) detected. Run anyway?`)) {
                // Reset border colors
                severeWarnings.forEach(w => {
                    const el = document.getElementById(w.nodeId);
                    if (el) el.style.borderColor = '';
                });
                return;
            }
        }
        
        if (regularWarnings.length > 0) {
            // Just show regular warnings, don't block or show confirmation
            regularWarnings.forEach(w => {
                log(`Warning: ${w.message}`, "warning");
                const el = document.getElementById(w.nodeId);
                if (el) el.style.borderColor = '#ffc107';
            });
            
            // Auto-reset border colors after 3 seconds
            setTimeout(() => {
                regularWarnings.forEach(w => {
                    const el = document.getElementById(w.nodeId);
                    if (el) el.style.borderColor = '';
                });
            }, 3000);
        }
    }
    
    consoleDiv.innerHTML = ''; 
    isRunning = true;
    document.getElementById('btn-run').style.display = 'none';
    document.getElementById('btn-stop').style.display = 'inline-block';
    
    // --- SKULPT SUSPENSION HOOK (THE FIX FOR SPEED) ---
    Sk.builtins.highlight_node = function(id) {
        if (!isRunning) throw "ExecutionStopped";

        const nodeId = (typeof id === "string") ? id : id.v;
        highlightNode(nodeId);

        const delay = parseInt(document.getElementById('speed-slider').value) || 800;
        return new Sk.misceval.promiseToSuspension(
            new Promise(resolve => setTimeout(resolve, delay))
        );
    };

    try {
        await Sk.misceval.asyncToPromise(function() {
            return Sk.importMainWithBody("<stdin>", false, generatedCode, true);
        });
        log("Program Finished.");
    } catch (e) {
        if (e.toString() !== "ExecutionStopped") {
            log(e.toString(), "error");
            
            // Check for specific Python errors
            if (e.toString().includes("NameError")) {
                log("Hint: Make sure all variables are defined before use", "error");
            } else if (e.toString().includes("SyntaxError")) {
                log("Hint: Check your Python syntax in the nodes", "error");
            } else if (e.toString().includes("TypeError")) {
                log("Hint: Check data types (int vs str)", "error");
            } else if (e.toString().includes("ValueError")) {
log("Hint: Invalid value provided", "error");
} else if (e.toString().includes("IndentationError")) {
log("Hint: Check indentation in generated code", "error");
}
} else {
log("Stopped by user.", "error");
}
} finally {
stopSimulation();
}
}




                       
function stopSimulation() {
    isRunning = false; 
    document.getElementById('btn-run').style.display = 'inline-block';
    document.getElementById('btn-stop').style.display = 'none';
    document.querySelectorAll('.node').forEach(n => {
        n.classList.remove('running');
        n.style.borderColor = ''; // Reset any warning colors
    });
    const modalEl = document.getElementById('inputModal');
    const bsModal = bootstrap.Modal.getInstance(modalEl);
    if(bsModal) bsModal.hide();
}


</script>

</body>
</html>
