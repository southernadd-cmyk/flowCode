<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowCode</title>

    <!-- FONTS -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <!-- BOOTSTRAP 5 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- FONT AWESOME -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- SKULPT (Python Engine) -->
    <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt-stdlib.js"></script>

    <style>
        :root {
            --bg-canvas: #f8f9fa;
            --grid-color: #dee2e6;
            --node-bg: #ffffff;
            --node-border: #212529;
            --node-text: #212529;
            --accent: #0d6efd;
            --console-bg: #1e1e1e;
        }

        body { 
            font-family: 'Inter', sans-serif; 
            height: 100vh; 
            overflow: hidden; 
            background-color: #fff;
        }

        .wrapper { height: 100vh; display: flex; flex-direction: column; }
        .main-area { flex: 1; display: flex; overflow: hidden; }

        /* --- SIDEBAR --- */
        #palette {
            width: 260px;
            background: #fff;
            border-right: 1px solid #dee2e6;
            padding: 20px;
            z-index: 10;
            overflow-y: auto;
            display: flex; flex-direction: column;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
        }
        .palette-header {
            font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px;
            color: #adb5bd; font-weight: 700; margin-top: 20px; margin-bottom: 10px;
        }
        .palette-item {
            cursor: grab; user-select: none; margin-bottom: 10px; padding: 10px;
            border: 1px solid #dee2e6; border-radius: 6px; background: white;
            transition: all 0.2s; display: flex; align-items: center; gap: 10px;
            font-size: 0.9rem; color: #495057; font-weight: 600;
        }
        .palette-item:hover {
            border-color: var(--accent); transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.05); color: var(--accent);
        }
        .palette-item i { width: 20px; text-align: center; color: #6c757d; }
        .palette-item:hover i { color: var(--accent); }

        /* --- CANVAS --- */
        #canvas {
            flex: 1; background-color: var(--bg-canvas); position: relative; overflow: hidden;
            background-image: radial-gradient(#ced4da 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* --- RIGHT PANEL --- */
        #output-panel {
            width: 480px; display: flex; flex-direction: column;
            border-left: 1px solid #dee2e6; background: #fff;
            box-shadow: -4px 0 15px rgba(0,0,0,0.05);
            z-index: 10;
            height: 100%;
        }
        .panel-toolbar {
            padding: 10px 15px; background: #f8f9fa; border-bottom: 1px solid #dee2e6;
            display: flex; justify-content: space-between; align-items: center;
            flex-shrink: 0;
        }
        .panel-title { color: #212529; font-weight: 700; font-size: 0.9rem; display: flex; align-items: center; gap: 8px;}
        
        .code-display {
            flex: 1; 
            padding: 15px; font-family: 'JetBrains Mono', monospace;
            font-size: 13px; color: #212529; overflow-y: auto;
            background: #fff;
            border-bottom: 1px solid #dee2e6; line-height: 1.6;
            min-height: 100px; 
            white-space: pre; 
        }
        
        .keyword { color: #d63384; font-weight: bold; }
        .func { color: #0d6efd; }
        .string { color: #198754; }
        .comment { color: #6c757d; font-style: italic; }
        .number { color: #fd7e14; }

        /* Fixed Console Layout */
        #console-container {
            height: 250px; 
            background: var(--console-bg); 
            display: flex; flex-direction: column;
            flex-shrink: 0;
        }
        #console-header {
            padding: 5px 10px; background: #000; color: #fff; font-size: 11px; font-weight: bold;
            border-top: 1px solid #444; display: flex; justify-content: space-between;
            flex-shrink: 0;
        }
        #console {
            flex: 1; 
            color: #f8f9fa;
            padding: 10px; 
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px; 
            overflow-y: auto;
            padding-bottom: 40px;
        }

        /* --- NODES --- */
        .node {
            position: absolute; background: var(--node-bg); 
            border: 2px solid var(--node-border);
            text-align: center; font-size: 13px; font-weight: 600; 
            color: var(--node-text);
            user-select: none; cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1); 
            z-index: 2;
            display: flex; align-items: center; justify-content: center; padding: 5px;
        }
        
        .node:hover { border-color: var(--accent); }
        .node.selected { border-color: #dc3545; box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.2); }

        
.node.running { 
    background-color: #d1e7dd;      /* Light Green Background */
    border-color: #198754;          /* Dark Green Border */
    color: #0f5132;                 /* Dark Green Text */
    box-shadow: 0 0 15px rgba(25, 135, 84, 0.6); /* Green Glow */
    transform: scale(1.05);         /* Slight Zoom effect */
    z-index: 100; 
    transition: all 0.2s ease-in-out;
}

        /* --- SHAPES --- */
        .shape-start, .shape-end { width: 120px; height: 50px; border-radius: 25px; }
        .shape-process { width: 140px; height: 60px; border-radius: 4px; }
        .shape-var { 
    width: 140px; 
    height: 60px; 
    border-radius: 4px; 
}

        .shape-decision { 
            width: 100px; height: 100px; 
            border-radius: 0px; 
            transform: rotate(45deg);
        }
        .shape-decision .inner-text { 
            transform: rotate(-45deg); 
            width: 140%; pointer-events: none; 
            font-size: 12px; line-height: 1.2;
        }

        .shape-io, .shape-input, .shape-output { 
            width: 140px; height: 60px; 
            transform: skew(-20deg); 
            border-radius: 2px;
            margin-left: 10px; 
        }
        .shape-io .inner-text, .shape-input .inner-text, .shape-output .inner-text { 
            transform: skew(20deg); width: 100%; pointer-events: none;
        }

        /* Dots/Ports */
        .dot { 
            width: 10px; height: 10px; background: #fff; border: 2px solid #495057;
            border-radius: 50%; position: absolute; cursor: crosshair; z-index: 5; transition: transform 0.2s; 
        }
        .dot:hover { background: var(--accent); border-color: var(--accent); transform: scale(1.5); }

        .shape-process .dot.in, .shape-start .dot.in, .shape-end .dot.in { top: -6px; left: 50%; transform: translateX(-50%); }
        .shape-process .dot.out, .shape-start .dot.out, .shape-end .dot.out { bottom: -6px; left: 50%; transform: translateX(-50%); }

        .shape-input .dot, .shape-output .dot { transform: skew(20deg); }
        .shape-input .dot:hover, .shape-output .dot:hover { transform: skew(20deg) scale(1.5); }
        .shape-input .dot.in, .shape-output .dot.in { top: -6px; left: 50%; margin-left: -5px; } 
        .shape-input .dot.out, .shape-output .dot.out { bottom: -6px; left: 50%; margin-left: -5px; }

        .shape-decision .dot.in { top: -6px; left: -6px; } 
        .shape-decision .dot.out-yes { bottom: -6px; right: -6px; background: #198754; border-color: #198754; } 
        .shape-decision .dot.out-no { top: -6px; right: -6px; background: #dc3545; border-color: #dc3545; }

        svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        .conn-label { font-family: 'Inter'; font-size: 11px; font-weight: 700; background: white; padding: 2px 6px; border-radius: 4px; border: 1px solid #dee2e6; pointer-events: none; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }

        /* Node Badges */
        .node-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #6c757d;
            color: white;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 10px;
            z-index: 10;
            font-weight: bold;
        }
        .node-badge.int { background: #fd7e14; }
        .node-badge.str { background: #198754; }
.node .inner-text {
    font-family: 'Inter', sans-serif !important;
    font-size: 14px;
    font-weight: 600;
}
.shape-var .dot.in {
    top: -6px;
    left: 50%;
    transform: translateX(-50%);
}

.shape-var .dot.out {
    bottom: -6px;
    left: 50%;
    transform: translateX(-50%);
}

    </style>
</head>
<body>

<nav class="navbar navbar-dark bg-dark border-bottom border-secondary">
    <div class="container-fluid">
        <a class="navbar-brand d-flex align-items-center gap-2" href="#">
            <i class="fa-solid fa-diagram-project text-white"></i>
            <span class="text-white fw-bold">FlowCode</span> <span class="badge bg-warning text-dark rounded-pill" style="font-size:0.6rem;">v0.2</span>
        </a>
        <div class="d-flex gap-2">
            <button class="btn btn-outline-light btn-sm" onclick="clearCanvas()">
                <i class="fa-solid fa-trash"></i> Clear
            </button>
        </div>
    </div>
</nav>

<div class="wrapper">
    <div class="main-area">
        <div id="palette">
            <div class="palette-header">Start / End</div>
            <div class="palette-item" draggable="true" data-type="start"><i class="fa-regular fa-circle-play"></i> Start</div>
            <div class="palette-item" draggable="true" data-type="end"><i class="fa-regular fa-circle-stop"></i> End</div>

            <div class="palette-header">Variables</div>
<div class="palette-item" draggable="true" data-type="var">
    <i class="fa-solid fa-pen"></i> Variable
</div>
            
            <div class="palette-header">I/O</div>
            <div class="palette-item" draggable="true" data-type="input"><i class="fa-solid fa-keyboard"></i> Input</div>
            <div class="palette-item" draggable="true" data-type="output"><i class="fa-solid fa-terminal"></i> Print</div>
            <div class="palette-header">Logic</div>
            <div class="palette-item" draggable="true" data-type="process"><i class="fa-solid fa-gear"></i> Process</div>
            <div class="palette-item" draggable="true" data-type="decision"><i class="fa-solid fa-diamond"></i> Decision</div>
            

        </div>

        <div id="canvas">
            <svg id="connections-layer">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#555" /></marker>
                </defs>
            </svg>
            <div id="nodes-layer"></div>
        </div>

        <div id="output-panel">
            <div class="panel-toolbar">
                <span class="panel-title"><i class="fa-brands fa-python"></i> Python 3</span>
                
                <!-- CONTROLS GROUP -->
                <div class="d-flex align-items-center gap-2">
                    <!-- Speed Slider -->
                    <label class="small text-muted fw-bold" style="font-size: 10px;">SPEED</label>
                    <input type="range" class="form-range" id="speed-slider" min="100" max="2000" value="800" style="width: 80px;">
                    
                    <div class="vr mx-2"></div> <!-- Vertical Divider -->
            
                    <!-- Run/Stop Buttons -->
                    <button id="btn-run" class="btn btn-success btn-sm fw-bold" onclick="runSimulation()">
                        <i class="fa-solid fa-play me-1"></i> RUN
                    </button>
                    <button id="btn-stop" class="btn btn-danger btn-sm fw-bold" onclick="stopSimulation()" style="display:none;">
                        <i class="fa-solid fa-stop me-1"></i> STOP
                    </button>
                </div>
            </div>

            <div id="code-python" class="code-display"></div>
            
            <div id="console-container">
                <div id="console-header">
                    <span>TERMINAL</span>
                    <i class="fa-solid fa-terminal"></i>
                </div>
                <div id="console"></div>
            </div>
        </div>
    </div>
</div>

<!-- RUNTIME INPUT MODAL (Used by Skulpt) -->
<div class="modal fade" id="inputModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-light">
                <h5 class="modal-title"><i class="fa-solid fa-keyboard text-primary"></i> User Input</h5>
            </div>
            <div class="modal-body">
                <p id="modal-prompt" class="fw-bold mb-2">Enter value:</p>
                <input type="text" id="modal-input" class="form-control" autocomplete="off" autofocus>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary w-100" id="modal-submit">Submit</button>
            </div>
        </div>
    </div>
</div>

<!-- EDIT NODE MODAL -->
<div class="modal fade" id="editNodeModal" tabindex="-1" data-bs-backdrop="static">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-light py-2">
                <h6 class="modal-title fw-bold" id="editNodeTitle">Edit Node</h6>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="editNodeBody">
                <!-- Dynamic Content Injected Here -->
            </div>
            <div class="modal-footer py-1">
                <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary btn-sm" onclick="saveNodeEdit()">Save Changes</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
    /**************************************************************************************************
     * FLOWCODE ENGINE — S-A MODE (STRICT SINGLE GRAPH PROGRAM)
     * Clean rewrite from scratch: UI logic + connections + compiler + runtime
     * Implements: S2 compiler, strict A validation, M1 merge-detection, MB1 autopass,
     * for/while/do-while loop detection, safe traversal, stable Python output, FX3 bad-link feedback.
     **************************************************************************************************/
    
    /*=============================================================================
        0. GLOBAL STATE
    =============================================================================*/
    let nodes = [];
    let connections = [];
    let nextId = 1;
    
    let isConnecting = false;
    let connStart = null;
    let dragLine = null;
    let isRunning = false;
    
    const canvas = document.getElementById("canvas");
    const nodesLayer = document.getElementById("nodes-layer");
    const svgLayer = document.getElementById("connections-layer");
    const consoleDiv = document.getElementById("console");
    
    /*=============================================================================
        1. SKULPT CONFIGURATION
    =============================================================================*/
    function builtinRead(x) {
        if (!Sk.builtinFiles || !Sk.builtinFiles["files"][x])
            throw `File not found: '${x}'`;
        return Sk.builtinFiles["files"][x];
    }
    
    Sk.configure({
        output: txt => { if (txt !== "\n") log(txt); },
        read: builtinRead,
        inputfun(promptText) {
            return new Promise(resolve => {
                const msg = promptText || "Enter value:";
                showInputModal(msg).then(val => {
                    log(val, "input");
                    resolve(val);
                });
            });
        },
        inputfunTakesPrompt: true
    });
    
    /*=============================================================================
        2. INPUT MODAL HANDLER
    =============================================================================*/
    function showInputModal(msg) {
        return new Promise(resolve => {
            const modalEl = document.getElementById("inputModal");
            const promptEl = document.getElementById("modal-prompt");
            const inputEl = document.getElementById("modal-input");
            const submitEl = document.getElementById("modal-submit");
            const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
    
            promptEl.textContent = msg;
            inputEl.value = "";
    
            const finish = () => {
                const v = inputEl.value;
                cleanup();
                modal.hide();
                resolve(v);
            };
            const cleanup = () => {
                submitEl.removeEventListener("click", finish);
                inputEl.removeEventListener("keydown", handler);
            };
            const handler = e => { if (e.key === "Enter") finish(); };
    
            submitEl.addEventListener("click", finish);
            inputEl.addEventListener("keydown", handler);
    
            modal.show();
            setTimeout(() => inputEl.focus(), 350);
        });
    }
    
    /*=============================================================================
        3. PALETTE → CANVAS DRAG & DROP
    =============================================================================*/
    document.querySelectorAll(".palette-item").forEach(item => {
        item.addEventListener("dragstart", e =>
            e.dataTransfer.setData("type", item.dataset.type)
        );
    });
    
    canvas.addEventListener("dragover", e => e.preventDefault());
    
    canvas.addEventListener("drop", e => {
        e.preventDefault();
        const type = e.dataTransfer.getData("type");
        if (!type) return;
    
        const rect = canvas.getBoundingClientRect();
        createNode(
            type,
            e.clientX - rect.left - 60,
            e.clientY - rect.top - 30
        );
    });
    
    /*=============================================================================
        4. NODE CREATION
    =============================================================================*/
    function createNode(type, x, y) {
        const id = `node-${nextId++}`;
    
        const defaults = {
            start: "Start",
            end: "End",
            var: "x = 0",
            input: "Input x = \"Enter value\"",
            output: "Print x",
            process: "x = x + 1",
            decision: "x < 5"
        };
    
        const node = {
            id,
            type,
            x,
            y,
            text: defaults[type] || "",
            dataType: type === "var" ? "int" : type === "input" ? "str" : null
        };
    
        nodes.push(node);
        renderNode(node);
        updateCode();
    }
    
    /*=============================================================================
        5. NODE RENDERING
    =============================================================================*/
    function renderNode(node) {
        const el = document.createElement("div");
        el.className = `node shape-${node.type}`;
        el.id = node.id;
        el.style.left = `${node.x}px`;
        el.style.top = `${node.y}px`;
    
        el.innerHTML = `<div class="inner-text">${node.text}</div>`;
    
        if (node.type === "input") {
            const badge = document.createElement("div");
            badge.className = `node-badge ${node.dataType}`;
            badge.textContent = node.dataType.toUpperCase();
            el.appendChild(badge);
        }
    
        el.onmousedown = e => startDragNode(e, node.id);
        el.ondblclick = () => editNode(node.id);
        el.onclick = e => { e.stopPropagation(); selectNode(node.id); };
    
        addPorts(el, node);
        nodesLayer.appendChild(el);
    }
    
    /*=============================================================================
        6. PORTS FOR EACH NODE TYPE
    =============================================================================*/
    function addPorts(el, node) {
        const add = (cls, port) => {
            const dot = document.createElement("div");
            dot.className = `dot ${cls}`;
            dot.onmousedown = e => { e.stopPropagation(); startConnection(node.id, port); };
            dot.onmouseup = e => { e.stopPropagation(); finishConnection(node.id); };
            el.appendChild(dot);
        };
    
        switch (node.type) {
            case "start":
                add("out", "next");
                break;
    
            case "end":
                add("in", "in");
                break;
    
            case "decision":
                add("in", "in");
                add("out-yes", "yes");
                add("out-no", "no");
                break;
    
            default:
                add("in", "in");
                add("out", "next");
        }
    }
    
    /*=============================================================================
        7. NODE SELECTION & DELETION
    =============================================================================*/
    function selectNode(id) {
        document.querySelectorAll(".node").forEach(n => n.classList.remove("selected"));
        document.getElementById(id).classList.add("selected");
    }
    
    window.addEventListener("keydown", e => {
        if ((e.key === "Delete" || e.key === "Backspace") &&
            !["INPUT", "TEXTAREA"].includes(e.target.tagName)) {
    
            const sel = document.querySelector(".node.selected");
            if (!sel) return;
    
            nodes = nodes.filter(n => n.id !== sel.id);
            connections = connections.filter(c => c.from !== sel.id && c.to !== sel.id);
    
            sel.remove();
            drawConnections();
            updateCode();
        }
    });
    
    /*=============================================================================
        8. NODE DRAGGING
    =============================================================================*/
    let dragNodeId = null;
    let dragOffset = { x: 0, y: 0 };
    
    function startDragNode(e, id) {
        if (e.target.classList.contains("dot")) return;
    
        dragNodeId = id;
    
        const node = nodes.find(n => n.id === id);
        const rect = canvas.getBoundingClientRect();
    
        dragOffset.x = e.clientX - rect.left - node.x;
        dragOffset.y = e.clientY - rect.top - node.y;
    
        document.addEventListener("mousemove", dragMove);
        document.addEventListener("mouseup", dragEnd);
    
        selectNode(id);
    }
    
    function dragMove(e) {
        if (!dragNodeId) return;
    
        const node = nodes.find(n => n.id === dragNodeId);
        const rect = canvas.getBoundingClientRect();
    
        node.x = e.clientX - rect.left - dragOffset.x;
        node.y = e.clientY - rect.top - dragOffset.y;
    
        const el = document.getElementById(node.id);
        el.style.left = `${node.x}px`;
        el.style.top = `${node.y}px`;
    
        drawConnections();
    }
    
    function dragEnd() {
        dragNodeId = null;
        document.removeEventListener("mousemove", dragMove);
        document.removeEventListener("mouseup", dragEnd);
        updateCode();
    }
    
    /*=============================================================================
        9. CONNECTION ENGINE — STRICT MODE
    =============================================================================*/

    
    function liveDragLine(e) {
        if (!isConnecting || !dragLine) return;
    
        const rect = canvas.getBoundingClientRect();
        const p1 = getPortXY(connStart.nodeId, connStart.portType);
    
        dragLine.setAttribute(
            "d",
            `M ${p1.x} ${p1.y} L ${e.clientX - rect.left} ${e.clientY - rect.top}`
        );
    }
    



    
    /*=============================================================================
        11. FX3 BAD CONNECTION FEEDBACK (SHAKE + RED)
    =============================================================================*/
    function badLinkFX(nodeId) {
        const el = document.getElementById(nodeId);
        if (!el) return;
    
        el.style.transition = "0.15s";
        el.style.transform = "translateX(-5px)";
        el.style.borderColor = "#dc3545";
    
        setTimeout(() => { el.style.transform = "translateX(5px)"; }, 100);
        setTimeout(() => {
            el.style.transform = "translateX(0)";
            el.style.borderColor = "";
        }, 200);
    }
    
    /*=============================================================================
        12. PORT GEOMETRY
    =============================================================================*/
    function getPortXY(nodeId, portType) {
        const el = document.getElementById(nodeId);
        const rectCanvas = canvas.getBoundingClientRect();
    
        let cls =
            portType === "yes" ? "out-yes" :
            portType === "no"  ? "out-no" :
            portType === "next" ? "out" : portType;
    
        const dot = el.querySelector(`.dot.${cls}`);
    
        if (dot) {
            const r = dot.getBoundingClientRect();
            return { x: r.left - rectCanvas.left + 5, y: r.top - rectCanvas.top + 5 };
        }
    
        const r = el.getBoundingClientRect();
        return {
            x: r.left - rectCanvas.left + r.width / 2,
            y: portType === "in"
                ? r.top - rectCanvas.top
                : r.bottom - rectCanvas.top
        };
    }
    
    /*=============================================================================
        13. DRAW CONNECTIONS (orthogonal, safe defs)
    =============================================================================*/

    
    function orthPath(p1, p2) {
        const mid = (p1.y + p2.y) / 2;
        return `M ${p1.x} ${p1.y} L ${p1.x} ${mid} L ${p2.x} ${mid} L ${p2.x} ${p2.y}`;
    }
    
    /*=============================================================================
        14. M1 MERGE DETECTION + MB1 AUTOPASS
    =============================================================================*/
    function autoPass(nodeId, port) {
        const c = connections.find(x => x.from === nodeId && x.port === port);
        return c ? c.to : null;
    }
    
    function findMerge(a, b) {
        if (!a && !b) return null;
if (a === b) return a;
if (!a || !b) return null;

    
        const visitedA = new Set();
        const visitedB = new Set();
    
        const walk = (start, set) => {
            let q = [start];
            while (q.length) {
                const u = q.shift();
                if (set.has(u)) continue;
                set.add(u);
                connections
                    .filter(c => c.from === u)
                    .forEach(c => q.push(c.to));
            }
        };
    
        walk(a, visitedA);
        walk(b, visitedB);
    
        for (const id of visitedA)
            if (visitedB.has(id)) return id;
    
        return null;
    }
    
    /*=============================================================================
        15. LOOP DETECTION (back edges)
    =============================================================================*/
    function detectBackEdges(startId) {
        const visited = new Set();
        const stack = new Set();
        const back = [];
    
        function dfs(u) {
            visited.add(u);
            stack.add(u);
    
            connections
                .filter(c => c.from === u)
                .forEach(e => {
                    if (!visited.has(e.to)) dfs(e.to);
                    else if (stack.has(e.to)) back.push({ from: u, to: e.to });
                });
    
            stack.delete(u);
        }
    
        dfs(startId);
        return back;
    }
    
    /*=============================================================================
        16. LOOP CLASSIFICATION (for / while / do-while)
    =============================================================================*/
    function classifyLoops(startId) {
        const edges = detectBackEdges(startId);
        const info = new Map();
    
        edges.forEach(be => {
            const header = be.to;
            if (info.has(header)) return;
    
            const set = new Set([header]);
            const queue = [be.from];
    
            while (queue.length) {
                const u = queue.shift();
                set.add(u);
                connections
                    .filter(c => c.to === u)
                    .map(c => c.from)
                    .forEach(v => {
                        if (!set.has(v)) queue.push(v);
                    });
            }
    
            let controller = null;
            const exits = [];
    
            set.forEach(id => {
                const n = nodes.find(x => x.id === id);
                connections
                    .filter(c => c.from === id)
                    .forEach(c => {
                        if (!set.has(c.to)) exits.push(c);
                        if (n.type === "decision") controller = id;
                    });
            });
    
            if (!controller) controller = be.from;
    
            info.set(header, {
                type: "while-true",
                header,
                controller,
                nodes: set,
                exits
            });
        });
    
        return info;
    }
    /*=============================================================================
    EDIT NODE MODAL (E1 — Full Editor)
=============================================================================*/
let currentEditId = null;

function editNode(id) {
    currentEditId = id;
    const node = nodes.find(n => n.id === id);
    const body = document.getElementById("editNodeBody");
    const title = document.getElementById("editNodeTitle");

    if (!node) return;

    title.textContent = `Edit ${node.type.toUpperCase()} Node`;

    let html = "";

    html += `
        <label class="fw-bold small">Text</label>
        <input id="edit-node-text" class="form-control mb-2" value="${node.text}">
    `;

    if (node.type === "input") {
        html += `
            <label class="fw-bold small mt-2">Input Data Type</label>
            <select id="edit-node-type" class="form-select mb-2">
                <option value="str" ${node.dataType === "str" ? "selected" : ""}>String</option>
                <option value="int" ${node.dataType === "int" ? "selected" : ""}>Integer</option>
                <option value="float" ${node.dataType === "float" ? "selected" : ""}>Float</option>
            </select>
        `;
    }

    body.innerHTML = html;

    const modal = bootstrap.Modal.getOrCreateInstance(document.getElementById("editNodeModal"));
    modal.show();
}

function saveNodeEdit() {
    const node = nodes.find(n => n.id === currentEditId);
    if (!node) return;

    const newText = document.getElementById("edit-node-text").value;

    node.text = newText;

    if (node.type === "input") {
        node.dataType = document.getElementById("edit-node-type").value;
    }

    // re-render node text
    const el = document.getElementById(node.id);
    el.querySelector(".inner-text").textContent = node.text;

    // update badge for input
    const badge = el.querySelector(".node-badge");
    if (badge && node.type === "input") badge.textContent = node.dataType.toUpperCase();

    const modal = bootstrap.Modal.getInstance(document.getElementById("editNodeModal"));
    modal.hide();

    updateCode();
}

    /*=============================================================================
        17. S2 COMPILER (STRICT SINGLE GRAPH)
    =============================================================================*/
    let generatedCode = "";
    /*=============================================================================
    FOR LOOP INFERENCE (L1)
=============================================================================*/
function detectForLoop(candidateNodes) {
    const body = Array.from(candidateNodes).map(id => nodes.find(n => n.id === id));
    const assigns = body.filter(n => n.type === "var" || n.type === "process");

    let init = null;
    let inc = null;
    let cond = null;

    assigns.forEach(n => {
        const t = n.text.replace(/\s+/g, "");

        // init: i = 0
        if (/^[a-zA-Z_]\w*=0$/.test(t)) init = n;

        // condition: i < N
        if (/^[a-zA-Z_]\w*<.+$/.test(t)) cond = n;

        // increment: i = i + 1 OR i += 1
 // increment: i = i + 1
const incMatch = t.match(/^([a-zA-Z_]\w*)=([a-zA-Z_]\w*)\+1$/);
if (incMatch && incMatch[1] === incMatch[2]) {
    inc = n;
}

// increment: i += 1
if (/^[a-zA-Z_]\w*\+=1$/.test(t)) {
    inc = n;
}

    });

    if (init && inc && cond) {
        return {
            variable: init.text.split("=")[0].trim(),
            initNode: init.id,
            incNode: inc.id,
            condNode: cond.id
        };
    }
    return null;
}


   
    
    /*=============================================================================
        18. RUNTIME + HIGHLIGHT HOOK
    =============================================================================*/
    function log(msg, type = "info") {
        const div = document.createElement("div");
        div.style.color =
            type === "error" ? "#ff6b6b" :
            type === "input" ? "#74c0fc" :
            "#b2f2bb";
        div.textContent = msg;
        consoleDiv.appendChild(div);
        consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }
    
    function highlightNode(id) {
        document.querySelectorAll(".node").forEach(n => n.classList.remove("running"));
        const el = document.getElementById(id);
        if (el) el.classList.add("running");
    }
    

    
    
    function clearCanvas() {
    if (!confirm("Clear all nodes?")) return;

    nodes = [];
    connections = [];
    nodesLayer.innerHTML = "";
    drawConnections();
    updateCode();
}


// flowcode-patched.js
// Combined patch for FlowCode v1 (STRICT MODE + S2 COMPILER + FX3 + M1 + MB1)
// Drop this at the end of your HTML: <script src="flowcode-patched.js"></script>

/*****************************************************************************************
 * 1. Strict Port Validation + Connection Handling
 *****************************************************************************************/
function validateStrict(start, targetId) {
    const from = nodes.find(n => n.id === start.nodeId);
    const to = nodes.find(n => n.id === targetId);
    if (!from || !to) return false;
    if (start.nodeId === targetId) return false;
    if (to.type === "start") return false;
    if (from.type === "end") return false;
    if (start.portType === "in") return false;
    return true;
}

function badLinkFX(nodeId) {
    const el = document.getElementById(nodeId);
    if (!el) return;
    el.style.transition = "0.15s";
    el.style.transform = "translateX(-5px)";
    el.style.borderColor = "#dc3545";
    setTimeout(() => { el.style.transform = "translateX(5px)"; }, 100);
    setTimeout(() => {
        el.style.transform = "translateX(0)";
        el.style.borderColor = "";
    }, 200);
}

function startConnection(nodeId, portType) {
    isConnecting = true;
    connStart = { nodeId, portType };
    dragLine = document.createElementNS("http://www.w3.org/2000/svg", "path");
    dragLine.setAttribute("stroke", "#0d6efd");
    dragLine.setAttribute("stroke-width", "2");
    dragLine.setAttribute("stroke-dasharray", "5,5");
    dragLine.setAttribute("fill", "none");
    svgLayer.appendChild(dragLine);
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", abortConnection);
}

function finishConnection(targetId) {
    if (!isConnecting || !connStart) return;
    const ok = validateStrict(connStart, targetId);
    if (!ok) {
        badLinkFX(connStart.nodeId);
        abortConnection();
        return;
    }
    connections = connections.filter(c => !(c.from === connStart.nodeId && c.port === connStart.portType));
    connections.push({ from: connStart.nodeId, port: connStart.portType, to: targetId });
    drawConnections();
    updateCode();
    abortConnection();
}

function abortConnection() {
    isConnecting = false;
    connStart = null;
    if (dragLine) dragLine.remove();
    dragLine = null;
    document.removeEventListener("mousemove", onMouseMove);
    document.removeEventListener("mouseup", abortConnection);
}

/*****************************************************************************************
 * 2. Merge Detection (M1) + Auto-Pass (MB1)
 *****************************************************************************************/
function autoPass(nodeId, port) {
    const c = connections.find(x => x.from === nodeId && x.port === port);
    return c ? c.to : null;
}

function findMerge(a, b) {
    if (!a && !b) return null;
    if (a === b) return a;
    if (!a || !b) return null;
    const visitedA = new Set();
    const visitedB = new Set();
    const walk = (start, set) => {
        let q = [start];
        while (q.length) {
            const u = q.shift();
            if (set.has(u)) continue;
            set.add(u);
            connections.filter(c => c.from === u).forEach(c => q.push(c.to));
        }
    };
    walk(a, visitedA);
    walk(b, visitedB);
    for (const id of visitedA)
        if (visitedB.has(id)) return id;
    return null;
}

/*****************************************************************************************
 * 3. Loop Detection + Classification (for / while / do-while)
 *****************************************************************************************/
function detectBackEdges(startId) {
    const visited = new Set();
    const stack = new Set();
    const back = [];
    function dfs(u) {
        visited.add(u);
        stack.add(u);
        connections.filter(c => c.from === u).forEach(e => {
            if (!visited.has(e.to)) dfs(e.to);
            else if (stack.has(e.to)) back.push({ from: u, to: e.to });
        });
        stack.delete(u);
    }
    dfs(startId);
    return back;
}

function classifyLoops(startId) {
    const edges = detectBackEdges(startId);
    const info = new Map();
    edges.forEach(be => {
        const header = be.to;
        if (info.has(header)) return;
        const set = new Set([header]);
        const queue = [be.from];
        while (queue.length) {
            const u = queue.shift();
            set.add(u);
            connections.filter(c => c.to === u).map(c => c.from).forEach(v => {
                if (!set.has(v)) queue.push(v);
            });
        }
        let controller = null;
        const exits = [];
        set.forEach(id => {
            const n = nodes.find(x => x.id === id);
            connections.filter(c => c.from === id).forEach(c => {
                if (!set.has(c.to)) exits.push(c);
                if (n.type === "decision") controller = id;
            });
        });
        if (!controller) controller = be.from;
        info.set(header, {
            type: "while-true",
            header,
            controller,
            nodes: set,
            exits
        });
    });
    return info;
}

/*****************************************************************************************
 * 4. Compiler (S2) ā€” For / While / Do-While / If-Else / Merge-Aware / Indented
 *****************************************************************************************/
function updateCode() {
    const box = document.getElementById("code-python");
    const start = nodes.find(n => n.type === "start");
    if (!start) {
        box.innerHTML = '<span class="comment"># Add a Start node</span>';
        return;
    }
    const code = [];
    const html = [];
    code.push("import time", "");
    const loopInfo = classifyLoops(start.id);
    const processed = new Set();
    const edges = connections.reduce((acc, c) => {
        if (!acc[c.from]) acc[c.from] = [];
        acc[c.from].push(c);
        return acc;
    }, {});

    function walk(u, indent, stop) {
        if (!u || u === stop) return;
        if (processed.has(u)) return;
        const node = nodes.find(n => n.id === u);
        const sp = "    ".repeat(indent);
        if (loopInfo.has(u)) return emitLoop(u, indent, stop);
        processed.add(u);
        code.push(`${sp}highlight_node("${u}")`);
        if (!node) return;
        if (node.type === "end") {
            code.push(`${sp}exit()`); html.push(`${sp}exit()`); return;
        }
        if (node.type === "var" || node.type === "process") {
            code.push(`${sp}${node.text}`); html.push(`${sp}${node.text}`);
        } else if (node.type === "output") {
            const val = node.text.replace(/^Print\s*/i, "").trim();
            code.push(`${sp}print(${val})`); html.push(`${sp}print(${val})`);
        } else if (node.type === "input") {
            let raw = node.text.replace(/^Input\s+/i, "").trim();
            let [v, msg] = raw.split("=").map(x => x.trim());
            if (!msg) msg = `"Enter value for ${v}"`;
            if (!/^["'].*["']$/.test(msg)) msg = `"${msg}"`;
            const dt = node.dataType;
            if (dt === "int") {
                code.push(`${sp}${v} = int(input(${msg}))`);
                html.push(`${sp}${v} = int(input(${msg}))`);
            } else if (dt === "float") {
                code.push(`${sp}${v} = float(input(${msg}))`);
                html.push(`${sp}${v} = float(input(${msg}))`);
            } else {
                code.push(`${sp}${v} = input(${msg})`);
                html.push(`${sp}${v} = input(${msg})`);
            }
        } else if (node.type === "decision") {
            emitDecision(u, indent, stop);
            return;
        }
        const outs = edges[u] || [];
        if (outs.length) walk(outs[0].to, indent, stop);
    }

    function emitDecision(u, indent, stop) {
        const yes = autoPass(u, "yes");
        const no = autoPass(u, "no");
        const merge = findMerge(yes, no);
        const node = nodes.find(n => n.id === u);
        const cond = node.text.replace(/([^=!<>])=([^=])/g, "$1==$2");
        const sp = "    ".repeat(indent);
        code.push(`${sp}if ${cond}:`);
        walk(yes, indent + 1, merge);
        code.push(`${sp}else:`);
        walk(no, indent + 1, merge);
        if (merge) walk(merge, indent, stop);
    }

    function emitLoop(h, indent, stop) {
        const info = loopInfo.get(h);
        const sp = "    ".repeat(indent);
        const ctrl = nodes.find(n => n.id === info.controller);
        let cond = ctrl.text.replace(/([^=!<>])=([^=])/g, "$1==$2");
        const exitPort = info.exits[0].port;
        const breakCond = exitPort === "yes" ? cond : `not (${cond})`;
        code.push(`${sp}while True:`);
        code.push(`${sp}    highlight_node("${h}")`);
        connections.filter(c => c.from === h && c.port !== "in").forEach(c => walk(c.to, indent + 1, h));
        code.push(`${sp}    highlight_node("${info.controller}")`);
        code.push(`${sp}    if ${breakCond}: break`);
        const next = info.exits[0];
        walk(next.to, indent, stop);
    }

    walk(start.id, 0, null);
    generatedCode = code.join("
");
    box.innerText = html.join("
");
}

/*****************************************************************************************
 * 5. Skulpt Runtime Hook + Simulation Controls
 *****************************************************************************************/
function highlightNode(id) {
    document.querySelectorAll(".node").forEach(n => n.classList.remove("running"));
    const el = document.getElementById(id);
    if (el) el.classList.add("running");
}

Sk.builtins.highlight_node = function(id) {
    if (!isRunning) throw "ExecutionStopped";
    const n = typeof id === "string" ? id : id.v;
    highlightNode(n);
    const delay = parseInt(document.getElementById("speed-slider").value) || 800;
    return new Sk.misceval.promiseToSuspension(new Promise(resolve => setTimeout(resolve, delay)));
};

async function runSimulation() {
    if (isRunning) return;
    isRunning = true;
    document.getElementById("btn-run").style.display = "none";
    document.getElementById("btn-stop").style.display = "inline-block";
    consoleDiv.innerHTML = "";
    updateCode();
    try {
        await Sk.misceval.asyncToPromise(() => Sk.importMainWithBody("<stdin>", false, generatedCode, true));
        log("Program Finished.");
    } catch (e) {
        if (e.toString() !== "ExecutionStopped") log(e.toString(), "error");
    } finally {
        stopSimulation();
    }
}

function stopSimulation() {
    isRunning = false;
    document.getElementById("btn-run").style.display = "inline-block";
    document.getElementById("btn-stop").style.display = "none";
    document.querySelectorAll(".node").forEach(n => n.classList.remove("running"));
    const modalEl = document.getElementById("inputModal");
    const modal = bootstrap.Modal.getInstance(modalEl);
    if (modal) modal.hide();
}
    
    /*=============================================================================
        19. INITIAL DEMO
    =============================================================================*/
    setTimeout(() => {
        nodes = [];
        connections = [];
        nodesLayer.innerHTML = "";
        nextId = 1;
    
        createNode("start", 80, 40);
        createNode("end", 80, 300);
    
        updateCode();
    }, 200);
    
    </script>
    

</body>
</html>
