<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowCode</title>

    <!-- FONTS -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <!-- BOOTSTRAP 5 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- FONT AWESOME -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- SKULPT (Python Engine) -->
    <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt-stdlib.js"></script>

    <style>
        :root {
            --bg-canvas: #f0f2f5;
            --grid-color: #e0e0e0;
            --node-bg: #ffffff;
            --node-border: #343a40;
            --accent: #0d6efd;
            --console-bg: #1e1e1e;
        }

        body { font-family: 'Inter', sans-serif; height: 100vh; overflow: hidden; background-color: #fff; }
        .wrapper { height: 100vh; display: flex; flex-direction: column; }
        .main-area { flex: 1; display: flex; overflow: hidden; }

        /* PALETTE */
        #palette {
            width: 250px; background: #fff; border-right: 1px solid #dee2e6;
            padding: 15px; overflow-y: auto; display: flex; flex-direction: column; z-index: 10;
        }
        .palette-header { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; color: #adb5bd; font-weight: 700; margin: 15px 0 5px 0; }
        .palette-item {
            cursor: grab; margin-bottom: 8px; padding: 8px 12px;
            border: 1px solid #dee2e6; border-radius: 6px; background: white;
            display: flex; align-items: center; gap: 10px; font-size: 0.9rem; font-weight: 600; color: #495057;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .palette-item:hover { border-color: var(--accent); color: var(--accent); transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.05); }

        /* CANVAS */
        #canvas {
            flex: 1; background-color: var(--bg-canvas); position: relative; overflow: hidden;
            background-image: radial-gradient(#ced4da 1px, transparent 1px); background-size: 20px 20px;
        }

        /* OUTPUT PANEL */
        #output-panel {
            width: 450px; display: flex; flex-direction: column; border-left: 1px solid #dee2e6;
            background: #fff; z-index: 10; height: 100%;
        }
        .panel-toolbar { padding: 10px; background: #f8f9fa; border-bottom: 1px solid #dee2e6; display: flex; justify-content: space-between; align-items: center; }
        .code-display {
            flex: 1; padding: 15px; font-family: 'JetBrains Mono', monospace; font-size: 12px;
            color: #212529; overflow-y: auto; white-space: pre; border-bottom: 1px solid #dee2e6;
        }
        .code-line { min-height: 18px; }
        
        /* SYNTAX HIGHLIGHTING */
        .kw { color: #d63384; font-weight: bold; } /* keyword */
        .fn { color: #0d6efd; } /* function */
        .str { color: #198754; } /* string */
        .cmt { color: #6c757d; font-style: italic; } /* comment */
        .num { color: #fd7e14; } /* number */

        #console-container { height: 200px; background: var(--console-bg); display: flex; flex-direction: column; }
        #console-header { padding: 5px 10px; background: #000; color: #fff; font-size: 10px; font-weight: bold; display: flex; justify-content: space-between; }
        #console { flex: 1; color: #f8f9fa; padding: 10px; font-family: 'JetBrains Mono', monospace; font-size: 12px; overflow-y: auto; }

        /* NODES */
        .node {
            position: absolute; background: white; border: 2px solid var(--node-border);
            color: #212529; cursor: pointer; user-select: none;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.1); z-index: 2;
            font-size: 13px; font-weight: 600; text-align: center;
            transition: border-color 0.1s, box-shadow 0.1s;
        }
        .node:hover { border-color: var(--accent); }
        .node.selected { border-color: #dc3545; box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.2); }
        .node.running { 
            background-color: #fff3cd; border-color: #ffc107; 
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.5); transform: scale(1.02); z-index: 100; 
        }

        /* SHAPES */
        .shape-start, .shape-end { width: 100px; height: 40px; border-radius: 20px; background: #212529; color: white; border: none; }
        .shape-process { width: 140px; height: 50px; border-radius: 4px; }
        .shape-var { width: 140px; height: 50px; border-radius: 4px; border-left: 5px solid #fd7e14; }
        .shape-decision { width: 90px; height: 90px; transform: rotate(45deg); border-radius: 0; }
        .shape-decision .inner { transform: rotate(-45deg); width: 130%; pointer-events: none; line-height: 1.1; font-size: 11px;}
        .shape-input, .shape-output { width: 130px; height: 50px; transform: skew(-15deg); border-radius: 2px; margin-left: 10px; }
        .shape-input .inner, .shape-output .inner { transform: skew(15deg); width: 100%; pointer-events: none; }
        .shape-input { border-left: 4px solid #0d6efd; }
        .shape-output { border-left: 4px solid #198754; }

        /* PORTS */
        .dot { 
            width: 10px; height: 10px; background: #fff; border: 2px solid #495057; border-radius: 50%; 
            position: absolute; cursor: crosshair; z-index: 5; transition: 0.2s; 
        }
        .dot:hover { background: var(--accent); transform: scale(1.4); }
        
        /* Port Positioning */
        .top-cntr { top: -6px; left: 50%; transform: translateX(-50%); }
        .bot-cntr { bottom: -6px; left: 50%; transform: translateX(-50%); }
        
        /* Skewed Ports */
        .skew-in { top: -6px; left: 50%; margin-left: -5px; transform: skew(15deg); }
        .skew-out { bottom: -6px; left: 50%; margin-left: -5px; transform: skew(15deg); }

        /* Decision Ports */
        .dec-in { top: -6px; left: -6px; }
        .dec-yes { bottom: -6px; right: -6px; background: #198754; border-color: #198754; }
        .dec-no { top: -6px; right: -6px; background: #dc3545; border-color: #dc3545; }

        /* SVG Connections */
        svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
        .conn-label { position: absolute; font-size: 10px; font-weight: bold; background: white; padding: 1px 4px; border-radius: 3px; border: 1px solid #dee2e6; z-index: 2; pointer-events: none; }
        
        /* Badges */
        .node-badge { position: absolute; top: -8px; right: -5px; font-size: 8px; padding: 2px 5px; border-radius: 4px; color: white; font-weight: bold; z-index: 6; }
        .bg-int { background: #fd7e14; } .bg-str { background: #198754; } .bg-float { background: #6610f2; }
    </style>
</head>
<body>

<nav class="navbar navbar-dark bg-dark border-bottom border-secondary py-1">
    <div class="container-fluid">
        <span class="navbar-brand d-flex align-items-center gap-2 fs-6">
            <i class="fa-solid fa-diagram-project text-white"></i>
            <span class="fw-bold">FlowCode</span> <span class="badge bg-warning text-dark" style="font-size:0.6rem;">v0.4</span>
        </span>
        <div class="d-flex gap-2">
            <button class="btn btn-outline-light btn-sm py-0" onclick="clearCanvas()"><i class="fa-solid fa-trash"></i> Reset</button>
        </div>
    </div>
</nav>

<div class="wrapper">
    <div class="main-area">
        <!-- PALETTE -->
        <div id="palette">
            <div class="palette-header">Flow</div>
            <div class="palette-item" draggable="true" data-type="start"><i class="fa-regular fa-circle-play"></i> Start</div>
            <div class="palette-item" draggable="true" data-type="end"><i class="fa-regular fa-circle-stop"></i> End</div>
            
            <div class="palette-header">Data</div>
            <div class="palette-item" draggable="true" data-type="var"><i class="fa-solid fa-cube"></i> Set Variable</div>
            <div class="palette-item" draggable="true" data-type="input"><i class="fa-solid fa-keyboard"></i> Input</div>
            <div class="palette-item" draggable="true" data-type="output"><i class="fa-solid fa-terminal"></i> Print</div>

            <div class="palette-header">Logic</div>
            <div class="palette-item" draggable="true" data-type="process"><i class="fa-solid fa-microchip"></i> Process</div>
            <div class="palette-item" draggable="true" data-type="decision"><i class="fa-solid fa-diamond"></i> Decision</div>
        </div>

        <!-- CANVAS -->
        <div id="canvas">
            <svg id="connections-layer">
                <defs><marker id="arrowhead" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#555" /></marker></defs>
            </svg>
            <div id="nodes-layer"></div>
        </div>

        <!-- RIGHT PANEL -->
        <div id="output-panel">
            <div class="panel-toolbar">
                <div class="d-flex align-items-center gap-2">
                    <i class="fa-brands fa-python"></i> <span class="fw-bold small">Generated Code</span>
                </div>
                <div class="d-flex align-items-center gap-2">
                    <input type="range" class="form-range" id="speed-slider" min="100" max="1500" value="600" style="width: 70px;" title="Execution Speed">
                    <button id="btn-run" class="btn btn-success btn-sm fw-bold" onclick="compileAndRun()"><i class="fa-solid fa-play"></i> RUN</button>
                    <button id="btn-stop" class="btn btn-danger btn-sm fw-bold" onclick="stopExecution()" style="display:none;"><i class="fa-solid fa-stop"></i> STOP</button>
                </div>
            </div>

            <div id="code-display" class="code-display"><span class="cmt"># Drag nodes to generate code...</span></div>
            
            <div id="console-container">
                <div id="console-header"><span>TERMINAL</span><i class="fa-solid fa-terminal"></i></div>
                <div id="console"></div>
            </div>
        </div>
    </div>
</div>

<!-- EDIT MODAL -->
<div class="modal fade" id="editModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered modal-sm">
        <div class="modal-content">
            <div class="modal-header py-2 bg-light">
                <h6 class="modal-title fw-bold">Properties</h6>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body" id="editBody"></div>
            <div class="modal-footer py-1">
                <button type="button" class="btn btn-primary btn-sm w-100" onclick="saveNodeData()">Apply</button>
            </div>
        </div>
    </div>
</div>

<!-- INPUT MODAL -->
<div class="modal fade" id="runtimeInputModal" data-bs-backdrop="static">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header py-2">
                <h6 class="modal-title fw-bold">Input Required</h6>
            </div>
            <div class="modal-body">
                <p id="runtime-prompt" class="mb-1 small text-muted">Value:</p>
                <input type="text" id="runtime-val" class="form-control font-monospace" autocomplete="off">
            </div>
            <div class="modal-footer py-1">
                <button id="runtime-submit" class="btn btn-success btn-sm w-100">Submit</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
/**
 * CORE DATA STRUCTURES
 */
let nodes = [];
let connections = [];
let nextId = 1;
let isRunning = false;
let executionStopFlag = false;
let editingId = null;

// DOM Elements
const canvas = document.getElementById('canvas');
const svgLayer = document.getElementById('connections-layer');
const nodesLayer = document.getElementById('nodes-layer');
const consoleDiv = document.getElementById('console');
const codeDisplay = document.getElementById('code-display');

// Initialize
function init() {
    createNode('start', 50, 50);
    createNode('end', 50, 400);
    renderGraph();
}

/**
 * GRAPH MANIPULATION
 */
function createNode(type, x, y) {
    const id = `node_${nextId++}`;
    let node = { id, type, x, y, text: "", data: {} };
    
    // Defaults
    if(type === 'start') node.text = "Start";
    if(type === 'end') node.text = "End";
    if(type === 'process') node.text = "x = x + 1";
    if(type === 'decision') node.text = "x < 10";
    if(type === 'var') { node.text = "x = 0"; node.data = { name:'x', val:'0', type:'int' }; }
    if(type === 'input') { node.text = "Input x"; node.data = { var:'x', prompt:'Enter value', type:'str' }; }
    if(type === 'output') { node.text = "Print x"; node.data = { val:'x' }; }
    
    nodes.push(node);
    renderNode(node);
    generateCode(); // Live update
}

function renderNode(node) {
    const el = document.createElement('div');
    el.id = node.id;
    el.className = `node shape-${node.type}`;
    el.style.left = node.x + 'px';
    el.style.top = node.y + 'px';
    
    let content = `<div class="inner">${escapeHtml(node.text)}</div>`;
    
    // Visual Badges
    if(node.type === 'var' || node.type === 'input') {
        const typeShort = (node.data.type || 'str').toUpperCase();
        content += `<span class="node-badge bg-${node.data.type || 'str'}">${typeShort}</span>`;
    }
    
    el.innerHTML = content;
    
    // Events
    el.onmousedown = (e) => startDrag(e, node.id);
    el.ondblclick = () => openEditModal(node.id);
    el.onclick = (e) => { e.stopPropagation(); selectNode(node.id); };
    
    // Ports
    if(node.type === 'start') addPort(el, node.id, 'out', 'bot-cntr');
    else if(node.type === 'end') addPort(el, node.id, 'in', 'top-cntr');
    else if(node.type === 'decision') {
        addPort(el, node.id, 'in', 'dec-in');
        addPort(el, node.id, 'yes', 'dec-yes');
        addPort(el, node.id, 'no', 'dec-no');
    } else if (['input','output'].includes(node.type)) {
        addPort(el, node.id, 'in', 'skew-in');
        addPort(el, node.id, 'out', 'skew-out');
    } else {
        addPort(el, node.id, 'in', 'top-cntr');
        addPort(el, node.id, 'out', 'bot-cntr');
    }
    
    nodesLayer.appendChild(el);
}

function addPort(parent, nodeId, type, cssClass) {
    const dot = document.createElement('div');
    dot.className = `dot ${cssClass}`;
    dot.dataset.type = type;
    dot.onmousedown = (e) => startConnection(e, nodeId, type);
    parent.appendChild(dot);
}

/**
 * EDITING LOGIC
 */
function openEditModal(id) {
    editingId = id;
    const node = nodes.find(n => n.id === id);
    if(!node) return;
    
    const body = document.getElementById('editBody');
    let html = '';
    
    if(node.type === 'var') {
        html = `
            <div class="mb-2"><label class="form-label small fw-bold">Variable Name</label><input id="inp-var" class="form-control form-control-sm" value="${node.data.name}"></div>
            <div class="mb-2"><label class="form-label small fw-bold">Value</label><input id="inp-val" class="form-control form-control-sm" value="${node.data.val}"></div>
            <div class="mb-2"><label class="form-label small fw-bold">Type</label>
                <select id="inp-type" class="form-select form-select-sm">
                    <option value="int" ${node.data.type==='int'?'selected':''}>Integer</option>
                    <option value="float" ${node.data.type==='float'?'selected':''}>Float</option>
                    <option value="str" ${node.data.type==='str'?'selected':''}>String</option>
                </select></div>`;
    } else if(node.type === 'input') {
        html = `
            <div class="mb-2"><label class="form-label small fw-bold">Store in Variable</label><input id="inp-var" class="form-control form-control-sm" value="${node.data.var}"></div>
            <div class="mb-2"><label class="form-label small fw-bold">Prompt Text</label><input id="inp-prompt" class="form-control form-control-sm" value="${node.data.prompt}"></div>
            <div class="mb-2"><label class="form-label small fw-bold">Input Type</label>
                <select id="inp-type" class="form-select form-select-sm">
                    <option value="str" ${node.data.type==='str'?'selected':''}>String</option>
                    <option value="int" ${node.data.type==='int'?'selected':''}>Integer</option>
                    <option value="float" ${node.data.type==='float'?'selected':''}>Float</option>
                </select></div>`;
    } else if(node.type === 'output') {
        html = `<div class="mb-2"><label class="form-label small fw-bold">Expression to Print</label><input id="inp-val" class="form-control form-control-sm" value="${node.data.val}"></div>`;
    } else if(node.type === 'decision') {
        html = `<div class="mb-2"><label class="form-label small fw-bold">Condition (e.g. x < 10)</label><input id="inp-text" class="form-control form-control-sm" value="${node.text}"></div>`;
    } else if(node.type === 'process') {
        html = `<div class="mb-2"><label class="form-label small fw-bold">Statement (e.g. x = x + 1)</label><textarea id="inp-text" class="form-control form-control-sm" rows="3">${node.text}</textarea></div>`;
    } else {
        return; // Start/End
    }
    
    body.innerHTML = html;
    new bootstrap.Modal(document.getElementById('editModal')).show();
}

function saveNodeData() {
    const node = nodes.find(n => n.id === editingId);
    if(!node) return;
    
    if(node.type === 'var') {
        node.data.name = document.getElementById('inp-var').value.trim() || 'x';
        node.data.val = document.getElementById('inp-val').value.trim() || '0';
        node.data.type = document.getElementById('inp-type').value;
        const valDisp = node.data.type === 'str' ? `"${node.data.val}"` : node.data.val;
        node.text = `${node.data.name} = ${valDisp}`;
    } else if(node.type === 'input') {
        node.data.var = document.getElementById('inp-var').value.trim() || 'x';
        node.data.prompt = document.getElementById('inp-prompt').value.trim() || '';
        node.data.type = document.getElementById('inp-type').value;
        node.text = `Input ${node.data.var}`;
    } else if(node.type === 'output') {
        node.data.val = document.getElementById('inp-val').value.trim();
        node.text = `Print ${node.data.val}`;
    } else {
        const el = document.getElementById('inp-text');
        if(el) node.text = el.value.trim();
    }
    
    // Re-render only text/badge
    const el = document.getElementById(node.id);
    let inner = `<div class="inner">${escapeHtml(node.text)}</div>`;
    if(node.data && node.data.type) inner += `<span class="node-badge bg-${node.data.type}">${node.data.type.toUpperCase()}</span>`;
    el.innerHTML = inner;
    
    // Re-attach ports (innerHTML wipes them)
    if(node.type === 'decision') {
        addPort(el, node.id, 'in', 'dec-in'); addPort(el, node.id, 'yes', 'dec-yes'); addPort(el, node.id, 'no', 'dec-no');
    } else if (['input','output'].includes(node.type)) {
        addPort(el, node.id, 'in', 'skew-in'); addPort(el, node.id, 'out', 'skew-out');
    } else if (node.type !== 'start' && node.type !== 'end') {
        addPort(el, node.id, 'in', 'top-cntr'); addPort(el, node.id, 'out', 'bot-cntr');
    } else if (node.type === 'start') addPort(el, node.id, 'out', 'bot-cntr');
    else if (node.type === 'end') addPort(el, node.id, 'in', 'top-cntr');

    bootstrap.Modal.getInstance(document.getElementById('editModal')).hide();
    generateCode();
}

/**
 * CONNECTIONS & DRAGGING
 */
let dragData = null;
let connData = null;

canvas.addEventListener('mousedown', (e) => {
    if(e.target === canvas) selectNode(null);
});
canvas.addEventListener('mousemove', (e) => {
    if(dragData) {
        const dx = e.clientX - dragData.startX;
        const dy = e.clientY - dragData.startY;
        const node = nodes.find(n=>n.id === dragData.id);
        node.x = dragData.origX + dx;
        node.y = dragData.origY + dy;
        const el = document.getElementById(dragData.id);
        el.style.left = node.x + 'px'; el.style.top = node.y + 'px';
        renderConnections();
    }
    if(connData) {
        renderTempLine(e.clientX, e.clientY);
    }
});
canvas.addEventListener('mouseup', () => {
    if(dragData) { dragData = null; generateCode(); }
    if(connData) { svgLayer.innerHTML=''; renderConnections(); connData=null; }
});
canvas.addEventListener('dragover', e => e.preventDefault());
canvas.addEventListener('drop', e => {
    e.preventDefault();
    const type = e.dataTransfer.getData('type');
    const rect = canvas.getBoundingClientRect();
    if(type) createNode(type, e.clientX - rect.left - 50, e.clientY - rect.top - 25);
});
document.querySelectorAll('.palette-item').forEach(i => {
    i.addEventListener('dragstart', e => e.dataTransfer.setData('type', i.dataset.type));
});
window.addEventListener('keydown', e => {
    if(e.key === 'Delete' && selectedNodeId) {
        nodes = nodes.filter(n => n.id !== selectedNodeId);
        connections = connections.filter(c => c.from !== selectedNodeId && c.to !== selectedNodeId);
        document.getElementById(selectedNodeId).remove();
        selectedNodeId = null;
        renderConnections();
        generateCode();
    }
});

function startDrag(e, id) {
    if(e.target.classList.contains('dot')) return;
    dragData = { id, startX: e.clientX, startY: e.clientY, origX: nodes.find(n=>n.id===id).x, origY: nodes.find(n=>n.id===id).y };
    selectNode(id);
}

function startConnection(e, nodeId, type) {
    e.stopPropagation();
    if(type === 'in') return; // Can't start from input
    // Limit outputs: If port already has connection, remove it
    connections = connections.filter(c => !(c.from === nodeId && c.port === type));
    
    const rect = canvas.getBoundingClientRect();
    connData = { from: nodeId, port: type, startX: e.clientX - rect.left, startY: e.clientY - rect.top };
}

// Global mouseup handler for connecting to target
document.addEventListener('mouseup', e => {
    if(connData && e.target.classList.contains('dot') && e.target.dataset.type === 'in') {
        const targetNodeId = e.target.parentElement.id;
        if(connData.from !== targetNodeId) { // No self loops directly
            connections.push({ from: connData.from, port: connData.port, to: targetNodeId });
            renderConnections();
            generateCode();
        }
    }
});

function renderTempLine(mx, my) {
    const rect = canvas.getBoundingClientRect();
    const ex = mx - rect.left;
    const ey = my - rect.top;
    
    // Redraw existing + temp
    renderConnections(); 
    
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const d = getPath(connData.startX, connData.startY, ex, ey, connData.port);
    line.setAttribute('d', d);
    line.setAttribute('stroke', '#0d6efd');
    line.setAttribute('stroke-width', '2');
    line.setAttribute('stroke-dasharray', '5,5');
    line.setAttribute('fill', 'none');
    svgLayer.appendChild(line);
}

function renderConnections() {
    svgLayer.innerHTML = '<defs><marker id="arrowhead" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#555" /></marker></defs>';
    document.querySelectorAll('.conn-label').forEach(e=>e.remove());
    
    connections.forEach(c => {
        const n1 = nodes.find(n=>n.id===c.from);
        const n2 = nodes.find(n=>n.id===c.to);
        if(!n1 || !n2) return;
        
        const p1 = getPortPos(n1, c.port);
        const p2 = getPortPos(n2, 'in');
        
        const d = getPath(p1.x, p1.y, p2.x, p2.y, c.port);
        const color = c.port === 'yes' ? '#198754' : (c.port === 'no' ? '#dc3545' : '#555');
        
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', d);
        path.setAttribute('stroke', color);
        path.setAttribute('stroke-width', '2');
        path.setAttribute('fill', 'none');
        path.setAttribute('marker-end', 'url(#arrowhead)');
        
        svgLayer.appendChild(path);
        
        if(c.port === 'yes' || c.port === 'no') {
            const lbl = document.createElement('div');
            lbl.className = 'conn-label';
            lbl.innerText = c.port.toUpperCase();
            lbl.style.color = color;
            // Position label
            if(c.port === 'yes') { lbl.style.left = (p1.x + 10) + 'px'; lbl.style.top = (p1.y + 10) + 'px'; }
            else { lbl.style.left = (p1.x + 10) + 'px'; lbl.style.top = (p1.y - 20) + 'px'; }
            nodesLayer.appendChild(lbl);
        }
    });
}

function renderGraph() {
    nodesLayer.innerHTML = '';
    nodes.forEach(renderNode);
    renderConnections();
}

function getPortPos(node, type) {
    const el = document.getElementById(node.id);
    const rect = el.getBoundingClientRect();
    const cRect = canvas.getBoundingClientRect();
    // Simple offsets based on known CSS classes
    let dx = rect.width/2, dy = rect.height; // default bottom
    
    if(node.type === 'decision') {
        if(type==='in') { dx=0; dy=0; }
        else if(type==='yes') { dx=rect.width; dy=rect.height; }
        else if(type==='no') { dx=rect.width; dy=0; }
    } else if (type === 'in') {
        dy = 0;
    }
    
    return { x: (rect.left - cRect.left) + dx, y: (rect.top - cRect.top) + dy };
}

function getPath(x1, y1, x2, y2, type) {
    let d = `M ${x1} ${y1}`;
    const midY = (y1 + y2) / 2;
    
    // Orthogonal routing logic
    if (type === 'no') {
        d += ` L ${x1+30} ${y1} L ${x1+30} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;
    } else {
        // Standard stepped line
        if (Math.abs(x1 - x2) < 20) {
            d += ` L ${x2} ${y2}`;
        } else {
            d += ` L ${x1} ${midY} L ${x2} ${midY} L ${x2} ${y2}`;
        }
    }
    return d;
}

let selectedNodeId = null;
function selectNode(id) {
    selectedNodeId = id;
    document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
    if(id) document.getElementById(id).classList.add('selected');
}

function clearCanvas() {
    if(confirm("Clear all nodes?")) {
        nodes = []; connections = []; nextId=1;
        nodesLayer.innerHTML = ''; svgLayer.innerHTML = '';
        generateCode();
    }
}

function escapeHtml(text) {
    if(!text) return "";
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

/**
 * ----------------------------------------------------------------------
 * CORE COMPILER: GRAPH TO PYTHON
 * ----------------------------------------------------------------------
 * Solves Issues:
 * - Detects arbitrary loops (nested, multiple headers)
 * - Handles 'If/Else' merge points correctly
 * - Prevents infinite recursion
 * - Generates valid Python for strict inputs
 */

let compiledPython = "";

function generateCode() {
    const startNode = nodes.find(n => n.type === 'start');
    if(!startNode) {
        codeDisplay.innerHTML = '<span class="cmt"># Error: No Start Node found.</span>';
        return;
    }

    // 1. Build Adjacency Map
    const adj = {};
    nodes.forEach(n => adj[n.id] = []);
    connections.forEach(c => {
        if(!adj[c.from]) adj[c.from] = [];
        adj[c.from].push({ to: c.to, port: c.port });
    });

    // 2. Traversal State
    let lines = ["import time", "import sys", ""];
    let htmlLines = [];
    const visited = new Set();
    
    // Helper to add code
    function emit(indent, code, htmlCode) {
        const sp = "    ".repeat(indent);
        lines.push(sp + code);
        htmlLines.push(`<div class="code-line">${sp}${htmlCode || escapeHtml(code)}</div>`);
    }

    // 3. Recursive Graph Walker
    // 'stopNodeId' is the node where the current block (If/Loop) MUST stop to return control to parent
    function writeBlock(nodeId, indent, stopNodeId = null) {
        // Stop if we hit the limit, end of chain, or already visited (loop safeguard for linear flows)
        if (!nodeId || nodeId === stopNodeId) return;
        
        // Loop Detection: If we see a node that is currently in the recursion stack, we found a loop.
        // However, we handle structured loops by detecting "Back Edges" before entering.
        
        const node = nodes.find(n => n.id === nodeId);
        
        // Highlight logic (Runtime hook)
        emit(indent, `__highlight__('${nodeId}')`, ``);

        // --- HANDLER: DECISION (The complex part) ---
        if (node.type === 'decision') {
            const yesEdge = adj[nodeId].find(e => e.port === 'yes');
            const noEdge = adj[nodeId].find(e => e.port === 'no');
            
            // 3a. DETECT LOOPS (Cycle Check)
            // Does the YES or NO path lead back to THIS node?
            const isLoop = (edge) => {
                if(!edge) return false;
                return canReach(edge.to, nodeId, adj, new Set());
            };

            const yesLoops = isLoop(yesEdge);
            const noLoops = isLoop(noEdge);

            let condition = node.text.replace(/=/g, '==');

            if (yesLoops || noLoops) {
                // IT IS A LOOP
                emit(indent, `while True:`, `<span class="kw">while</span> True:`);
                
                // If the loop condition logic is "While Condition is True", 
                // we break if condition is False.
                
                // Logic: We are mimicking "Do-While" or "While" by using "While True" + "Break"
                // This ensures body executes correctly even if logic is complex.
                
                emit(indent+1, `if not (${condition}):`, `<span class="kw">if not</span> (${escapeHtml(condition)}):`);
                emit(indent+2, `break`, `<span class="kw">break</span>`);

                // Generate Loop Body
                // If Yes loops, Yes is the body. If No loops, No is the body.
                // We stop generating the body if we hit the Header again (continue)
                
                if (yesLoops) {
                     writeBlock(yesEdge.to, indent + 1, nodeId); 
                } else if (noLoops) {
                     // Invert logic if user wired "No" as the loop back
                     // (This is rare but possible, standardizing on Yes-Loop is safer but we support both)
                     writeBlock(noEdge.to, indent + 1, nodeId);
                }
                
                // After loop block ends, where do we go?
                // The "Exit" edge is the one that didn't loop.
                const exitEdge = yesLoops ? noEdge : yesEdge;
                if (exitEdge) writeBlock(exitEdge.to, indent, stopNodeId);

            } else {
                // IT IS A STANDARD IF/ELSE
                const mergeNode = findMergeNode(yesEdge?.to, noEdge?.to, adj);
                
                emit(indent, `if ${condition}:`, `<span class="kw">if</span> ${escapeHtml(condition)}:`);
                if (yesEdge) writeBlock(yesEdge.to, indent + 1, mergeNode);
                else emit(indent + 1, "pass", "<span class=\"kw\">pass</span>");

                if (noEdge) {
                    emit(indent, `else:`, `<span class="kw">else</span>:`);
                    writeBlock(noEdge.to, indent + 1, mergeNode);
                }

                // Continue main flow after merge
                if (mergeNode) writeBlock(mergeNode, indent, stopNodeId);
            }
            return;
        }

        // --- HANDLER: LINEAR NODES ---
        
        switch (node.type) {
            case 'start':
                emit(indent, `# Start`, `<span class="cmt"># Start</span>`);
                break;
            case 'end':
                emit(indent, `sys.exit()`, `<span class="kw">exit</span>()`);
                return; // Stop generation here
            case 'process':
                emit(indent, node.text, escapeHtml(node.text));
                break;
            case 'var':
                // Enforce type safety
                let val = node.data.val;
                if(node.data.type === 'str' && !val.startsWith('"') && !val.startsWith("'")) val = `"${val}"`;
                emit(indent, `${node.data.name} = ${val}`, `${node.data.name} = ${val}`);
                break;
            case 'input':
                const prompt = node.data.prompt ? `"${node.data.prompt}"` : '""';
                // Safe Input Parsing
                emit(indent, `_raw = input(${prompt})`, `_raw = <span class="fn">input</span>(${prompt})`);
                if(node.data.type === 'int') {
                    emit(indent, `${node.data.var} = int(_raw)`, `${node.data.var} = <span class="fn">int</span>(_raw)`);
                } else if (node.data.type === 'float') {
                    emit(indent, `${node.data.var} = float(_raw)`, `${node.data.var} = <span class="fn">float</span>(_raw)`);
                } else {
                    emit(indent, `${node.data.var} = _raw`, `${node.data.var} = _raw`);
                }
                break;
            case 'output':
                emit(indent, `print(${node.data.val})`, `<span class="fn">print</span>(${node.data.val})`);
                break;
        }

        // Continue to next node
        const next = adj[nodeId][0];
        if (next) writeBlock(next.to, indent, stopNodeId);
    }

    // Start Generation
    writeBlock(startNode.id, 0);

    compiledPython = lines.join("\n");
    codeDisplay.innerHTML = htmlLines.join("\n");
}

// Helper: Check if 'target' is reachable from 'start' (DFS)
function canReach(start, target, adj, visited) {
    if (start === target) return true;
    if (visited.has(start) || !start) return false;
    visited.add(start);
    
    const edges = adj[start] || [];
    for (let e of edges) {
        if (canReach(e.to, target, adj, visited)) return true;
    }
    return false;
}

// Helper: Find the first common descendant node (Post-Dominator)
// Solves Issue #7 (Infinite Loop) by using visited sets
function findMergeNode(nodeA, nodeB, adj) {
    if(!nodeA || !nodeB) return null;
    if(nodeA === nodeB) return nodeA;

    // Get all descendants of A
    const descendantsA = new Set();
    const queueA = [nodeA];
    while(queueA.length) {
        const n = queueA.shift();
        if(!descendantsA.has(n)) {
            descendantsA.add(n);
            (adj[n]||[]).forEach(e => queueA.push(e.to));
        }
    }

    // BFS from B, return first node that is also in A's descendants
    const queueB = [nodeB];
    const visitedB = new Set();
    while(queueB.length) {
        const n = queueB.shift();
        if(descendantsA.has(n)) return n;
        
        if(!visitedB.has(n)) {
            visitedB.add(n);
            (adj[n]||[]).forEach(e => queueB.push(e.to));
        }
    }
    return null; // No merge point (e.g. one branch ends or infinite loop)
}

/**
 * ----------------------------------------------------------------------
 * EXECUTION ENGINE (Skulpt)
 * ----------------------------------------------------------------------
 */
function log(msg, type='info') {
    const div = document.createElement('div');
    div.style.color = type === 'err' ? '#ff6b6b' : (type==='inp'?'#339af0':'#69db7c');
    div.textContent = typeof msg === 'object' ? JSON.stringify(msg) : msg;
    consoleDiv.appendChild(div);
    consoleDiv.scrollTop = consoleDiv.scrollHeight;
}

function stopExecution() {
    executionStopFlag = true;
    isRunning = false;
    document.getElementById('btn-run').style.display = 'inline-block';
    document.getElementById('btn-stop').style.display = 'none';
    document.querySelectorAll('.node').forEach(n => n.classList.remove('running'));
    // Close modal if open
    const modalEl = document.getElementById('runtimeInputModal');
    const bsModal = bootstrap.Modal.getInstance(modalEl);
    if(bsModal) bsModal.hide();
}

async function compileAndRun() {
    if(isRunning) return;
    
    // Validate
    if(!nodes.find(n=>n.type==='start')) { alert("Add a Start node"); return; }
    
    isRunning = true;
    executionStopFlag = false;
    consoleDiv.innerHTML = '';
    document.getElementById('btn-run').style.display = 'none';
    document.getElementById('btn-stop').style.display = 'inline-block';

    generateCode(); // Ensure latest code

    // Skulpt Config
    Sk.configure({
        output: (text) => { if(text !== "\n") log(text); },
        read: (x) => {
            if (Sk.builtinFiles === undefined || Sk.builtinFiles["files"][x] === undefined)
                throw "File not found: '" + x + "'";
            return Sk.builtinFiles["files"][x];
        },
        inputfun: (prompt) => {
            return new Promise((resolve, reject) => {
                if(executionStopFlag) return reject("Stopped");
                
                const modalEl = document.getElementById('runtimeInputModal');
                const bsModal = new bootstrap.Modal(modalEl);
                const inputEl = document.getElementById('runtime-val');
                const btn = document.getElementById('runtime-submit');
                
                document.getElementById('runtime-prompt').innerText = prompt || "Value:";
                inputEl.value = "";
                
                function submit() {
                    const val = inputEl.value;
                    bsModal.hide();
                    log(`${prompt} ${val}`, 'inp');
                    cleanup();
                    resolve(val);
                }
                
                function handleKey(e) { if(e.key === 'Enter') submit(); }
                
                function cleanup() {
                    btn.removeEventListener('click', submit);
                    inputEl.removeEventListener('keydown', handleKey);
                }
                
                btn.addEventListener('click', submit);
                inputEl.addEventListener('keydown', handleKey);
                
                bsModal.show();
                setTimeout(()=>inputEl.focus(), 500);
            });
        },
        inputfunTakesPrompt: true
    });

    // Custom Highlight Hook
    Sk.builtins.__highlight__ = function(id) {
        if (executionStopFlag) throw "ExecutionStopped";
        const nodeId = id.v;
        
        // Visual Update
        document.querySelectorAll('.node').forEach(n => n.classList.remove('running'));
        const el = document.getElementById(nodeId);
        if(el) {
            el.classList.add('running');
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Delay logic
        const delay = parseInt(document.getElementById('speed-slider').value) || 500;
        return new Sk.misceval.promiseToSuspension(
            new Promise(resolve => setTimeout(resolve, delay))
        );
    };

    try {
        await Sk.misceval.asyncToPromise(() => {
            return Sk.importMainWithBody("<stdin>", false, compiledPython, true);
        });
        log("--- Program Finished ---", "sys");
    } catch (e) {
        if(e.toString() !== "ExecutionStopped") log(e.toString(), "err");
    } finally {
        stopExecution();
    }
}

// Initial Call
init();

</script>
</body>
</html>
