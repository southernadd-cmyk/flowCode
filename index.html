<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowCode v3.62</title>
 <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="favicon.svg" />
<link rel="shortcut icon" href="favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />
<link rel="manifest" href="site.webmanifest" />
    <!-- LIBS -->

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anonymous+Pro:ital,wght@0,400;0,700;1,400;1,700&family=Major+Mono+Display&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="skulpt.min.js"></script>
    <script src="skulpt-stdlib.js"></script>
    <style>
        :root {
            /* Backgrounds */
            --bg-canvas: #f8fafc;
            --bg-sidebar: #ffffff;
            --bg-panel: #f1f5f9;
            
            /* Professional Flowchart Colors (Softer, modern) */
            --color-start-end: #10b981;    /* Emerald 500 */
            --color-process: #6366f1;      /* Indigo 500 */
            --color-decision: #f59e0b;     /* Amber 500 */
            --color-input-output: #0ea5e9; /* Sky 500 */
            --color-variable: #8b5cf6;     /* Violet 500 */
            --color-list: #ec4899;         /* Pink 500 */
            
            /* UI Accents */
            --accent: #2563eb;
            --border-subtle: #e2e8f0;
            --text-main: #1e293b;
            --node-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --node-selected: 0 0 0 3px rgba(37, 99, 235, 0.4);
        }
        #palette::-webkit-scrollbar-track {
            background: #92eda1; /* Matches the sidebar bg */
        }    
        
        .dropdown-menu[data-bs-popper] {
            left:-100px!important;
        }
        body { 
            font-family: 'Anonymous Pro', 'Courier New', monospace; 
            height: 100vh; 
            overflow: hidden; 
            background-color: #ffffff; 
            margin: 0;
            color: #1e293b;
        }
        .headerfont,.modal-title{
            font-family: 'Major Mono Display', monospace;
        }
        
        .wrapper { 
            height: calc(100vh - 56px); 
            display: flex; 
            flex-direction: column; 
        }
        
        .main-area { 
            flex: 1; 
            display: flex; 
            overflow: hidden; 
        }
        .node .inner-text {
            display: block;
        
            /* ellipsis behaviour */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        
            /* keeps text inside padding limits */
            max-width: 95%;
            line-height: 1.2;
        }
        
        /* ========== PALETTE ========== */
        #palette {
            width: 260px;
            background: var(--bg-sidebar);
            padding: 24px 16px;
            border-right: 1px solid var(--border-subtle);
            overflow-y:auto;
        }
        
        .palette-header {
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #94a3b8;
            margin: 20px 0 12px 4px;
        }
        
        .palette-item {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-main);
            transition: all 0.15s ease-in-out;
        }
        
        .palette-item:hover {
            background: #ffffff;
            border-color: var(--accent);
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            transform: translateY(-1px);
        }
        .palette-item:active {
            transform: translateY(0);
        }
        
        /* ========== CANVAS ========== */
        #canvas { 
            flex: 1; 
            background-color: var(--bg-canvas); 
            position: relative; 
            overflow: hidden; 
            background-image: 
                radial-gradient(circle, #cbd5e1 1px, transparent 1px);
            background-size: 48px 48px;
        }
        
        svg#connections-layer { 
            position: absolute; 
            inset: 0; 
            pointer-events: none; 
            overflow:hidden;
            z-index: 1; 
            width: 100%; 
            height: 100%; 
        }
        
        /* ========== FLOWCHART NODES ========== */
        .node { 
            position: absolute; 
            background: white;
            border: 3px solid #334155; 
            text-align: center; 
            font-size: 11.5px; 
            font-weight: 700; 
            user-select: none; 
            cursor: move; 
            z-index: 2; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            padding: 6px; 
            box-shadow: 0 4px 12px var(--node-shadow);
            transition: transform 0.2s ease, background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
            transform-origin: center center;
        }
        
        .node:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }
        
        .node.selected { 
            border-color: var(--accent); 
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.25),
                        0 6px 16px rgba(59, 130, 246, 0.3);
            z-index: 100;
        }
        
        /* NEW: simple grow + green, no pulse */
        .node.running { 
            /*transform: scale(1.02);*/
            filter: grayscale(1) sepia(1) hue-rotate(35deg) saturate(25) !important;
            
            color: #ffffff !important;
            z-index: 101;
        }
        
        /* ========== START/END (Green Oval) ========== */
        .shape-start, .shape-end { 
            width: 95px; 
            height: 40px; 
            border-radius: 25px;
            background: linear-gradient(135deg, var(--color-start-end) 0%, #16a34a 100%);
            border-color: var(--border-start-end);
            color: white;
            font-weight: 800;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        
        /* when running, just follow the global green, no extra glow */
        .shape-start.running, .shape-end.running {
filter: grayscale(1) sepia(1) hue-rotate(35deg) saturate(25) !important;
background-color:#eed202 ;
            background-image: none !important;
            box-shadow: none;
        }
        
        /* ========== PROCESS (Blue Rectangle) ========== */
        .shape-process { 
            width: 120px; 
            height: 50px; 
            border-radius: 6px;
            background: linear-gradient(135deg, var(--color-process) 0%, #2563eb 100%);
            border-color: var(--border-process);
            color: white;
            font-weight: 700;
        }
        
        .shape-process.running {
            filter: grayscale(1) sepia(1) hue-rotate(35deg) saturate(25) !important;
            background-color:#eed202 ;
            background-image: none !important;
            box-shadow: none;
        }
        
        /* ========== VARIABLE (Purple Rectangle) ========== */
        .shape-var { 
            width: 120px; 
            height: 50px; 
            border-radius: 6px;
            background: linear-gradient(135deg, var(--color-variable) 0%, #7c3aed 100%);
            border-color: var(--border-variable);
            color: white;
            font-weight: 700;
        }
        
        .shape-var.running {
            filter: grayscale(1) sepia(1) hue-rotate(35deg) saturate(25) !important;
            background-color:#eed202 ;
            background-image: none !important;
            box-shadow: none;
        }
        
        /* ========== INPUT/OUTPUT (Blue Parallelogram) ========== */
        .shape-output, .shape-input {
            width: 140px;
            height: 50px;
            background: var(--color-input-output) !important;
            border: none !important;
            transform: skewX(-15deg);
            color: white;
        }
        
        /* Remove the skew from the inner text since we used clip-path */
        .shape-output .inner-text, .shape-input .inner-text {
            transform: skewX(15deg);
            padding: 0 10px;
        }
        
        .shape-output.running, .shape-input.running {
            filter: grayscale(1) sepia(1) hue-rotate(35deg) saturate(25);
            background-color:#eed202 ;
            background-image: none !important;
            box-shadow: none;
        }
        
        /* ========== DECISION (Yellow Diamond) ========== */
        .shape-decision { 
            width: 130px; 
            height: 110px; 
            background: transparent !important; 
            border: none !important; 
            box-shadow: none !important; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .decision-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            fill: var(--color-decision);
            stroke: var(--border-decision);
            stroke-width: 3px;
            z-index: -1;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.12));
            transition: all 0.2s ease;
        }
        

        .node.running .decision-svg {

            filter: grayscale(1) sepia(1) hue-rotate(35deg) saturate(25);
           /* fill: #d2f10c !important;
            stroke: #14532d !important;*/
           
        }
        
        .node.selected .decision-svg {
            stroke: var(--accent);
            stroke-width: 2px;
        }
        
        .shape-decision .inner-text { 
            transform: none; 
            width: 70%;
            font-size: 11px;
            font-weight: 800;
            z-index: 2;
            color: white;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.5);
        }
        
        /* ========== LIST (Cyan Rectangle with Accent) ========== */
        .shape-list {
            width: 140px;
            height: 50px;
            border-radius: 6px;
            background: linear-gradient(135deg, var(--color-list) 0%, #0891b2 100%);
            border-color: var(--border-list);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 6px;
            color: white;
            font-weight: 700;
        }
        
        .shape-list::before {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 5px;
            background: rgba(255, 255, 255, 0.4);
            border-top-left-radius: 4px;
            border-bottom-left-radius: 4px;
        }
        
        .shape-list.running {
            filter: grayscale(1) sepia(1) hue-rotate(35deg) saturate(25) !important;
            background-color:#eed202 ;
            background-image: none !important;
            box-shadow: none;
        }
        
        .shape-list .inner-text {
            width: 100%;
            transform: none;
            font-weight: 700;
            font-size: 11px;
        }
        
        /* ========== CONNECTION DOTS ========== */
        .dot { 
            width: 12px; 
            height: 12px; 
            background: #ffffff; 
            border: 3px solid #475569; 
            border-radius: 50%; 
            position: absolute; 
            z-index: 5; 
            cursor: crosshair;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }
        
        .dot:hover {
            transform: scale(1.3);
            border-color: var(--accent);
            background: var(--accent);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.2);
        }
        
        .dot.in { 
            top: -6px; 
            left: 50%; 
            transform: translateX(-50%); 
        }
        
        .dot.out { 
            bottom: -6px; 
            left: 50%; 
            transform: translateX(-50%); 
        }
        
        /* Decision-specific dots */
        .shape-decision .dot.in { 
            top: -6px; 
            left: 50%; 
            transform: translateX(-50%); 
        } 
        
        .shape-decision .dot.out-yes { 
            bottom: -6px; 
            left: 50%; 
            transform: translateX(-50%);
            background: #22c55e;
            border-color: #16a34a;
        }
        
        .shape-decision .dot.out-yes:hover {
            background: #16a34a;
            transform: translateX(-50%) scale(1.3);
        }
        
        .shape-decision .dot.out-no { 
            top: 50%; 
            right: -6px; 
            transform: translateY(-50%);
            background: #ef4444;
            border-color: #dc2626;
        }
        
        .shape-decision .dot.out-no:hover {
            background: #dc2626;
            transform: translateY(-50%) scale(1.3);
        }
        
        /* ========== CONNECTION LABELS ========== */
        .conn-label { 
            position: absolute; 
            font-size: 10px; 
            font-weight: 800; 
            background: white; 
            padding: 3px 8px; 
            border: 2px solid #e2e8f0; 
            border-radius: 6px; 
            z-index: 3; 
            pointer-events: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            letter-spacing: 0.5px;
        }
        
        #nodes-layer, #connections-layer {
            transform-origin: 0 0;
        }
        
        /* ========== UTILITY CLASSES ========== */
        .text-muted {
            color: #9ca3af !important;
            font-weight: 400;
        }
        
        #console .text-muted {
            color: var(--fc-console-muted) !important;
        }
        
        /* ========== SCROLLBAR STYLING ========== */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        #console::-webkit-scrollbar-track {
            background: #0f1419;
        }
        
        #console::-webkit-scrollbar-thumb {
            background: #334155;
        }
        
        /* ========== DRAGGABLE CHALLENGE BANNER ========== */
        #active-challenge-banner {
            pointer-events: auto;
            cursor: move;
        }
        #active-challenge-banner button {
            pointer-events: auto;
            cursor: pointer;
        }
        #active-challenge-banner {
            z-index: 9999;
            position: absolute;
        }
        
        /* ========== OUTPUT PANEL, CODE, CONSOLE, VARWATCH ========== */
        
        /* 1. MAIN OUTPUT CONTAINER */
        #output-panel { 
            width: 480px; 
            display: flex; 
            flex-direction: column; 
            background: #0f172a; /* Deep Slate 900 */
            border-left: 1px solid #1e293b;
            box-shadow: -10px 0 20px rgba(0,0,0,0.2);
        }
        
        /* 2. PYTHON CODE AREA (Top Section) */
        .code-display { 
            flex: 1; 
            padding: 40px 24px 24px 24px; /* Extra top padding for the pseudo-label */
            font-family: 'JetBrains Mono', 'Fira Code', monospace; 
            font-size: 13px; 
            color: #cbd5e1; 
            background: #0f172a; 
            white-space: pre; 
            overflow-y: auto; 
            line-height: 1.6;
            border-bottom: 2px solid #1e293b;
            position: relative;
        }
        
        /* CSS-ONLY Label for Code Area */
        .code-display::before {
            content: "\f3e2  PYTHON PREVIEW";
            position: absolute;
            top: 12px;
            left: 24px;
            font-size: 9px;
            font-weight: 800;
            letter-spacing: 1.5px;
            color: #a8ecba;
            font-family: "Font Awesome 6 Brands";
            font-weight: 400;
        }
        
        /* 3. TERMINAL CONSOLE (Middle Section) */
        #console { 
            height: 250px; 
            background: #020617; /* Rich Black */
            color: #e2e8f0; 
            padding: 45px 16px 16px 16px; /* Top padding makes room for the pseudo-header */
            font-family: 'JetBrains Mono', monospace; 
            font-size: 13px; 
            overflow-y: auto; 
            border-top: 1px solid #334155;
            line-height: 1.5;
            position: relative;
            border-bottom: 2px solid #1e293b;
        }
        
        /* CSS-ONLY Terminal Header Bar */
        #console::before {
            content: "TERMINAL";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 32px;
            background: #1e293b;
            color: #94a3b8;
            display: flex;
            align-items: center;
            padding-left: 36px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 1px;
        }
        
        /* CSS-ONLY Terminal Icon (FontAwesome-like dot) */
        #console::after {
            content: "";
            position: absolute;
            top: 11px;
            left: 16px;
            width: 10px;
            height: 10px;
            background: #10b981; /* Green dot */
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }
        
        /* 4. VARIABLE WATCH (Bottom Section) */
        #varwatch {
            height: 180px !important; 
            background: #0f172a !important; 
            padding: 40px 16px 16px 16px !important;
            position: relative;
            border-top: 1px solid #1e293b !important;
        }
        
        /* CSS-ONLY Header for VarWatch */
        #varwatch::before {
            content: "DEBUGGER / VARIABLES";
            position: absolute;
            top: 15px;
            left: 16px;
            font-size: 9px;
            font-weight: 800;
            color: #38bdf8; /* Sky Blue */
            letter-spacing: 1px;
        }
        
        /* Target the table created by JS inside VarWatch */
        #varwatch-table table {
            width: 100%;
            border-spacing: 0;
            margin-top: 5px;
        }
        
        #varwatch-table tr {
            border-bottom: 1px solid #1e293b !important;
        }
        
        #varwatch-table td {
            padding: 6px 0 !important;
            font-size: 12px;
        }
        
        /* Left column (Var name) */
        #varwatch-table td:first-child {
            color: #94a3b8 !important;
            font-weight: 600;
        }
        
        /* Right column (Value) */
        #varwatch-table td:last-child {
            color: #22d3ee !important; /* Cyan */
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* 5. SCROLLBARS (Universal Dark Polish for these) */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: #0f172a;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #475569;
        }
        
        /* Text Selection Color */
        ::selection {
            background: rgba(56, 189, 248, 0.2);
            color: #38bdf8;
        }
        

        </style>
        

</head>
<body>

<nav class="navbar navbar-dark bg-dark">
    <div class="container-fluid">
        <span class="headerfont navbar-brand fw-bold"><i class="fa-solid fa-code-branch me-2"></i>FlowCode<small class="text-muted">v3.62</small></span>
        <div class="d-flex gap-2">

            <button id="btn-challenges" class="btn btn-outline-secondary">
                Challenges
              </button>
              
            <!-- RUN button (shown when idle) -->
<button id="run-btn"
class="btn btn-success btn-sm px-4 fw-bold"
onclick="App.runSim()">
<i class="fa-solid fa-play me-1"></i> RUN
</button>

<!-- STOP button (hidden until running) -->
<button id="stop-btn"
class="btn btn-danger btn-sm px-4 fw-bold"
style="display:none"
onclick="App.stopSim()">
<i class="fa-solid fa-stop me-1"></i> STOP
</button>

<button class="btn btn-primary btn-sm px-3 fw-bold" onclick="App.openSaveOptions()">
    <i class="fa-solid fa-download me-1"></i> Save</button>
            <button class="btn btn-info btn-sm px-3 fw-bold" onclick="App.loadDiagram()"><i class="fa-solid fa-upload me-1"></i> Load</button>
            <div class="btn-group">
                <button class="btn btn-secondary btn-sm dropdown-toggle fw-bold" data-bs-toggle="dropdown">
                Examples
                </button>
            
                <ul class="dropdown-menu">
                <li><a class="dropdown-item" onclick="App.loadExampleFromFile('basicIF.json')">If / Else</a></li>
                <li><a class="dropdown-item" onclick="App.loadExampleFromFile('maxOfThree.json')">Maximum Number of 3 Inputs</a></li>
                <li><a class="dropdown-item" onclick="App.loadExampleFromFile('sumOfN.json')">Sum of first N Numbers</a></li>
                <li><a class="dropdown-item" onclick="App.loadExampleFromFile('forloop.json')">For Loop</a></li>
                <li><a class="dropdown-item" onclick="App.loadExampleFromFile('countdown.json')">Descending For Loop</a></li>
                <li><a class="dropdown-item" onclick="App.loadExampleFromFile('2loops.json')">Nested For Loops</a></li>
                <li><a class="dropdown-item" onclick="App.loadExampleFromFile('whileloop.json')">While Loop</a></li>
                <li><a class="dropdown-item" onclick="App.loadExampleFromFile('WhileTrue.json')">While True Loop</a></li>
                <li><a class="dropdown-item" onclick="App.loadExampleFromFile('anti.json')">Anti-Gravity</a></li>
                <li><a class="dropdown-item" onclick="App.loadExampleFromFile('random.json')">Random Number</a></li>
                </ul>
            </div>
            
            <button class="btn btn-outline-light btn-sm" onclick="App.clearCanvas()">Clear All</button>
        </div>
    </div>
</nav>

<div class="wrapper">
    <div class="main-area">
        <div id="palette">
            <div class="palette-header">Flow</div>
            <div class="palette-item" draggable="true" data-type="start">Start</div>
            <div class="palette-item" draggable="true" data-type="end">End</div>

            <div class="palette-item" draggable="true" data-type="decision">Decision</div>
            
            <div class="palette-header">Logic</div>
            <div class="palette-item" draggable="true" data-type="var">Variable</div>
            <div class="palette-item" draggable="true" data-type="list">List</div>
            <div class="palette-item" draggable="true" data-type="process">Process</div>
            
            <div class="palette-header">I/O</div>
            <div class="palette-item" draggable="true" data-type="input">Input</div>
            <div class="palette-item" draggable="true" data-type="output">Print</div>

            <div class="palette-header">Speed</div>
            <input type="range" class="form-range" id="speed-slider" min="100" max="2000" value="1600">
        </div>

        <div id="canvas">
            <div style="position:absolute; top:12px; right:12px; z-index:10;">
                <button class="btn btn-sm btn-light" onclick="App.zoomIn()">
                  +
                </button>
                <button class="btn btn-sm btn-light" onclick="App.zoomOut()">
                  âˆ’
                </button>
                <button class="btn btn-sm btn-light" onclick="App.resetView()">
                  reset
                </button>
              </div>
              
            <svg id="connections-layer">
                <defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#555" /></marker></defs>
                <path id="drag-line" stroke="#0d6efd" stroke-width="2" stroke-dasharray="4,4" fill="none" style="display:none;"></path>
            </svg>
            <div id="nodes-layer"></div>

        </div>
        
        <div id="output-panel">
            <div class="code-display" id="code-python"></div>
            <div id="console"></div>
            <div id="varwatch" style="height:160px; overflow-y:auto; font-family:'JetBrains Mono', monospace; font-size:13px; padding:10px; border-top:1px solid #333; background:#111; color:#0f0">
                <div id="varwatch-table"></div>
            </div>
              
        </div>
    </div>
</div>

<!-- INPUT MODAL -->
<div class="modal fade" id="inputModal" tabindex="-1" data-bs-backdrop="static"><div class="modal-dialog modal-dialog-centered"><div class="modal-content"><div class="modal-body p-4"><h6 id="modal-prompt" class="fw-bold mb-3">Input:</h6><input type="text" id="modal-field" class="form-control mb-3"><button class="btn btn-primary w-100 fw-bold" id="modal-submit">Continue</button></div></div></div></div>
<div class="modal fade" id="editModal" tabindex="-1"><div class="modal-dialog modal-dialog-centered"><div class="modal-content"><div class="modal-header py-2 bg-light"><h6 class="modal-title fw-bold">Edit Node</h6></div><div class="modal-body" id="edit-modal-body"></div><div class="modal-footer py-2 bg-light"><button class="btn btn-primary btn-sm px-4 fw-bold" id="save-node-btn">Save Changes</button></div></div></div></div>
<!-- WELCOME / INSTRUCTIONS MODAL -->
<div class="modal fade" id="welcomeModal" tabindex="-1" data-bs-backdrop="static">
    <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content">

        <div class="modal-header bg-dark text-white py-2">
        <h5 class="modal-title fw-bold">Welcome to FlowCode!</h5>
        </div>

        <div class="modal-body">
            <p><strong>FlowCode</strong> lets you make flowcharts that actually run and turn into Python code.</p>
        
            <h6 class="fw-bold mt-3">Quick start</h6>
            <ol>
                <li>Drag blocks onto the canvas</li>
                <li>Join them using the small circles</li>
                <li>Double-click a block to edit it</li>
                <li>Press <strong>RUN</strong> to watch it execute</li>
            </ol>
        
            <h6 class="fw-bold mt-3">What it can do</h6>
            <ul>
                <li>Input and print</li>
                <li>Variables</li>
                <li>If / Else</li>
                <li>Loops (while and for)</li>
                <li>Lists</li>
            </ul>
        
            <h6 class="fw-bold mt-3">Good to know</h6>
            <ul>
                <li>Green = YES path</li>
                <li>Red = NO path</li>
                <li>You must have a <strong>Start</strong> block</li>
                <li>You can save and load your work</li>
            </ul>
        <hr class="mt-3 mb-2">

<div class="small text-muted">
  <p class="mb-1"><a target="_blank" href="flowcode_TG.pdf">Teacher's Guide ðŸŽ“</a></p>
  <p class="mb-1"><strong>Privacy notice</strong></p>
  <p class="mb-1">FlowCode runs entirely in your web browser.</p>
  <p class="mb-1">No data is uploaded to any server.</p>
  <p class="mb-1">Your diagrams and code exist only on your device.</p>
  <p class="mb-0">We do not collect analytics, cookies, personal data, or usage information.</p>
</div>
            <div class="form-check mt-2">
                <input class="form-check-input" type="checkbox" id="dontShowAgainCheck">
                <label class="form-check-label" for="dontShowAgainCheck">
                    Donâ€™t show this again
                </label>
            </div>
        </div>
        
        <div class="modal-footer bg-light py-2">
            <button class="btn btn-primary fw-bold" id="welcomeCloseBtn">Get Started</button>
        </div>
        

    </div>
    </div>
</div>
<div class="modal fade" id="challengesModal" tabindex="-1">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">FlowCode Challenges</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
  
        <div class="modal-body" style="height: 60vh;">
            <div class="row h-100">
          
              <!-- LEFT: scrollable list -->
              <div class="col-4 border-end h-100">
                <ul id="challenge-list"
                    class="list-group"
                    style="max-height: 100%; overflow-y: auto;">
                </ul>
              </div>
          
              <!-- RIGHT: fixed info panel, separate scroll -->
              <div class="col-8 h-100"
                   style="display:flex; flex-direction:column;">
          
                <div style="flex:1; overflow-y:auto;">
                  <h5 id="challenge-title"></h5>
                  <span id="challenge-diff" class="badge bg-primary mb-2"></span>
                  <p id="challenge-task" class="mt-2"></p>
                  <p id="challenge-detail" class="mt-2"></p>
                  <p id="challenge-success" class="mt-2"></p>
                  <pre id="challenge-code" class="mt-2"></pre>
                  <div id="challenge-skills" class="mt-2"></div>
                </div>
          
                <div class="mt-2">
                  <button id="btn-attempt-challenge" class="btn btn-success" disabled>
                    Attempt this challenge
                  </button>
                </div>
          
              </div>
            </div>
          </div>
          
  
      </div>
    </div>
  </div>
  <!-- SAVE OPTIONS MODAL -->
<div class="modal fade" id="saveOptionsModal" tabindex="-1">
    <div class="modal-dialog">
      <div class="modal-content">
  
        <div class="modal-header bg-dark text-white py-2">
          <h6 class="modal-title fw-bold">Export Options</h6>
        </div>
  
        <div class="modal-body">
  
          <strong>What do you want to export?</strong>
  
          <div class="form-check mt-2">
            <input class="form-check-input" type="checkbox" id="chk-export-code">
            <label class="form-check-label">Python code (.py)</label>
          </div>
  
          <div class="form-check mt-2">
            <input class="form-check-input" type="checkbox" id="chk-export-json">
            <label class="form-check-label">Flowchart JSON (.json)</label>
          </div>
  
          <div class="form-check mt-2">
            <input class="form-check-input" type="checkbox" id="chk-export-image">
            <label class="form-check-label">Flowchart image (.png)</label>
          </div>
  
          <div class="small text-muted mt-3">
            Tip: you can select multiple export options.
          </div>
  
        </div>
  
        <div class="modal-footer bg-light py-2">
          <button class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Cancel</button>
          <button class="btn btn-primary btn-sm" id="btn-save-export">Export</button>
        </div>
  
      </div>
    </div>
  </div>
<!-- Move this to the bottom of your file, right above </body> -->
<div id="active-challenge-banner"
     style="
        display:none;
        position:fixed; /* Changed from absolute to fixed */
        top:70px;       /* Puts it just below the navbar */
        left:50%;
        transform:translateX(-50%);
        z-index:10000;  /* High number ensures it's above EVERYTHING */
        padding:6px 12px;
        background:rgba(255, 243, 205, 0.98); /* Less transparent */
        border:2px solid #eed202;
        border-radius:10px;
        font-weight:800;
        box-shadow:0 10px 25px rgba(0,0,0,0.2); /* Stronger shadow */
        min-width: 300px;
     ">
  <div id="banner-handle" style="cursor: move; border-bottom: 1px solid #ddd; margin-bottom: 5px; padding-bottom: 2px;">
     <i class="fa-solid fa-grip-lines me-2"></i> Challenge Active
  </div>
  <span id="active-challenge-text"></span>
  <hr style="margin: 8px 0;"/>
  <p style="margin-bottom: 4px;">Pseudocode:</p>
  <pre id="active-challenge-code" style="max-height: 200px; overflow: auto; background: #fff; padding: 5px;"></pre>
  <button id="dismiss-challenge"
          class="btn btn-sm btn-outline-dark w-100 mt-2">
    Hide Challenge Details
  </button>
</div>


<script>

const FLOWCODE_CHALLENGES = [
  /* ----------------------------- LEVEL 1 â€” SEQUENCE ----------------------------- */
  {
    "id": 1,
    "diff": 1,
    "title": "Print Shop â€“ Poster Quote",
    "skills": ["input","output","sequence"],
    "task": "Calculate total cost for posters at Â£3 each.",
    "pseudocode": "INPUT posters\nSET cost = posters * 3\nOUTPUT cost",
    "success": "Outputs correct total cost"
  },
  {
    "id": 2,
    "diff": 1,
    "title": "Helpdesk Ticket Message",
    "skills": ["input","output","sequence"],
    "task": "Create formatted helpdesk ticket text.",
    "pseudocode": "INPUT name\nINPUT device\nINPUT fault\nOUTPUT \"Ticket created for \" + name + \" with \" + device + \" fault: \" + fault",
    "success": "Outputs sentence correctly"
  },
  {
    "id": 3,
    "diff": 1,
    "title": "Photocopy Billing",
    "skills": ["input","output","sequence"],
    "task": "Calculate total price for B&W and colour copies.",
    "pseudocode": "INPUT bw\nINPUT colour\nSET total = (bw * 0.05) + (colour * 0.12)\nOUTPUT total",
    "success": "Correct calculation"
  },
  {
    "id": 4,
    "diff": 1,
    "title": "Minutes to Seconds",
    "skills": ["input","output","sequence"],
    "task": "Convert minutes entered to seconds.",
    "pseudocode": "INPUT minutes\nSET seconds = minutes * 60\nOUTPUT seconds",
    "success": "Correct conversion"
  },
  {
    "id": 5,
    "diff": 1,
    "title": "Simple Pay Calculator",
    "skills": ["input","output","sequence"],
    "task": "Multiply hours worked by hourly rate.",
    "pseudocode": "INPUT hours\nINPUT rate\nSET pay = hours * rate\nOUTPUT pay",
    "success": "Outputs correct pay"
  },

  /* ----------------------------- LEVEL 2 â€” SELECTION ----------------------------- */
  {
    "id": 6,
    "diff": 2,
    "title": "Apprenticeship Eligibility",
    "skills": ["selection"],
    "task": "Check if student is 16 or over.",
    "pseudocode": "INPUT age\nIF age >= 16 THEN\n OUTPUT \"Eligible\"\nELSE\n OUTPUT \"Not eligible\"\nENDIF",
    "success": "Outputs correct eligibility"
  },
  {
    "id": 7,
    "diff": 2,
    "title": "Password Length Check",
    "skills": ["selection"],
    "task": "Warn if password is too short.",
    "pseudocode": "INPUT length\nIF length < 8 THEN\n OUTPUT \"Too weak\"\nELSE\n OUTPUT \"OK\"\nENDIF",
    "success": "Outputs correct message"
  },
  {
    "id": 8,
    "diff": 2,
    "title": "Mobile Usage Discount",
    "skills": ["selection"],
    "task": "Check if minutes used qualifies for discount.",
    "pseudocode": "INPUT minutes\nIF minutes > 500 THEN\n OUTPUT \"Apply discount\"\nELSE\n OUTPUT \"No discount\"\nENDIF",
    "success": "Correct decision"
  },
  {
    "id": 9,
    "diff": 2,
    "title": "Exam Grade",
    "skills": ["selection"],
    "task": "Output Pass or Fail based on mark 50.",
    "pseudocode": "INPUT mark\nIF mark >= 50 THEN\n OUTPUT \"Pass\"\nELSE\n OUTPUT \"Fail\"\nENDIF",
    "success": "Correct grade"
  },
  {
    "id": 10,
    "diff": 2,
    "title": "IT Shop Delivery Charge",
    "skills": ["selection"],
    "task": "Add delivery if under Â£50 spend.",
    "pseudocode": "INPUT total\nIF total < 50 THEN\n SET total = total + 4.99\nENDIF\nOUTPUT total",
    "success": "Adds delivery when required"
  },

  /* ----------------------------- LEVEL 3 â€” FOR LOOPS ----------------------------- */
  {
    "id": 11,
    "diff": 3,
    "title": "Invoice Number Printing",
    "skills": ["loop"],
    "task": "Print numbers 1 to N.",
    "pseudocode": "INPUT n\nFOR i = 1 TO n\n OUTPUT i\nNEXT i",
    "success": "Correct list output"
  },
  {
    "id": 12,
    "diff": 3,
    "title": "Sticker Printer",
    "skills": ["loop"],
    "task": "Print message N times.",
    "pseudocode": "INPUT n\nFOR i = 1 TO n\n OUTPUT \"Sticker printed\"\nNEXT i",
    "success": "Correct repeat count"
  },
  {
    "id": 13,
    "diff": 3,
    "title": "Times Table Maker",
    "skills": ["loop"],
    "task": "Print 1â€“10 multiplication table.",
    "pseudocode": "INPUT n\nFOR i = 1 TO 10\n OUTPUT n * i\nNEXT i",
    "success": "Correct products"
  },
  {
    "id": 14,
    "diff": 3,
    "title": "Sum of First N",
    "skills": ["loop"],
    "task": "Calculate 1 + 2 + ... + N.",
    "pseudocode": "INPUT n\nSET total = 0\nFOR i = 1 TO n\n SET total = total + i\nNEXT i\nOUTPUT total",
    "success": "Correct total"
  },
  {
    "id": 15,
    "diff": 3,
    "title": "Days Worked Hours Total",
    "skills": ["loop"],
    "task": "Total hours worked across days.",
    "pseudocode": "INPUT days\nSET total = 0\nFOR i = 1 TO days\n INPUT hours\n SET total = total + hours\nNEXT i\nOUTPUT total",
    "success": "Correct accumulation"
  },

  /* ----------------------------- LEVEL 4 â€” LOOPS + SELECTION ----------------------------- */
  {
    "id": 16,
    "diff": 4,
    "title": "Website Uptime Monitor",
    "skills": ["loop","selection"],
    "task": "Count slow ping responses.",
    "pseudocode": "SET slow = 0\nFOR i = 1 TO 10\n INPUT ping\n IF ping > 200 THEN\n  SET slow = slow + 1\n ENDIF\nNEXT i\nOUTPUT slow",
    "success": "Counts correctly"
  },
  {
    "id": 17,
    "diff": 4,
    "title": "Password Retry Until Correct",
    "skills": ["loop","selection"],
    "task": "Keep asking password until correct.",
    "pseudocode": "SET password = \"letmein\"\nINPUT guess\nWHILE guess != password\n INPUT guess\nENDWHILE\nOUTPUT \"Access granted\"",
    "success": "Loops until correct"
  },
  {
    "id": 18,
    "diff": 4,
    "title": "Loyalty Card Stamp Counter",
    "skills": ["loop","selection"],
    "task": "Ask repeatedly to add stamp.",
    "pseudocode": "SET stamps = 0\nINPUT answer\nWHILE answer == \"yes\"\n SET stamps = stamps + 1\n INPUT answer\nENDWHILE\nOUTPUT stamps",
    "success": "Counts stamps correctly"
  },
  {
    "id": 19,
    "diff": 4,
    "title": "Even Number Finder",
    "skills": ["loop","selection"],
    "task": "Print all even numbers up to N.",
    "pseudocode": "INPUT n\nFOR i = 1 TO n\n IF i % 2 == 0 THEN\n  OUTPUT i\n ENDIF\nNEXT i",
    "success": "Even numbers correct"
  },
  {
    "id": 20,
    "diff": 4,
    "title": "Guess the Secret Number",
    "skills": ["loop","selection"],
    "task": "Repeat guessing until secret number matched.",
    "pseudocode": "SET secret = 7\nINPUT guess\nWHILE guess != secret\n INPUT guess\nENDWHILE\nOUTPUT \"Correct\"",
    "success": "Stops only when correct"
  },

  /* ----------------------------- LEVEL 5 â€” LISTS / ARRAYS ----------------------------- */
  {
    "id": 21,
    "diff": 5,
    "title": "Store Student Marks",
    "skills": ["list","loop"],
    "task": "Input five marks and output them.",
    "pseudocode": "CREATE list\nFOR i = 1 TO 5\n INPUT mark\n APPEND mark TO list\nNEXT i\nOUTPUT list",
    "success": "Stores 5 marks"
  },
  {
    "id": 22,
    "diff": 5,
    "title": "Average of Marks",
    "skills": ["list","loop"],
    "task": "Calculate average of 5 marks.",
    "pseudocode": "SET total = 0\nFOR i = 1 TO 5\n INPUT mark\n SET total = total + mark\nNEXT i\nSET average = total / 5\nOUTPUT average",
    "success": "Correct average"
  },
  {
    "id": 23,
    "diff": 5,
    "title": "Highest Priority Job",
    "skills": ["list","loop","selection"],
    "task": "Find highest priority value in list.",
    "pseudocode": "INPUT n\nINPUT first\nSET max = first\nFOR i = 2 TO n\n INPUT value\n IF value > max THEN\n  SET max = value\n ENDIF\nNEXT i\nOUTPUT max",
    "success": "Outputs maximum"
  },
  {
    "id": 24,
    "diff": 5,
    "title": "Network Latency Average",
    "skills": ["list","loop"],
    "task": "Average 5 network latency readings.",
    "pseudocode": "SET total = 0\nFOR i = 1 TO 5\n INPUT ping\n SET total = total + ping\nNEXT i\nOUTPUT total / 5",
    "success": "Correct mean latency"
  },
  {
    "id": 25,
    "diff": 5,
    "title": "Count Failed Login Attempts",
    "skills": ["list","loop","selection"],
    "task": "Count login attempts recorded as FAIL.",
    "pseudocode": "SET fails = 0\nFOR i = 1 TO 5\n INPUT result\n IF result == \"FAIL\" THEN\n  SET fails = fails + 1\n ENDIF\nNEXT i\nOUTPUT fails",
    "success": "Counts fail values"
  },

  /* ----------------------------- LEVEL 6 â€” CAPSTONE ----------------------------- */
  {
    "id": 26,
    "diff": 6,
    "title": "Cyber Login Lockout",
    "skills": ["loop","selection"],
    "task": "Block account after 3 wrong attempts.",
    "pseudocode": "SET attempts = 0\nSET pin = 1234\nWHILE attempts < 3\n INPUT guess\n IF guess == pin THEN\n  OUTPUT \"Success\"\n  STOP\n ENDIF\n SET attempts = attempts + 1\nENDWHILE\nOUTPUT \"Locked\"",
    "success": "Locks after 3 tries"
  },
  {
    "id": 27,
    "diff": 6,
    "title": "USB Order Discount System",
    "skills": ["selection","arithmetic"],
    "task": "Apply discount for bulk orders.",
    "pseudocode": "INPUT qty\nSET price = qty * 6\nIF qty >= 20 THEN\n SET price = price * 0.8\nELSE IF qty >= 10 THEN\n SET price = price * 0.9\nENDIF\nOUTPUT price",
    "success": "Correct discount applied"
  },
  {
    "id": 28,
    "diff": 6,
    "title": "Network Cable Cutter",
    "skills": ["loop","arithmetic"],
    "task": "Cut 3m sections from cable and count leftover.",
    "pseudocode": "INPUT total\nSET count = 0\nWHILE total >= 3\n SET total = total - 3\n SET count = count + 1\nENDWHILE\nOUTPUT count\nOUTPUT total",
    "success": "Correct cut count and remainder"
  },
  {
    "id": 29,
    "diff": 6,
    "title": "Backup Storage Filler",
    "skills": ["loop","selection","arithmetic"],
    "task": "Add files until storage reaches 1000MB.",
    "pseudocode": "SET used = 0\nSET files = 0\nWHILE used < 1000\n INPUT size\n SET used = used + size\n SET files = files + 1\nENDWHILE\nOUTPUT used\nOUTPUT files",
    "success": "Stops near capacity"
  },
  {
    "id": 30,
    "diff": 6,
    "title": "Project Task Burndown",
    "skills": ["loop","arithmetic","selection"],
    "task": "Count days until project tasks reach zero.",
    "pseudocode": "INPUT tasks\nSET days = 0\nWHILE tasks > 0\n INPUT done\n SET tasks = tasks - done\n SET days = days + 1\nENDWHILE\nOUTPUT days",
    "success": "Outputs correct day count"
  }
]
;

// open modal
document.getElementById("btn-challenges").addEventListener("click", () => {
    const modal = new bootstrap.Modal(document.getElementById("challengesModal"));
    modal.show();
    renderChallengeList();
});
function nextFrame() {
    return new Promise(resolve => requestAnimationFrame(() => resolve()));
}
function renderChallengeList() {
    const ul = document.getElementById("challenge-list");
    ul.innerHTML = "";

    FLOWCODE_CHALLENGES.forEach(ch => {
        const li = document.createElement("li");
        li.className = "list-group-item list-group-item-action";
        li.textContent = `#${ch.id} ${ch.title}`;
        li.onclick = () => loadChallenge(ch);
        ul.appendChild(li);
    });
}


let ACTIVE_CHALLENGE = null;
let CHALLENGE_COMPLETED = new Set();

function loadChallenge(ch) {
    document.getElementById("challenge-title").textContent = ch.title;
    document.getElementById("challenge-diff").textContent = "Difficulty " + ch.diff;
    document.getElementById("challenge-task").textContent = ch.task;
    document.getElementById("challenge-detail").textContent = ch.detail;
    document.getElementById("challenge-success").textContent = "Success Criteria: " + ch.success;
    document.getElementById("challenge-code").textContent = ch.pseudocode; // âœ… Fixed
    document.getElementById("challenge-skills").textContent = "Skills: " + ch.skills.join(", ");
    
    // Enable the attempt button and store the challenge
    document.getElementById("btn-attempt-challenge").disabled = false;
    ACTIVE_CHALLENGE = ch;
}
document.getElementById("btn-save-export").addEventListener("click", () => {
    const code = document.getElementById("chk-export-code").checked;
    const json = document.getElementById("chk-export-json").checked;
    const img  = document.getElementById("chk-export-image").checked;

    const modalEl = document.getElementById("saveOptionsModal");
    bootstrap.Modal.getInstance(modalEl).hide();

    if (!code && !json && !img) {
        alert("Please select at least one export option.");
        return;
    }

    if (code) App.exportPython();
    if (json) App.exportJSON();
    if (img)  App.exportImage();
});

document.getElementById("btn-attempt-challenge").addEventListener("click", () => {

if (!ACTIVE_CHALLENGE) return;

// show banner overlay
const banner = document.getElementById("active-challenge-banner");
banner.style.display = "block";
document.getElementById("active-challenge-text").textContent =
    `#${ACTIVE_CHALLENGE.id} â€” ${ACTIVE_CHALLENGE.title}`;
    document.getElementById("active-challenge-code").textContent =
    `${ACTIVE_CHALLENGE.pseudocode}`;
// â˜… CLOSE THE MODAL â˜…
const modalEl = document.getElementById("challengesModal");
const modal = bootstrap.Modal.getInstance(modalEl) 
            || new bootstrap.Modal(modalEl);
modal.hide();
});

document.getElementById("dismiss-challenge").addEventListener("click", () => {
    document.getElementById("active-challenge-banner").style.display = "none";
});


    // Show welcome modal on first visit
document.addEventListener("DOMContentLoaded", function () {

// if user previously disabled it, don't show
if (localStorage.getItem("hideWelcomeModal") === "true") return;

const welcomeModal = new bootstrap.Modal(
    document.getElementById('welcomeModal')
);

welcomeModal.show();

document.getElementById("welcomeCloseBtn").onclick = function () {
    if (document.getElementById("dontShowAgainCheck").checked) {
        localStorage.setItem("hideWelcomeModal", "true");
    }
    welcomeModal.hide();
};
});

/**
 * ENHANCED FLOWCHART COMPILER
 * Handles nested loops, if/else, for/while loops, and complex structures
 */
class FlowchartCompiler {
    constructor(nodes, connections, useHighlighting = false) {
        this.nodes = nodes;
        this.connections = connections;
        this.useHighlighting = useHighlighting;
        this.loweredImplicitLoops = new Set();   // prevents stack overflow on implicit loops
        this.nodesToSkip = new Set();


        // Build adjacency maps for faster lookups
        this.outgoingMap = new Map();
        this.incomingMap = new Map();
        this.loopHeaderCache = new Map(); // Cache for loop header detection
        this.forPatternCache = new Map();
this.forPatternInProgress = new Set();

        this.buildMaps();
    }

// Returns true if this node is the init assignment of a detected for-loop
isInitOfForLoop(nodeId) {

const node = this.nodes.find(n => n.id === nodeId);
if (!node || (node.type !== "var" && node.type !== "process")) return false;

// look at every decision node (possible loop header)
for (const dec of this.nodes.filter(n => n.type === "decision")) {

    const info = this.detectForLoopPattern(dec.id);
    if (!info || !info.initNodeId) continue;

    // must match the detected init node
    if (info.initNodeId !== nodeId) continue;

    // must be unmittel predecessor in straight-line code
    const incoming = this.incomingMap.get(dec.id) || [];
    const directlyBefore = incoming.some(c => c.sourceId === nodeId);

    if (directlyBefore) return true;
}

return false;
}


    findImplicitForeverLoopHeaders() {

const headers = new Set();

const visited = new Set();
const onStack = new Set();

const dfs = (nodeId) => {

    visited.add(nodeId);
    onStack.add(nodeId);

    const outgoing = this.outgoingMap.get(nodeId) || [];

    for (const edge of outgoing) {
        const target = edge.targetId;

        if (!visited.has(target)) {
            dfs(target);
        } else if (onStack.has(target)) {
            // BACK EDGE detected: nodeId -> target
            const fromNode = this.nodes.find(n => n.id === nodeId);
            const toNode   = this.nodes.find(n => n.id === target);

            if (!fromNode || !toNode) continue;

            // ignore ALL decision-controlled loops
            if (fromNode.type === "decision") continue;
            if (toNode.type   === "decision") continue;

            // non-decision â†’ non-decision = implicit forever loop
            headers.add(target);
        }
    }

    onStack.delete(nodeId);
};

const start = this.nodes.find(n => n.type === "start");
if (start) dfs(start.id);

return headers;
}

    buildMaps() {
        // Clear maps and cache
        this.outgoingMap.clear();
        this.incomingMap.clear();
        if (this.loopHeaderCache) {
            this.loopHeaderCache.clear();
        }
        
        // Initialize maps for all nodes
        this.nodes.forEach(node => {
            this.outgoingMap.set(node.id, []);
            this.incomingMap.set(node.id, []);
        });
        
        // Fill maps
        this.connections.forEach(conn => {
            // Outgoing connections
            const outgoing = this.outgoingMap.get(conn.from) || [];
            outgoing.push({...conn, targetId: conn.to});
            this.outgoingMap.set(conn.from, outgoing);
            
            // Incoming connections
            const incoming = this.incomingMap.get(conn.to) || [];
            incoming.push({...conn, sourceId: conn.from});
            this.incomingMap.set(conn.to, incoming);
        });
    }

    getSuccessor(nodeId, port = 'next') {
        const outgoing = this.outgoingMap.get(nodeId) || [];
        const conn = outgoing.find(c => c.port === port);
        return conn ? conn.targetId : null;
    }

    getAllSuccessors(nodeId) {
        const outgoing = this.outgoingMap.get(nodeId) || [];
        return outgoing.map(c => ({port: c.port, nodeId: c.targetId}));
    }

    /**
     * Main compilation entry point
     */
/**
 * Main compilation entry point
 */
 compile() {
    const startNode = this.nodes.find(n => n.type === 'start');
    if (!startNode) return "# Add a Start node.";
    
    this.buildMaps(); // Ensure maps are up to date
    this.implicitLoopHeaders = this.findImplicitForeverLoopHeaders();

    this.nodes
        .filter(n => n.type === "decision")
        .forEach(dec => {
            const info = this.detectForLoopPattern(dec.id);
            if (info && info.initNodeId) {
                
            }
        });

    // Use iterative compilation with manual stack management
    let code = this.compileNode(startNode.id, new Set(), [], 0, false, false);
    
    // Add END node highlight as the very last line if we're in highlighting mode
    if (this.useHighlighting) {
        const endNode = this.nodes.find(n => n.type === 'end');
        if (endNode) {
            code += `highlight('${endNode.id}')\n`;
        }
    }
    
    return code;
}

    /**
     * Compile a node with context tracking
     */
     compileNode(nodeId, visitedInPath, contextStack, indentLevel, inLoopBody = false, inLoopHeader = false) {
    if (!nodeId) return "";
    
    const node = this.nodes.find(n => n.id === nodeId);
    if (!node) return "";
    
    // ========== HANDLE END NODES FIRST ==========
    if (node.type === 'end') {
        const indent = "    ".repeat(indentLevel);
        let code = "";
        
        // Add highlight if in execution mode
        if (this.useHighlighting) {
           // code += `${indent}highlight('${node.id}')\n`;
          //  code += `${indent}# END NODE REACHED\n`;
        }
        
        // End nodes should STOP compilation - don't continue to any successors
        return code;
    }
    
    // prevent infinite recursion by node revisits along same path
    if (visitedInPath.has(nodeId)) {
        return "";
    }
    visitedInPath.add(nodeId);
    
 
// --- suppress for-loop init statements (like `i = x`) ---
// but STILL continue to successors AND HIGHLIGHT
if (this.isInitOfForLoop(nodeId)) {
    const indent = "    ".repeat(indentLevel);
    let highlightCode = "";
    
    // ADD HIGHLIGHT FOR INIT NODES
    if (this.useHighlighting) {
        highlightCode += `${indent}highlight('${nodeId}')\n`;
    }
    
// normal skip â€” not a loop header
const succ = this.getAllSuccessors(nodeId);
let out = highlightCode;
for (const { nodeId: nxt } of succ) {
    // Check if this is a back edge to a loop header that's in our context
    let isBackEdgeToCurrentLoop = false;
    for (const ctx of contextStack) {
        if (ctx.startsWith('loop_')) {
            const loopHeaderId = ctx.replace('loop_', '');
            if (nxt === loopHeaderId) {
                isBackEdgeToCurrentLoop = true;
                break;
            }
        }
    }
    
    if (!isBackEdgeToCurrentLoop) {
        out += this.compileNode(nxt, visitedInPath, [...contextStack], indentLevel,
    inLoopBody,
    inLoopHeader);
    }
}
return out;
}

// 2) any nodes explicitly skipped for this loop body (typically increments)
// make them *control-flow transparent*: don't emit code, but STILL HIGHLIGHT
if (this.nodesToSkip && this.nodesToSkip.has(nodeId)) {
    
    const indent = "    ".repeat(indentLevel);
    let highlightCode = "";
    
    // ADD HIGHLIGHT FOR SKIPPED NODES
    if (this.useHighlighting) {
        highlightCode += `${indent}highlight('${nodeId}')\n`;
    }
    
    // if this is the loop header produced by for-loop lowering
    if (nodeId === this.loopHeaderId) {
        
    // Check if we're in THIS specific loop's context
    const isInThisLoopContext = contextStack.some(ctx => ctx === `loop_${nodeId}`);
    
    // Check if this is a for-loop
    const forInfo = this.detectForLoopPattern(nodeId);
    
    // If this is a for-loop header AND we're reaching it from within its loop
    // (either in context or in loop body), just highlight and stop
    // The Python for-loop handles the iteration control
    if (forInfo && (isInThisLoopContext || inLoopBody)) {
        return highlightCode;  // Just highlight, don't compile branches
    }
    
    // Original logic for while loops...
    const yesId = this.getSuccessor(nodeId, 'yes');
    const exitId = this.getSuccessor(nodeId, 'no');
    
    if (isInThisLoopContext || inLoopBody) {
        return highlightCode + this.compileNode(yesId, visitedInPath, [...contextStack], indentLevel,
    inLoopBody,
    inLoopHeader);
    } else {
        return highlightCode + this.compileNode(exitId, visitedInPath, [...contextStack], indentLevel,
    inLoopBody,
    inLoopHeader);
    }
}

// normal skip â€” not a loop header
    const succ = this.getAllSuccessors(nodeId);
    let out = highlightCode; // Start with highlight
    for (const { nodeId: nxt } of succ) {
        out += this.compileNode(nxt, visitedInPath, [...contextStack], indentLevel,
    inLoopBody,
    inLoopHeader);
    }
    return out;
}
    // ================= IMPLICIT FOREVER LOOP HANDLING =================
    
    // Do we have implicit loop headers computed?
    if (this.implicitLoopHeaders && this.implicitLoopHeaders.has(nodeId)) {
        
        // Already lowered once â†’ do NOT lower again â†’ just continue to successor
        if (this.loweredImplicitLoops.has(nodeId)) {
            const next = this.getSuccessor(nodeId, "next");
            return this.compileNode(next, visitedInPath, contextStack, indentLevel,
        inLoopBody,
        inLoopHeader);
        }
        
        // Mark lowered so we don't recurse forever
        this.loweredImplicitLoops.add(nodeId);
        
        // Emit while True loop safely
        return this.compileImplicitForeverLoop(
            nodeId,
            visitedInPath,
            contextStack,
            indentLevel,
        inLoopBody,
        inLoopHeader
        );
    }
    // ================================================================
    
    const indent = "    ".repeat(indentLevel);
    let code = "";
    
    // Add highlight if enabled - FOR ALL NODE TYPES
    if (this.useHighlighting) {
        code += `${indent}highlight('${node.id}')\n`;
    }
    
    // Handle different node types
    switch (node.type) {
        case 'decision':
            return this.compileDecision(node, visitedInPath, contextStack, indentLevel,
        inLoopBody,
        inLoopHeader);
            
        case 'start':
            // Just continue to next node
            break;
            
        case 'end':
            // Already handled at the beginning
            break;
            
        case 'output':
            code += `${indent}print(${node.text})\n`;
            break;
            
        case 'input':
            const wrap = node.dtype === 'int' ? 'int(input(' : 'input(';
            code += `${indent}${node.varName} = ${wrap}${node.prompt})\n`;
            //code += `${indent}${node.varName} = ${wrap}"${node.prompt}")\n`;
            if (node.dtype === 'int') code = code.trimEnd() + ")\n";
            break;
            
        default:
            // Process, var, etc.
            if (node.text) code += `${indent}${node.text}\n`;
            break;
    }
    
    // Get next node (default 'next' port)
    const nextNodeId = this.getSuccessor(nodeId, 'next');
    
    // If we're in a loop context, check if next node is any loop header in the stack
    // If so, don't follow it (it's a back edge)
    if (contextStack.length > 0) {
        for (const ctx of contextStack) {
            if (ctx.startsWith('loop_')) {
                const loopHeaderId = ctx.replace('loop_', '');
                if (nextNodeId === loopHeaderId) {
                    // This is a back edge to a loop header, stop here
                    return code;
                }
            }
        }
    }
    
    // Also check if next node is a decision that's already in the context stack
    // This prevents infinite recursion when multiple loops share nodes
    if (nextNodeId) {
        const nextNode = this.nodes.find(n => n.id === nextNodeId);
        if (nextNode && nextNode.type === 'decision') {
            const isAlreadyInStack = contextStack.some(ctx => ctx === `loop_${nextNodeId}`);
            if (isAlreadyInStack) {
                // This decision is already being compiled as a loop, don't follow it
                return code;
            }
        }
        
        // Check if next node is already visited in current context to prevent cycles
        const nextContextId = `${nextNodeId}_${contextStack.join('_')}_${indentLevel}`;
        if (visitedInPath.has(nextContextId)) {
            // This node is already being compiled in this context, stop to prevent cycle
            return code;
        }
    }
    
    // Continue compilation
    code += this.compileNode(nextNodeId, visitedInPath, contextStack, indentLevel,
    inLoopBody,
    inLoopHeader);
    
    return code;
}



compileSingleNode(nodeId, indentLevel) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (!node) return "";
    
    const indent = "    ".repeat(indentLevel);
    let code = "";
    
    // Add highlight if enabled
    if (this.useHighlighting) {
        code += `${indent}highlight('${node.id}')\n`;
    }
    
    switch (node.type) {
        case "output":
            code += `${indent}print(${node.text})\n`;
            break;
            
        case "input":
            const wrap = node.dtype === "int" ? "int(input(" : "input(";
            code += `${indent}${node.varName} = ${wrap}"${node.prompt}")\n`;
            if (node.dtype === "int") code = code.trimEnd() + ")\n";
            break;
            
        case "decision":
            // decision itself is handled elsewhere â€“ treat as no-op here
            break;
            
        case "start":
        case "end":

            break;
            
        default:
            if (node.text) code += `${indent}${node.text}\n`;
    }
    
    return code;
}  
    
    
    compileImplicitForeverLoop(nodeId, visitedInPath, contextStack, indentLevel,
    inLoopBody,
    inLoopHeader) {

const indent = "    ".repeat(indentLevel);
let code = "";

// while True header
code += `${indent}while True:\n`;

if (this.useHighlighting) {
    code += `${indent}    highlight('${nodeId}')\n`;
}

// ----- compile the header node body once (inside loop) -----
const nodeCode = this.compileSingleNode(nodeId, indentLevel + 1) || "";

// ----- then compile successor chain -----
const nextId = this.getSuccessor(nodeId, "next");

const bodyCode =
    this.compileNode(
        nextId,
        new Set(), // fresh visited set to stop recursion chain explosion
        [...contextStack, `implicit_${nodeId}`],
        indentLevel + 1,
    inLoopBody,
    inLoopHeader
    ) || "";

const fullBody = (nodeCode + bodyCode).trim()
    ? nodeCode + bodyCode
    : `${indent}    pass\n`;

code += fullBody;

return code;
}


/**
 * Simple if/else compilation without elif chains for nested decision structures
 */
 compileSimpleIfElse(node, yesId, noId, visitedInPath, contextStack, indentLevel,
    inLoopBody = false,
    inLoopHeader = false) {
        const indent = "    ".repeat(indentLevel);
    let code = "";
    
    // FIX: Add highlight for the decision node itself
    if (this.useHighlighting) {
        code += `${indent}highlight('${node.id}')\n`;
    }
    
    code += `${indent}if ${node.text}:\n`;  

    // Compile YES branch
    const ifContext = [...contextStack, `if_${node.id}`];
    const ifVisited = new Set([...visitedInPath]);
    const ifCode = this.compileNode(yesId, ifVisited, ifContext, indentLevel + 1, inLoopBody, inLoopHeader);
    code += ifCode || `${indent}    pass\n`;

    // Compile NO branch
    if (noId) {
        code += `${indent}else:\n`;
        const elseContext = [...contextStack, `else_${node.id}`];
        const elseVisited = new Set([...visitedInPath]);
        const elseCode = this.compileNode(noId, elseVisited, elseContext, indentLevel + 1, inLoopBody, inLoopHeader);
        code += elseCode || `${indent}    pass\n`;
    }

    return code;
}
    /**
     * Compile decision node (could be if, while, or for)
     */
    /**
 * Compile decision node (could be if, while, or for)
 */
 compileDecision(
    node,
    visitedInPath,
    contextStack,
    indentLevel,
    inLoopBody = false,
    inLoopHeader = false
) {
    const yesId = this.getSuccessor(node.id, 'yes');
    const noId  = this.getSuccessor(node.id, 'no');

    // If this decision node is *already* in a loop context,
    // just treat it as a normal if/else to avoid re-creating the loop.
    const isAlreadyLoop = contextStack.some(ctx => ctx === `loop_${node.id}`);
    if (isAlreadyLoop) {
        return this.compileIfElse(node, yesId, noId, visitedInPath, contextStack, indentLevel,
    inLoopBody,
    inLoopHeader);
    }

    // Simple loop detection: does this branch eventually lead back to me?
    const isLoopYes = this.isLoopHeader(node.id, yesId);
    const isLoopNo  = noId ? this.isLoopHeader(node.id, noId) : false;
    const isLoop    = isLoopYes || isLoopNo;
    
    if (isLoop) {
        // YES or NO branch is the loop body
        const loopBodyId  = isLoopYes ? yesId : noId;
        const exitId      = isLoopYes ? noId  : yesId;
        const useNoBranch = !isLoopYes && isLoopNo;  // loop on "no" branch => negate condition

        return this.compileLoop(
            node,
            loopBodyId,
            exitId,
            visitedInPath,
            contextStack,
            indentLevel,
            useNoBranch,
    inLoopBody,
    inLoopHeader
        );
    } else {
        // Plain if/else - BUT use a simpler approach for nested decisions
        return this.compileSimpleIfElse(node, yesId, noId, visitedInPath, contextStack, indentLevel,
    inLoopBody,
    inLoopHeader);
    }
}
    /**
     * Check if a decision node is a loop header
     */
/**
 * Check if a decision node is a loop header by following all paths
 */
 isLoopHeader(nodeId, branchId) {

if (!branchId) return false;

const MAX_DEPTH = 200;
const visited = new Set();

const dfs = (id, depth = 0) => {

    if (!id) return false;
    if (depth > MAX_DEPTH) return false;

    // Real loop only if it comes back to THIS decision
    if (id === nodeId) return true;

    if (visited.has(id)) return false;
    visited.add(id);

    const outgoing = this.outgoingMap.get(id) || [];

    for (const edge of outgoing) {
        if (dfs(edge.targetId, depth + 1)) {
            return true;
        }
    }

    return false;
};

return dfs(branchId, 0);
}


// ensure increment -> header path has NO other decisions
pathIsDirectIncrementToHeader(incId, headerId) {

const stack = [incId];
const visited = new Set();

while (stack.length) {
    const cur = stack.pop();
    if (visited.has(cur)) continue;
    visited.add(cur);

    if (cur === headerId) return true;

    const outgoing = this.outgoingMap.get(cur) || [];

    for (const edge of outgoing) {
        const nxt = edge.targetId;

        if (nxt === headerId) {
            return true; // direct OK
        }

        const node = this.nodes.find(n => n.id === nxt);

        // ðŸš« reject if another decision is in between
        if (node && node.type === "decision") return false;

        stack.push(nxt);
    }
}

return false;
}

/**
 * Check if a path from startId eventually leads to targetId
 */
 pathLeadsTo(startId, targetId, visited = new Set()) {
    if (!startId || visited.has(startId)) return false;
    if (startId === targetId) return true;
    
    visited.add(startId);
    
    const outgoing = this.outgoingMap.get(startId) || [];
    for (const edge of outgoing) {
        if (this.pathLeadsTo(edge.targetId, targetId, visited)) {
            return true;
        }
    }
    
    return false;
}
/**
 * Compile loop structure (while or for)
 *
 * node         = decision node (loop header)
 * loopBodyId   = entry node of looping branch
 * exitId       = entry node of exit branch (after loop)
 * useNoBranch  = true when NO branch is the loop body
 */
 compileLoop(
    node,
    loopBodyId,
    exitId,
    visitedInPath,
    contextStack,
    indentLevel,
    useNoBranch = false,
    inLoopBody = false,
    inLoopHeader = false
) {


const indent = "    ".repeat(indentLevel);
let code = "";

// -------------------------------
// 1) Try COUNTED FOR loop lowering
// -------------------------------

const forInfo = !useNoBranch ? this.detectForLoopPattern(node.id) : null;

if (forInfo) {

    // mark this decision node as the active loop header
    this.loopHeaderId = node.id;

    // -------------------------------
    // create a local skip set
    // -------------------------------
    const savedSkip = this.nodesToSkip;
    const localSkips = new Set();

    // skip increment statement always
    if (forInfo.incrementNodeId) {
        localSkips.add(forInfo.incrementNodeId);
    }

    // optionally skip init if it directly precedes header
    if (forInfo.initNodeId) {
        const incoming = this.incomingMap.get(node.id) || [];
        const direct = incoming.some(c => c.sourceId === forInfo.initNodeId);
        if (direct) localSkips.add(forInfo.initNodeId);
    }

    // MOST IMPORTANT:
    // the loop header itself must not emit AND must not follow both branches
    localSkips.add(node.id);

    this.nodesToSkip = localSkips;

    // -------------------------------
    // build Python for-range()
    // -------------------------------
    let step = forInfo.step;
    if (!step) {
        step = (parseInt(forInfo.start) <= parseInt(forInfo.end)) ? 1 : -1;
    }

    const rangeStr = `range(${forInfo.start}, ${forInfo.end}, ${step})`;

    code += `${indent}for ${forInfo.variable} in ${rangeStr}:\n`;

    if (this.useHighlighting) {
        code += `${indent}    highlight('${node.id}')\n`;
    }

    // -------------------------------
    // compile loop body ONLY along loop branch
    // -------------------------------
    const loopCtx = [...contextStack, `loop_${node.id}`];

// After compiling the loop body in the for-loop section:
const bodyCode = this.compileNode(
    loopBodyId,
    new Set(),
    loopCtx,
    indentLevel + 1,
    /* inLoopBody = */ true,true
);

// Add highlight for the increment node if we're using highlighting
let finalBodyCode = bodyCode;

code += finalBodyCode.trim() ? finalBodyCode : `${indent}    pass\n`;

// -------------------------------
// compile exit path AFTER loop
// -------------------------------
// compile exit path AFTER loop
// compile exit path AFTER loop
this.nodesToSkip = savedSkip;

if (exitId) {
    console.log(`Checking exit for loop ${node.id}, exitId: ${exitId}, inLoopBody: ${inLoopBody}, contextStack:`, contextStack);
    
    // Check if the exit path eventually leads back to a loop header in our context
    // If so, it's part of nested loop flow; if not, it's a true exit
    let leadsToLoopHeader = false;
    
    for (const ctx of contextStack) {
        if (ctx.startsWith('loop_')) {
            const outerLoopHeaderId = ctx.replace('loop_', '');
            // Check if exitId eventually reaches this outer loop header
            const leads = this.pathLeadsTo(exitId, outerLoopHeaderId, new Set([node.id]));
            console.log(`  Does ${exitId} lead to outer loop ${outerLoopHeaderId}? ${leads}`);
            if (leads) {
                leadsToLoopHeader = true;
                break;
            }
        }
    }
    
    console.log(`  leadsToLoopHeader: ${leadsToLoopHeader}`);
    
    // If we're in a nested loop AND the exit doesn't lead back to an outer loop,
    // then don't compile it (it's a premature exit to END)
    if (inLoopBody && !leadsToLoopHeader) {
        console.log(`  SKIPPING exit path - nested loop exit to END`);
        // Skip this exit path - it's a final exit but we're still in an outer loop
        return code;
    }
    
    console.log(`  COMPILING exit path`);
    
    // Otherwise compile the exit path
    if (this.useHighlighting && !inLoopBody) {
        // Add highlight for when loop condition becomes false (exit)
        code += `${indent}highlight('${node.id}')\n`;
    }
    
    const exitContext = [...contextStack, `loop_${node.id}`];
    code += this.compileNode(
        exitId,
        visitedInPath,
        exitContext,
        indentLevel,
        false,  // Exit path is NOT in a loop body
        false
    );
}
return code;
}

// -------------------------------
// 2) OTHERWISE â†’ WHILE LOOP
// -------------------------------

// YES-branch loop â†’ normal condition
// NO-branch loop  â†’ negate condition
let condition = node.text;
if (useNoBranch) condition = `not (${condition})`;

code += `${indent}while ${condition}:\n`;

if (this.useHighlighting) {
    code += `${indent}    highlight('${node.id}')\n`;
}

const whileCtx = [...contextStack, `loop_${node.id}`];

const bodyCode = this.compileNode(
    loopBodyId,
    new Set(),
    whileCtx,
    indentLevel + 1,true,
    /* inLoopBody = */ true
);

code += bodyCode.trim() ? bodyCode : `${indent}    pass\n`;

// exit path after while
if (exitId) {
    code += this.compileNode(
        exitId,
        visitedInPath,
        contextStack,
        indentLevel,
    false,
    false
    );
}

return code;
}

    /**
     * Detect for loop pattern:
     * Looks for: var = 0 â†’ decision â†’ ... â†’ var = var + 1 â†’ back to decision
     */
/**
 * Improved for loop detection with path analysis
 */
/**
 * Detect for loop pattern (increasing and decreasing)
 * Supports:
 *   i = 0      / i = start
 *   i < end    / i <= end / i > end / i >= end
 *   i = i + k  / i += k / i = i - k / i -= k
 *   numeric OR variable bounds
 */
 detectForLoopPattern(decisionId) {
// cache already computed answers
if (this.forPatternCache.has(decisionId)) {
    return this.forPatternCache.get(decisionId);
}

// prevent re-entry recursion explosions
if (this.forPatternInProgress.has(decisionId)) {

return null;

}

this.forPatternInProgress.add(decisionId);

// -------------------------------
// 1) Find initialisation before decision (walk back in straight line)
// -------------------------------
let initNode = null;
let varName = null;
let startValue = null;

const visitedBack = new Set();
const stack = [...(this.incomingMap.get(decisionId) || [])];

while (stack.length > 0) {
    const conn = stack.pop();
    if (!conn || visitedBack.has(conn.sourceId)) continue;

    visitedBack.add(conn.sourceId);

    const node = this.nodes.find(n => n.id === conn.sourceId);
    if (!node) continue;

    // stop if control flow *branches* â€“ we only allow straight-line init chains
    const incomings = this.incomingMap.get(node.id) || [];
    if (incomings.length > 1) continue;

    // match: i = 0   OR   i = x   (number or identifier)
    const m = node.text?.match(/^\s*(\w+)\s*=\s*([\w\d_]+)\s*$/);
    if (m) {
        initNode = node;
        varName = m[1];
        startValue = m[2];
        break;
    }

    // continue walking backwards
    (this.incomingMap.get(node.id) || []).forEach(prev => stack.push(prev));
}

if (!varName) return null;

// -------------------------------
// 2) Parse loop condition
// -------------------------------
const decisionNode = this.nodes.find(n => n.id === decisionId);
if (!decisionNode || !decisionNode.text) return null;

const condition = decisionNode.text.trim();

let endValue = null;
let comparisonOp = null;

const condPatterns = [
    { re: new RegExp(`${varName}\\s*<\\s*([\\w\\d_]+)`), op: '<'  },
    { re: new RegExp(`${varName}\\s*<=\\s*([\\w\\d_]+)`), op: '<=' },
    { re: new RegExp(`${varName}\\s*>\\s*([\\w\\d_]+)`), op: '>'  },
    { re: new RegExp(`${varName}\\s*>=\\s*([\\w\\d_]+)`), op: '>=' },
];

for (const p of condPatterns) {
    const m = condition.match(p.re);
    if (m) {
        endValue = m[1];
        comparisonOp = p.op;
        break;
    }
}

if (!endValue) return null;

// -------------------------------
// 3) Find increment anywhere in loop body (BFS)
// -------------------------------
const yesId = this.getSuccessor(decisionId, 'yes');
const incrementInfo = this.findIncrementNodeBFS(yesId, decisionId, varName);

if (!incrementInfo) return null;

let step = incrementInfo.step || 1;

// -------------------------------
// 4) Handle increasing vs decreasing loops
// -------------------------------
let finalStart = startValue;
let finalEnd   = endValue;
let finalStep  = step;

// --- DECREASING LOOPS (DOWNWARD) ---
if (comparisonOp === '>' || comparisonOp === '>=') {

// force negative step
finalStep = -Math.abs(step);

// range() is exclusive, so:
//   i > 0  â†’ range(start, end, -1)        (stops before end)
//   i >= 0 â†’ range(start, end-1, -1)      (include zero)
if (comparisonOp === '>=') {
    finalEnd = `${parseInt(endValue) - 1}`;
} else {
    finalEnd = endValue;
}

// --- INCREASING LOOPS (UPWARD) ---
} else {

    // ensure positive step
    finalStep = Math.abs(step);

    if (comparisonOp === '<=') {
        // include the end value
        finalEnd = `(${endValue}) + 1`;
    } else {
        finalEnd = endValue;
    }
}

// -------------------------------
// 5) NEW SAFETY CHECK
// increment must flow back to THIS decision directly,
// and MUST NOT pass through any other decision nodes
// -------------------------------
const incId = incrementInfo.node.id;

if (!this.pathIsDirectIncrementToHeader(incId, decisionId)) {
    // âŒ not a clean counted loop â€” leave it as while + inner logic
    this.forPatternInProgress.delete(decisionId);
this.forPatternCache.set(decisionId, null);
return null;

}

// -------------------------------
// 6) otherwise it's a valid counted for-loop
// -------------------------------
this.forPatternInProgress.delete(decisionId);

const result = {
    variable: varName,
    start: finalStart,
    end: finalEnd,
    step: finalStep,
    incrementNodeId: incId,
    initNodeId: initNode?.id ?? null
};

this.forPatternCache.set(decisionId, result);
return result;


 }

/**
 * Find increment node using BFS to handle longer paths
 * Returns object with node, step size, and direction info
 */
findIncrementNodeBFS(startId, stopId, varName) {
    const queue = [{ nodeId: startId, visited: new Set() }];
    
    while (queue.length > 0) {
        const current = queue.shift();
        
        if (current.nodeId === stopId || current.visited.has(current.nodeId)) {
            continue;
        }
        
        current.visited.add(current.nodeId);
        
        const node = this.nodes.find(n => n.id === current.nodeId);
        if (node) {
            // Check for various increment patterns
            // Pattern 1: i = i + 1, i = i - 1, i = i + 2, etc.
            let incrementMatch = node.text.match(new RegExp(`^\\s*${varName}\\s*=\\s*${varName}\\s*([+-])\\s*(\\d+)\\s*$`));
            if (incrementMatch && (node.type === 'process' || node.type === 'var')) {
                const op = incrementMatch[1];
                const step = parseInt(incrementMatch[2]);
                return {
                    node: node,
                    step: step,
                    isDecrement: op === '-'
                };
            }
            
            // Pattern 2: i += 1, i -= 1, i += 2, etc.
            incrementMatch = node.text.match(new RegExp(`^\\s*${varName}\\s*([+-])=\\s*(\\d+)\\s*$`));
            if (incrementMatch && (node.type === 'process' || node.type === 'var')) {
                const op = incrementMatch[1];
                const step = parseInt(incrementMatch[2]);
                return {
                    node: node,
                    step: step,
                    isDecrement: op === '-'
                };
            }
        }
        
        // Add next nodes to queue
        const nextId = this.getSuccessor(current.nodeId, 'next');
        if (nextId && !current.visited.has(nextId)) {
            queue.push({
                nodeId: nextId,
                visited: new Set([...current.visited])
            });
        }
        
        // Also check yes branch if this is a decision
        if (node && node.type === 'decision') {
            const yesId = this.getSuccessor(current.nodeId, 'yes');
            if (yesId && !current.visited.has(yesId)) {
                queue.push({
                    nodeId: yesId,
                    visited: new Set([...current.visited])
                });
            }
        }

        // ALSO follow the NO branch (needed for nested loops where increment is on NO)
if (node && node.type === 'decision') {
    const noId = this.getSuccessor(current.nodeId, 'no');
    if (noId && !current.visited.has(noId)) {
        queue.push({
            nodeId: noId,
            visited: new Set([...current.visited])
        });
    }
}

    }
    

return null;

}

    /**
     * Find increment node in loop body
     */
    findIncrementNode(startId, stopId, varName, visited = new Set()) {
        if (!startId || visited.has(startId) || startId === stopId) return null;
        visited.add(startId);
        
        const node = this.nodes.find(n => n.id === startId);
        if (node) {
            // Check if this is an increment statement
            const incrementPattern = new RegExp(`^\\s*${varName}\\s*=\\s*${varName}\\s*[+-]\\s*\\d+\\s*$`);
            if ((node.type === 'process' || node.type === 'var') && 
                node.text && incrementPattern.test(node.text)) {
                return node;
            }
            
            // Check if this node has a back edge to the loop header
            const outgoing = this.outgoingMap.get(startId) || [];
            const hasBackEdge = outgoing.some(conn => conn.targetId === stopId);
            if (hasBackEdge) {
                // Reached back edge without finding increment
                return null;
            }
        }
        
        // Continue searching
        const nextId = this.getSuccessor(startId, 'next');
        return this.findIncrementNode(nextId, stopId, varName, visited);
    }

    /**
     * Compile loop body, stopping at back edges    
     */
    compileLoopBody(loopHeaderId, startId, skipNodeId, visitedInPath, contextStack, indentLevel,
    inLoopBody = false,
    inLoopHeader = false) {
        let code = "";
        let currentId = startId;
        const visitedInLoop = new Set([...visitedInPath]);
        
        while (currentId && currentId !== loopHeaderId) {
            // >>> ALWAYS highlight loop body nodes <<<
        if (this.useHighlighting) {
            const indentHL = "    ".repeat(indentLevel);
            code += `${indentHL}highlight('${currentId}')\n`;
        }

            // Check if we should skip this node (for increment in for loops)
            if (currentId === skipNodeId) {
                currentId = this.getSuccessor(currentId, 'next');
                continue;
            }
            
            const node = this.nodes.find(n => n.id === currentId);
            if (!node) break;
            
            // Check if this node has a back edge to the loop header
            const outgoing = this.outgoingMap.get(currentId) || [];
            const hasBackEdge = outgoing.some(conn => 
    conn.targetId === loopHeaderId &&
    (conn.port === 'next' || conn.port === 'yes' || conn.port === 'no'));

            
            // Also check if next node is any loop header in the context stack
            const nextId = this.getSuccessor(currentId, 'next');
            let isBackEdgeToAnyLoop = false;
            if (nextId && contextStack.length > 0) {
                for (const ctx of contextStack) {
                    if (ctx.startsWith('loop_')) {
                        const ctxLoopHeaderId = ctx.replace('loop_', '');
                        if (nextId === ctxLoopHeaderId) {
                            isBackEdgeToAnyLoop = true;
                            break;
                        }
                    }
                }
            }
            
            if (hasBackEdge || isBackEdgeToAnyLoop) {
                // Compile this node but don't follow the back edge
                // We need to compile just this node's code without following its 'next' connection
            // Compile this node but don't follow the back edge
            const indent = "    ".repeat(indentLevel);


            if (this.useHighlighting) {
                code += `${indent}highlight('${node.id}')\n`;
            }

            switch (node.type) {
                case 'output':
                    code += `${indent}print(${node.text})\n`;
                    break;

                    case 'input':
                        const wrap = node.dtype === 'int' ? 'int(input(' : 'input(';
                        code += `${indent}${node.varName} = ${wrap}"${node.prompt}")\n`;
                        if (node.dtype === 'int') code = code.trimEnd() + ")\n";
                        break;
                    default:
                        if (node.text) code += `${indent}${node.text}\n`;
                        break;
                }
                break;
            }
            
            // Compile the node
// Always highlight body nodes
            if (this.useHighlighting) {
                code += `${"    ".repeat(indentLevel)}highlight('${currentId}')\n`;
            }

            // Compile the node normally
            const nodeCode = this.compileNode(currentId, visitedInLoop, contextStack, indentLevel, true, true);
            code += nodeCode;

            
            // Move to next node, but check if it's the loop header first
            if (nextId === loopHeaderId) {
                // Next node is the loop header, stop here
                break;
            }
            currentId = nextId;
        }
        
        return code;
    }

    /**
     * Compile if/else statement with support for elif
     */
/**
 * Compile if/else statement with support for elif
 */
 compileIfElse(node, yesId, noId, visitedInPath, contextStack, indentLevel,
    inLoopBody = false,
    inLoopHeader = false) {
    
    // Check if this decision is part of a "find largest/smallest" pattern
    // where we have nested decisions that should stay as separate if/else blocks
    const yesNode = this.nodes.find(n => n.id === yesId);
    const noNode = this.nodes.find(n => n.id === noId);
    
    // If either branch leads to another decision, use simple if/else
    // This prevents elif chains for nested decision trees
    if ((yesNode && yesNode.type === 'decision') || 
        (noNode && noNode.type === 'decision')) {
        return this.compileSimpleIfElse(node, yesId, noId, visitedInPath, contextStack, indentLevel,
    inLoopBody,
    inLoopHeader);
    }
    
    // Otherwise, use the original elif chain logic
    const indent = "    ".repeat(indentLevel);
    let code = `${indent}if ${node.text}:\n`;

    // ----- IF BRANCH -----
    const ifContext = [...contextStack, `if_${node.id}`];
    const ifVisited = visitedInPath;
    const ifDecisionContextId = `${node.id}_${ifContext.join('_')}_${indentLevel + 1}`;
    ifVisited.add(ifDecisionContextId);

    const ifCode = this.compileNode(yesId, ifVisited, ifContext, indentLevel + 1 ,inLoopBody,inLoopHeader);
    code += ifCode || `${indent}    pass\n`;

    // ----- ELSE / ELIF -----
    if (noId) {
        const noNode = this.nodes.find(n => n.id === noId);

        if (noNode && noNode.type === 'decision') {
            // Check if this "else" decision is itself a loop header.
            // If it is, we MUST NOT turn it into an elif chain, or we get
            // exactly the infinite recursion you're seeing.
            const yesOfNo        = this.getSuccessor(noNode.id, 'yes');
            const noBranchIsLoop = this.isLoopHeader(noNode.id, yesOfNo);

            if (noBranchIsLoop) {
                // Treat it as a plain else: block, whose contents happen
                // to start with another while-loop decision.
                const elseContext = [...contextStack, `else_${node.id}`];
                const elseVisited = visitedInPath;
                const elseDecisionContextId = `${node.id}_${elseContext.join('_')}_${indentLevel + 1}`;
                elseVisited.add(elseDecisionContextId);

                code += `${indent}else:\n`;
                const elseCode = this.compileNode(noId, elseVisited, elseContext, indentLevel + 1,inLoopBody,inLoopHeader);
                code += elseCode || `${indent}    pass\n`;
            } else {
                // Safe to treat as an elif chain
                code += this.compileElifChain(noNode, visitedInPath, contextStack, indentLevel ,inLoopBody,inLoopHeader);
            }
        } else {
            // Simple else branch (no decision node at the top)
            const elseContext = [...contextStack, `else_${node.id}`];
            const elseVisited = visitedInPath;
            const elseDecisionContextId = `${node.id}_${elseContext.join('_')}_${indentLevel + 1}`;
            elseVisited.add(elseDecisionContextId);

            code += `${indent}else:\n`;
            const elseCode = this.compileNode(noId, elseVisited, elseContext, indentLevel + 1,inLoopBody,inLoopHeader);
            code += elseCode || `${indent}    pass\n`;
        }
    }

    return code;
}   /**
     * Handle elif chains
     */
/**
 * Handle elif chains safely (no infinite A â†” B bouncing)
 */
compileElifChain(elifNode, visitedInPath, contextStack, indentLevel ,inLoopBody,inLoopHeader) {
    let code = "";
    const indent = "    ".repeat(indentLevel);

    let currentElif = elifNode;
    const seen = new Set();   // prevent the same decision reappearing in the chain

    while (currentElif && currentElif.type === 'decision') {
        // Stop if weâ€™ve already emitted this decision in the chain
        if (seen.has(currentElif.id)) break;
        seen.add(currentElif.id);

        const elifYesId = this.getSuccessor(currentElif.id, 'yes');
        const elifNoId  = this.getSuccessor(currentElif.id, 'no');

        code += `${indent}elif ${currentElif.text}:\n`;

        const elifContext = [...contextStack, `elif_${currentElif.id}`];
        const elifVisited = visitedInPath;

        const elifCode = this.compileNode(elifYesId, elifVisited, elifContext, indentLevel + 1,inLoopBody,inLoopHeader);
        code += elifCode || `${indent}    pass\n`;

        if (!elifNoId) break;

        const nextNode = this.nodes.find(n => n.id === elifNoId);

        // Another elif in the chain?
        if (nextNode && nextNode.type === 'decision') {
            currentElif = nextNode;
            continue;
        }

        // Final else clause
        code += `${indent}else:\n`;
        const elseCode = this.compileNode(elifNoId, visitedInPath, contextStack, indentLevel + 1,inLoopBody,inLoopHeader);
        code += elseCode || `${indent}    pass\n`;

        break;
    }

    return code;
}

}

const App = {
    nodes: [], connections: [], nextId: 1, isRunning: false,
    isConnecting: false, connStart: null, fullExecCode: "",
    editingNode: null, selectedNodeId: null,viewportScale: 1,
viewportX: 0,
viewportY: 0,
minScale: 0.3,
maxScale: 2.5,
cancelExecution: false,
skulptTask: null,
skModule: null,

screenFromWorld(x, y) {
    return {
        x: x * this.viewportScale + this.viewportX,
        y: y * this.viewportScale + this.viewportY
    };
}
,
exportPython() {
    const code = document.getElementById("code-python").innerText || "";

    const blob = new Blob([code], { type: "text/x-python" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "flowcode_program.py";
    a.click();

    URL.revokeObjectURL(url);
}
,
exportJSON() {
    const diagram = {
        nodes: this.nodes,
        connections: this.connections,
        version: "3.0"
    };

    const blob = new Blob(
        [JSON.stringify(diagram, null, 2)],
        { type: "application/json" }
    );

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "flowchart.json";
    a.click();

    URL.revokeObjectURL(url);
}
,   

async exportImage() {

if (this.nodes.length === 0) {
    alert("Nothing to export.");
    return;
}

const canvasEl = document.getElementById("canvas");

// 1ï¸âƒ£ Save user viewport
const oldScale = this.viewportScale;
const oldX = this.viewportX;
const oldY = this.viewportY;

// 2ï¸âƒ£ Compute bounding box of all nodes
let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

this.nodes.forEach(n => {
    minX = Math.min(minX, n.x);
    minY = Math.min(minY, n.y);
    maxX = Math.max(maxX, n.x + 180);  // rough width
    maxY = Math.max(maxY, n.y + 120);  // rough height
});

// 3ï¸âƒ£ Reset viewport (no CSS transform)
this.viewportScale = 1;
this.viewportX = -minX + 30;
this.viewportY = -minY + 30;
this.applyViewportTransform();

// 4ï¸âƒ£ Redraw connectors at real coordinates
this.drawConns();

// 5ï¸âƒ£ wait for layout/paint
await new Promise(r => requestAnimationFrame(r));

// 6ï¸âƒ£ Capture
const canvas = await html2canvas(canvasEl, {
    backgroundColor: "#ffffff",
    scale: 2
});

// 7ï¸âƒ£ Restore user view
this.viewportScale = oldScale;
this.viewportX = oldX;
this.viewportY = oldY;
this.applyViewportTransform();
this.drawConns();

// 8ï¸âƒ£ Download
canvas.toBlob(blob => {
    if (!blob) {
        const url = canvas.toDataURL("image/png");
        const a = document.createElement("a");
        a.href = url;
        a.download = "flowchart.png";
        a.click();
        return;
    }

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "flowchart.png";
    a.click();
    URL.revokeObjectURL(url);
});
}
,
openSaveOptions() {
    const modal = new bootstrap.Modal(
        document.getElementById('saveOptionsModal')
    );
    modal.show();
}
,
updateVarWatch(varsObj) {
const div = document.getElementById("varwatch-table");
if (!div) return;

let html = "<table style='width:100%; border-collapse: collapse;'>";
let hasVars = false;

for (const key in varsObj) {
    // Filter out internal Skulpt attributes and the highlight function itself
    if (key.startsWith("__") || key === "highlight" || key === "input" || key === "print") continue;

    let val = varsObj[key];
    let displayVal = val;

    // Safely unwrap Skulpt types
    if (val !== null && typeof val === 'object') {
        if (val.v !== undefined) {
            displayVal = val.v; // Standard primitives
        } else if (val.tp$name !== undefined) {
            displayVal = `[${val.tp$name}]`; // Objects/Lists
        }
    }

    html += `
        <tr style="border-bottom: 1px solid #333;">
            <td style="color: #888; padding: 4px; font-weight: bold;">${key}</td>
            <td style="color: #0f0; padding: 4px; text-align: right;">${displayVal}</td>
        </tr>`;
    hasVars = true;
}

html += "</table>";
div.innerHTML = hasVars ? html : "<em>No variables set</em>";
},

stopSim() {
    if (!this.isRunning) return;

    this.cancelExecution = true;

    // abort Skulpt task if exists
    if (this.skulptTask && this.skulptTask.cancel) {
        try { this.skulptTask.cancel(); } catch (_) {}
    }

    this.isRunning = false;

    // UI reset
    document.querySelectorAll('.node').forEach(n => n.classList.remove('running'));
    document.getElementById('run-btn').style.display = "inline-block";
    document.getElementById('stop-btn').style.display = "none";

    this.log("\n>>> Stopped.");
}
,
async loadExampleFromFile(filename) {
    try {
        const res = await fetch(`flows/${filename}`);
        if (!res.ok) {
            alert(`Could not load ${filename}`);
            return;
        }

        const diagram = await res.json();
        this.loadDiagramObject(diagram);

    } catch (err) {
        console.error(err);
        alert("Error loading example file");
    }
},
loadDiagramObject(diagram) {
    if (!diagram.nodes || !Array.isArray(diagram.nodes)) {
        alert("Invalid diagram file (missing nodes)");
        return;
    }

    if (!diagram.connections || !Array.isArray(diagram.connections)) {
        alert("Invalid diagram file (missing connections)");
        return;
    }

    // reset
    this.nodes = [];
    this.connections = [];
    this.selectedNodeId = null;

    document.getElementById('nodes-layer').innerHTML = "";
    document.getElementById('console').innerHTML = "";
    document.getElementById('code-python').innerText = "";

    this.nextId = 1;

    // restore nodes
    diagram.nodes.forEach(node => {
        const num = parseInt(node.id.replace("n", "")) || 0;
        if (num >= this.nextId) this.nextId = num + 1;

        this.nodes.push(node);
        this.renderNode(node);
    });

    // restore connections
    this.connections = diagram.connections;

    requestAnimationFrame(() => {
        this.drawConns();
        this.updateCode();
        if (this.resetView) this.resetView();
    });
},

zoomIn() {
    this.viewportScale = Math.min(this.maxScale, this.viewportScale * 1.2);
    this.applyViewportTransform();
},

zoomOut() {
    this.viewportScale = Math.max(this.minScale, this.viewportScale / 1.2);
    this.applyViewportTransform();
},

resetView() {
    this.viewportScale = 1;
    this.viewportX = 0;
    this.viewportY = 0;
    this.applyViewportTransform();
},

applyViewportTransform() {
    const t = `translate(${this.viewportX}px, ${this.viewportY}px) scale(${this.viewportScale})`;
    this.nodesLayer.style.transform = t;
    //this.svgLayer.style.transform = t;

    // force connectors to match new zoom/pan
    this.drawConns();
}
,

    init() {

        
        Sk.configure({ 
            output: (t) => this.log(t), 
            read: (x) => Sk.builtinFiles["files"][x], 
            inputfun: (p) => this.handleInput(p), 
            inputfunTakesPrompt: true 
        });
        this.canvas = document.getElementById('canvas');
        this.nodesLayer = document.getElementById('nodes-layer');
        this.svgLayer = document.getElementById('connections-layer');
        this.dragLine = document.getElementById('drag-line');
        this.setupGlobalEvents();
        this.setupDragDrop();
        this.createNode('start', 50, 50);
        document.getElementById('save-node-btn').onclick = () => this.saveNodeEdit();
        this.applyViewportTransform();
        this.dragLine = document.createElementNS("http://www.w3.org/2000/svg", "path");
this.dragLine.setAttribute("stroke", "#666");
this.dragLine.setAttribute("stroke-width", "3");
this.dragLine.setAttribute("fill", "none");
this.dragLine.style.display = "none";
this.svgLayer.appendChild(this.dragLine);
this.loadExampleFromFile("welcome.json");

    },

    log(t) { 
        const c = document.getElementById('console'); 
        const s = document.createElement('span'); 
        s.innerText = t; 
        c.appendChild(s); 
        c.scrollTop = c.scrollHeight; 
    },

    handleInput(prompt) {
        return new Promise((resolve) => {
            const modal = new bootstrap.Modal(document.getElementById('inputModal'));
            document.getElementById('modal-prompt').innerText = prompt || "\"Enter value:\"";
            const field = document.getElementById('modal-field');
            field.value = ""; modal.show();
            const finish = () => { modal.hide(); resolve(field.value); };
            document.getElementById('modal-submit').onclick = finish;
            field.onkeydown = (e) => { if(e.key === 'Enter') finish(); };
        });
    },

    createNode(type, x, y) {

// â˜… Prevent more than one START node
if (type === "start") {
    const hasStart = this.nodes.some(n => n.type === "start");
    if (hasStart) {
        alert("Only one Start node is allowed.");
        return;
    }
}

// â˜… Prevent more than one END node
if (type === "end") {
    const hasEnd = this.nodes.some(n => n.type === "end");
    if (hasEnd) {
        alert("Only one End node is allowed.");
        return;
    }
}

const id = `n${this.nextId++}`;

        let text = '';
        let varName = "x";
        let prompt = "\"Enter value\"";
        let dtype = "int";
        
        switch(type) {
            
    case 'start': text = 'Start'; break;
    case 'end':   text = 'End'; break;
    case 'decision': text = 'x < 10'; break;
    case 'var': text = 'x = 0'; break;
    case 'list':
    text = 'myList = []';
    break;

    case 'output': text = 'x'; break;
    case 'process': text = 'x = x + 1'; break;
    case 'input': text = ''; varName = "x"; prompt = "\"Enter value\""; dtype = "int"; break;
}

        
        const config = { id, type, x, y, text, varName, prompt, dtype };
        this.nodes.push(config); 
        this.renderNode(config); 
        this.updateCode();
    },

    renderNode(node) {
    const el = document.createElement('div');
    el.className = `node shape-${node.type}`; 
    el.id = node.id;
    el.style.left = node.x + 'px'; 
    el.style.top = node.y + 'px';
    
    let label = node.text;
    if (node.type === 'output') label = `${node.text}`;
    if (node.type === 'input') label = `${node.prompt}`;
    
    // Logic for the Diamond SVG
    if (node.type === 'decision') {
        el.innerHTML = `
            <svg class="decision-svg" viewBox="0 0 100 100" preserveAspectRatio="none">
                <polygon points="50,0 100,50 50,100 0,50" />
            </svg>
            <div class="inner-text">${label}</div>
        `;
    } else {
        el.innerHTML = `<div class="inner-text">${label}</div>`;
    }
    el.title = label || "";
    // Ports
    if (node.type !== 'start') this.addDot(el, 'in', 'in');
    
    if (node.type === 'decision') { 
        this.addDot(el, 'out-yes', 'yes'); 
        this.addDot(el, 'out-no', 'no'); 
    } else if (node.type !== 'end') {
        this.addDot(el, 'out', 'next');
    }
    
    // Dragging Logic (unchanged)
    el.onpointerdown = (e) => {
        if (e.target.classList.contains('dot')) return;
        this.selectNode(node.id);
        const sX = e.clientX, sY = e.clientY, iX = node.x, iY = node.y;
        const move = (me) => {
            node.x = iX + (me.clientX - sX); 
            node.y = iY + (me.clientY - sY);
            el.style.left = node.x + 'px'; 
            el.style.top = node.y + 'px';
            this.drawConns();
        };
        window.addEventListener('pointermove', move);
        window.addEventListener('pointerup', () => { 
            window.removeEventListener('pointermove', move); 
            this.updateCode(); 
        }, {once: true});
    };
    
    el.ondblclick = () => this.openEditor(node);
    this.nodesLayer.appendChild(el);
},
    selectNode(id) {
        this.selectedNodeId = id;
        document.querySelectorAll('.node').forEach(n => 
            n.classList.toggle('selected', n.id === id));
    },

    getPortPos(id, portType) {
    const node = this.nodes.find(n => n.id === id);
    if (!node) return { x: 0, y: 0 };

    // These dimensions should match your CSS widths/heights
    const dims = {
        start:    { w: 95,  h: 40 },
        end:      { w: 95,  h: 40 },
        process:  { w: 120, h: 50 },
        var:      { w: 120, h: 50 },
        list:     { w: 140, h: 50 },
        input:    { w: 130, h: 50 },
        output:   { w: 130, h: 50 },
        decision: { w: 130, h: 110 }
    };

    const d = dims[node.type] || { w: 120, h: 50 };
    let x = node.x;
    let y = node.y;

    // Calculate relative offset based on port type
    switch (portType) {
        case 'in':
            x += d.w / 2;
            y += 0;
            break;
        case 'next':
        case 'yes':
            x += d.w / 2;
            y += d.h;
            break;
        case 'no':
            x += d.w;
            y += d.h / 2;
            break;
    }

    return { x, y };
},

drawConns() {

// Remove old labels
document.querySelectorAll('.conn-label').forEach(l => l.remove());

// Reset SVG paths
const d = this.svgLayer.querySelector('defs');
this.svgLayer.innerHTML = "";
this.svgLayer.appendChild(d);
this.svgLayer.appendChild(this.dragLine);

// Manhattan router
function orthogonal(p1, p2) {

    const GAP = 25;   // spacing away from shapes
    const SIDE = 90;  // width for loopbacks

    // ---------- NORMAL DOWNWARD FLOW ----------
    if (p2.y >= p1.y) {

        // go straight down a bit to clear node
        const y1 = p1.y + GAP;

        // midpoint between source and target
        const midY = (y1 + p2.y - GAP) / 2;

        return `
            M ${p1.x} ${p1.y}
            V ${y1}
            V ${midY}
            H ${p2.x}
            V ${p2.y - GAP}
            V ${p2.y}
        `.replace(/\s+/g, ' ');
    }

    // ---------- LOOPBACK / TARGET ABOVE ----------
    // route sideways, then up, then across
    const sideX = p1.x < p2.x ? p1.x - SIDE : p1.x + SIDE;

    return `
        M ${p1.x} ${p1.y}
        V ${p1.y + GAP}
        H ${sideX}
        V ${p2.y - GAP}
        H ${p2.x}
        V ${p2.y}
    `.replace(/\s+/g, ' ');
}

// Draw each connection
this.connections.forEach(c => {

    // world coords from node geometry
const p1w = this.getPortPos(c.from, c.port);
const p2w = this.getPortPos(c.to,   'in');

// âœ” convert to screen coords because SVG NOT transformed
const p1 = this.screenFromWorld(p1w.x, p1w.y);
const p2 = this.screenFromWorld(p2w.x, p2w.y);


    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

    const dStr = orthogonal(p1, p2);

    path.setAttribute('d', dStr);

    // colors by port
    path.setAttribute(
        'stroke',
        c.port === 'yes' ? '#16a34a' :
        c.port === 'no'  ? '#dc2626' :
                        '#444'
    );

    path.setAttribute('stroke-width', 2.5);
    path.setAttribute('fill', 'none');
    path.setAttribute('marker-end', 'url(#arrowhead)');

    // tidy corners
    path.setAttribute('stroke-linejoin', 'round');
    path.setAttribute('stroke-linecap', 'round');

    this.svgLayer.appendChild(path);

    // YES / NO labels
    if (c.port === 'yes' || c.port === 'no') {
        const l = document.createElement('div');
        l.className = 'conn-label';
        l.innerText = c.port.toUpperCase();
        l.style.left = (p1.x + 8) + 'px';
        l.style.top  = (p1.y + 8) + 'px';
        this.svgLayer.parentElement.appendChild(l);

    }
});
}
,

    updateCode() {
        try {
            const comp = new FlowchartCompiler(this.nodes, this.connections, false);
            const execComp = new FlowchartCompiler(this.nodes, this.connections, true);
            const code = comp.compile();
            document.getElementById('code-python').innerText = code;
            this.fullExecCode = execComp.compile();
        } catch (error) {
            console.error('Compilation error:', error);
            document.getElementById('code-python').innerText = `# Compilation Error: ${error.message}\n# Check console for details.`;
            this.fullExecCode = "";
        }
    },

    async runSim() {
if (this.isRunning) return;

this.isRunning = true;
this.cancelExecution = false;

document.getElementById('run-btn').style.display = "none";
document.getElementById('stop-btn').style.display = "inline-block";
document.getElementById('console').innerHTML = ">>> Running...<br/>";

// Reset watch
this.updateVarWatch({});

// Define the highlight bridge
Sk.builtins.highlight = new Sk.builtin.func((id) => {
    if (this.cancelExecution) throw new Error("Execution stopped.");

    const nid = (typeof id === "string") ? id : id.v;

    // UI Update: Highlight Node
    document.querySelectorAll('.node').forEach(n => n.classList.remove('running'));
    const activeNode = document.getElementById(nid);
    if (activeNode) activeNode.classList.add('running');

    // VARIABLE TRACKER LOGIC:
    // Use Sk.globals to get the current state of user variables
    if (Sk.globals) {
        this.updateVarWatch(Sk.globals);
    }

    const delay = 2100 - document.getElementById('speed-slider').value;
    return new Sk.misceval.promiseToSuspension(
        new Promise(resolve => setTimeout(resolve, delay))
    );
});

try {
    this.skulptTask = Sk.misceval.asyncToPromise(() =>
        Sk.importMainWithBody("<stdin>", false, this.fullExecCode, true)
    );
    await this.skulptTask;
} catch (e) {
    if (!this.cancelExecution) this.log(String(e));
}

this.isRunning = false;
document.querySelectorAll('.node').forEach(n => n.classList.remove('running'));
document.getElementById('run-btn').style.display = "inline-block";
document.getElementById('stop-btn').style.display = "none";
if (!this.cancelExecution) this.log("\n>>> Finished.");
} ,
    setupGlobalEvents() {

        this.canvas.addEventListener("wheel", (e) => {
    e.preventDefault();

    const scaleBefore = this.viewportScale;

    if (e.deltaY < 0) this.viewportScale *= 1.1;
    else this.viewportScale /= 1.1;

    this.viewportScale = Math.min(this.maxScale, Math.max(this.minScale, this.viewportScale));

    // zoom towards mouse pointer
    const rect = this.canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    this.viewportX = mx - (mx - this.viewportX) * (this.viewportScale / scaleBefore);
    this.viewportY = my - (my - this.viewportY) * (this.viewportScale / scaleBefore);

    this.applyViewportTransform();
}, { passive: false });
let isPanning = false;
let panStartX = 0;
let panStartY = 0;

this.canvas.addEventListener("pointerdown", (e) => {
    // only pan if clicking empty canvas background
    if (e.target.id === "canvas" || e.target.id === "connections-layer") {
        isPanning = true;
        panStartX = e.clientX - this.viewportX;
        panStartY = e.clientY - this.viewportY;
    }
});

window.addEventListener("pointermove", (e) => {
    if (!isPanning) return;
    this.viewportX = e.clientX - panStartX;
    this.viewportY = e.clientY - panStartY;
    this.applyViewportTransform();
});

window.addEventListener("pointerup", () => {
    isPanning = false;
});

        window.onkeydown = (e) => {
            if ((e.key === "Delete" || e.key === "Backspace") && this.selectedNodeId) {
                if (document.activeElement.tagName === "INPUT") return;
                const n = this.nodes.find(x => x.id === this.selectedNodeId); 
                if(n?.type === 'start') return;
                
                this.nodes = this.nodes.filter(x => x.id !== this.selectedNodeId);
                this.connections = this.connections.filter(c => 
                    c.from !== this.selectedNodeId && c.to !== this.selectedNodeId);
                
                document.getElementById(this.selectedNodeId)?.remove(); 
                this.selectedNodeId = null; 
                this.drawConns(); 
                this.updateCode();
            }
        };
        
        window.onpointermove = (e) => {
    if (!this.isConnecting) return;

    const rect = this.canvas.getBoundingClientRect();

    // --- mouse to WORLD coordinates ---
    const worldX = (e.clientX - rect.left - this.viewportX) / this.viewportScale;
    const worldY = (e.clientY - rect.top  - this.viewportY) / this.viewportScale;

    // --- port position already in WORLD coordinates ---
    const startWorld = this.getPortPos(
        this.connStart.nodeId,
        this.connStart.portType
    );

    // --- convert BOTH into SCREEN/SVG coordinates ---
    const startScreenX = startWorld.x * this.viewportScale + this.viewportX;
    const startScreenY = startWorld.y * this.viewportScale + this.viewportY;

    const endScreenX = worldX * this.viewportScale + this.viewportX;
    const endScreenY = worldY * this.viewportScale + this.viewportY;

    this.dragLine.setAttribute(
        "d",
        `M ${startScreenX} ${startScreenY} L ${endScreenX} ${endScreenY}`
    );
};

        
        window.onpointerup = (e) => {
            if (!this.isConnecting) return;
            this.isConnecting = false; 
            this.dragLine.style.display = 'none';
            
            const target = document.elementFromPoint(e.clientX, e.clientY)?.closest('.node');
            if (target && target.id !== this.connStart.nodeId) {
                // Remove any existing connection from same port
                this.connections = this.connections.filter(c => 
                    !(c.from === this.connStart.nodeId && c.port === this.connStart.portType));
                
                // Add new connection
                this.connections.push({ 
                    from: this.connStart.nodeId, 
                    port: this.connStart.portType, 
                    to: target.id 
                });
                
                this.drawConns(); 
                this.updateCode();
            }
        };
    },

    setupDragDrop() {
        document.querySelectorAll('.palette-item').forEach(p => 
            p.ondragstart = (e) => e.dataTransfer.setData('type', p.dataset.type));
        
        this.canvas.ondragover = (e) => e.preventDefault();
        this.canvas.ondrop = (e) => {
            const r = this.canvas.getBoundingClientRect();
            this.createNode(
                e.dataTransfer.getData('type'), 
                e.clientX - r.left - 50, 
                e.clientY - r.top - 20
            );
        };
    },

    openEditor(node) {
        // Backward compatibility and safety defaults
node.text = node.text || node.code || node.label || "";
node.prompt = node.prompt || node.text || "";

        if (node.type === 'start' || node.type === 'end') return;

    this.editingNode = node;
    const body = document.getElementById('edit-modal-body');

    if (node.type === 'output') {
        body.innerHTML = `
            <label class="small fw-bold mb-1">Output value (inside print)</label>
            <div class="input-group">
                <span class="input-group-text">print(</span>
                <input id="edit-output-text" class="form-control" value="${escHTML(node.text)}">
                <span class="input-group-text">)</span>
            </div>
        `;
    }
    else if (node.type === 'decision') {
        body.innerHTML = `
            <label class="small fw-bold mb-1">Decision condition</label>
            <div class="input-group">
                <span class="input-group-text">if</span>
                <input id="edit-decision-text" class="form-control" value="${escHTML(node.text)}">
                <span class="input-group-text">:</span>
            </div>
            <div class="form-text">Examples: x &lt; 10, total == 0, name != ""</div>
        `;
    }
    else if (node.type === 'input') {
        body.innerHTML = `
            <label class="small fw-bold">Variable name</label>
            <input id="edit-input-var" class="form-control mb-2" value="${escHTML(node.varName) || escHTML(node.var) || ""}">

            <label class="small fw-bold">Prompt text</label>
            <input id="edit-input-prompt" class="form-control mb-2" value="${escHTML(node.prompt) || escHTML(node.text) || ""}">

            <label class="small fw-bold">Input type</label>
            <select id="edit-input-dtype" class="form-select">
                <option value="int" ${node.dtype === 'int' ? 'selected' : ''}>Integer Number</option>
                <option value="str" ${node.dtype === 'str' ? 'selected' : ''}>String</option>
            </select>

            <div class="mt-2 small text-muted">
                Preview:
                <code id="input-preview"></code>
            </div>
        `;

        setTimeout(() => {
            const updatePreview = () => {
                const v = document.getElementById("edit-input-var").value || "x";
                const p = document.getElementById("edit-input-prompt").value || "";
                const t = document.getElementById("edit-input-dtype").value;

                document.getElementById("input-preview").innerText =
                    t === "int"
                        ? `${v} = int(input(${p}))`
                        : `${v} = input(${p})`;
            };

            document.getElementById("edit-input-var").oninput = updatePreview;
            document.getElementById("edit-input-prompt").oninput = updatePreview;
            document.getElementById("edit-input-dtype").onchange = updatePreview;

            updatePreview();
        }, 0);
    }
    else if (node.type === 'var') {

        // Split existing text like:   total = total + 1
        let varName = "x";
        let varValue = "";

        if (node.text && node.text.includes("=")) {
            const parts = escHTML(node.text).split("=");
            varName = parts[0].trim();
            varValue = parts.slice(1).join("=").trim();
        }

        body.innerHTML = `
            <label class="small fw-bold">Variable name</label>
            <input id="edit-var-name" class="form-control mb-2" value="${varName}">

            <label class="small fw-bold">Value or expression</label>
            <input id="edit-var-value" class="form-control mb-2" value="${varValue}">

            <div class="mt-2 small text-muted">
                Preview:
                <code id="var-preview"></code>
            </div>
        `;

        setTimeout(() => {
            const updatePreview = () => {
                const n = document.getElementById("edit-var-name").value || "x";
                const v = document.getElementById("edit-var-value").value || "0";
                document.getElementById("var-preview").innerText = `${n} = ${v}`;
            };

            document.getElementById("edit-var-name").oninput = updatePreview;
            document.getElementById("edit-var-value").oninput = updatePreview;

            updatePreview();
        }, 0);
    }

    else if (node.type === 'list') {

// defaults
let listName = "myList";
let values = [];

if (node.text && node.text.includes("=")) {
    const parts = node.text.split("=");
    listName = parts[0].trim();

    // parse array literal
    try {
        values = JSON.parse(parts[1].trim().replace(/'/g,'"'));
    } catch {
        values = [];
    }
}

const length = values.length || 3;

// build initial element inputs
let elementsHtml = "";
for (let i = 0; i < length; i++) {
    elementsHtml += `
        <input class="form-control mb-1 list-element"
               value="${values[i] ?? ''}"
               placeholder="Element ${i}">
    `;
}

body.innerHTML = `
    <label class="small fw-bold">List name</label>
    <input id="edit-list-name" class="form-control mb-2" value="${listName}">

    <label class="small fw-bold">List length</label>
    <input id="edit-list-length" type="number"
           min="0" class="form-control mb-2" value="${length}">

    <label class="small fw-bold">Elements</label>
    <div id="list-elements-box">${elementsHtml}</div>

    <div class="mt-2 small text-muted">
        Preview:
        <code id="list-preview"></code>
    </div>
`;

// dynamic behaviour
setTimeout(() => {

    const listBox = document.getElementById("list-elements-box");

    const rebuild = () => {
        const len = parseInt(document.getElementById("edit-list-length").value) || 0;

        listBox.innerHTML = "";
        for (let i = 0; i < len; i++) {
            listBox.innerHTML += `
                <input class="form-control mb-1 list-element"
                       placeholder="Element ${i}">
            `;
        }
        updatePreview();
    };

    const updatePreview = () => {
        const name = document.getElementById("edit-list-name").value || "myList";
        const elems = [...document.querySelectorAll(".list-element")].map(e => e.value);

        const quoted = elems.map(v =>
            isNaN(v) || v === "" ? `"${v}"` : v
        );

        document.getElementById("list-preview").innerText =
            `${name} = [${quoted.join(", ")}]`;
    };

    document.getElementById("edit-list-length").oninput = rebuild;
    document.getElementById("edit-list-name").oninput = updatePreview;
    listBox.oninput = updatePreview;

    updatePreview();
}, 0);
}

    else {
        body.innerHTML = `
            <label class="small fw-bold">Code Text</label>
            <input id="edit-generic-text" class="form-control" value="${node.text ?? ""}">
        `;
    }

    new bootstrap.Modal(document.getElementById('editModal')).show();
}
,
saveNodeEdit() {
    const n = this.editingNode;

    if (n.type === 'output') {
        n.text = document.getElementById('edit-output-text').value;
    }
    else if (n.type === 'decision') {
        n.text = document.getElementById('edit-decision-text').value;
    }
    else if (n.type === 'input') {
        n.varName = document.getElementById('edit-input-var').value;
        n.prompt  = document.getElementById('edit-input-prompt').value;
        n.dtype   = document.getElementById('edit-input-dtype').value;
    }
    else if (n.type === 'var') {
        const name  = document.getElementById('edit-var-name').value || "x";
        const value = document.getElementById('edit-var-value').value || "0";
        n.text = `${name} = ${value}`;
    }
    else if (n.type === 'list') {

const name = document.getElementById("edit-list-name").value || "myList";

const elems = [...document.querySelectorAll(".list-element")].map(e => e.value);

const formatted = elems.map(v =>
    isNaN(v) || v === "" ? `"${v}"` : v
);

n.text = `${name} = [${formatted.join(", ")}]`;
}

    else {
        n.text = document.getElementById('edit-generic-text').value;
    }

    bootstrap.Modal.getInstance(document.getElementById('editModal')).hide();

    document.getElementById(n.id).remove();
    this.renderNode(n);
    this.drawConns();
    this.updateCode();
}
,
    addDot(parent, cls, portType) {
        const d = document.createElement('div'); 
        d.className = `dot ${cls}`;
        d.onpointerdown = (e) => { 
    e.stopPropagation(); 

    this.isConnecting = true; 
    this.connStart = { nodeId: parent.id, portType }; 

    const start = this.getPortPos(parent.id, portType);

    // show drag preview line immediately
    this.dragLine.style.display = "block";
    this.dragLine.setAttribute(
        "d",
        `M ${start.x} ${start.y} L ${start.x} ${start.y}`
    );
};

        parent.appendChild(d);
    },

    saveDiagram() {
        const diagram = {
            nodes: this.nodes,
            connections: this.connections,
            version: "3.3"
        };
        
        const json = JSON.stringify(diagram, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'flowchart.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    },

    loadDiagram() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const diagram = JSON.parse(event.target.result);
                    
                    // Validate the diagram structure
                    if (!diagram.nodes || !Array.isArray(diagram.nodes)) {
                        alert('Invalid diagram file: missing nodes array');
                        return;
                    }
                    if (!diagram.connections || !Array.isArray(diagram.connections)) {
                        alert('Invalid diagram file: missing connections array');
                        return;
                    }
                    
                    // Clear current canvas
                    this.nodes = [];
                    this.connections = [];
                    this.selectedNodeId = null;
                    document.getElementById('nodes-layer').innerHTML = "";
                    document.getElementById('code-python').innerText = "";
                    document.getElementById('console').innerHTML = "";
                    
                    // Restore nodes
                    this.nextId = 1;
                    diagram.nodes.forEach(node => {
                        // Update nextId to avoid ID conflicts
                        const nodeNum = parseInt(node.id.replace('n', '')) || 0;
                        if (nodeNum >= this.nextId) {
                            this.nextId = nodeNum + 1;
                        }
                        this.nodes.push(node);
                        this.renderNode(node);
                    });
                    
                    // Restore connections
                    this.connections = diagram.connections;
                    
                    // Redraw everything
                    this.drawConns();
                    
                    // Update code with error handling
                    try {
                        this.updateCode();
                    } catch (compileError) {
                        console.error('Compilation error after load:', compileError);
                        document.getElementById('code-python').innerText = `# Error compiling loaded diagram: ${compileError.message}`;
                    }
                } catch (error) {
                    alert('Error loading diagram: ' + error.message);
                    console.error('Load error:', error);
                    console.error('Stack:', error.stack);
                }
            };
            reader.readAsText(file);
        };
        input.click();
    },

    clearCanvas() { 
        if(confirm("Clear all?")) { 
            this.nodes=[]; 
            this.connections=[]; 
            this.selectedNodeId=null; 
            document.getElementById('nodes-layer').innerHTML=""; 
            document.getElementById('code-python').innerText=""; 
            document.getElementById('console').innerHTML=""; 
            this.drawConns(); 
            this.updateCode(); 
        } 
    }
};
// === Draggable challenge banner ===
// === Global Draggable Challenge Banner ===
(function () {
    const banner = document.getElementById("active-challenge-banner");
    if (!banner) return;

    let isDragging = false;
    let offsetX = 0;
    let offsetY = 0;

    banner.addEventListener("mousedown", (e) => {
        // Prevent dragging when clicking the hide button or the code block
        if (e.target.id === "dismiss-challenge" || e.target.id === "active-challenge-code") return;

        isDragging = true;
        
        // Get current position
        const rect = banner.getBoundingClientRect();
        
        // Calculate where the mouse is relative to the top-left of the banner
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;

        // When starting a drag, remove the CSS "left: 50% + transform" centering
        // and replace it with fixed pixel coordinates
        banner.style.left = rect.left + "px";
        banner.style.top = rect.top + "px";
        banner.style.transform = "none"; 
        banner.style.margin = "0";

        document.body.style.userSelect = "none";
    });

    document.addEventListener("mousemove", (e) => {
        if (!isDragging) return;

        // Calculate new X and Y
        let x = e.clientX - offsetX;
        let y = e.clientY - offsetY;

        // Keep the banner inside the browser window edges
        const maxX = window.innerWidth - banner.offsetWidth - 10;
        const maxY = window.innerHeight - banner.offsetHeight - 10;

        x = Math.max(10, Math.min(x, maxX));
        y = Math.max(10, Math.min(y, maxY));

        banner.style.left = x + "px";
        banner.style.top = y + "px";
    });

    document.addEventListener("mouseup", () => {
        isDragging = false;
        document.body.style.userSelect = "";
    });
})();

function escHTML(s) {
    if (!s && s !== 0) return "";
    return String(s)
        .replace(/&/g, "&amp;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
}
document.addEventListener("DOMContentLoaded", () => {



});
// Initialize the application
App.init();

</script>
</body>
</html>
