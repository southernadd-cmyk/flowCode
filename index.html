<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowCode v3.2</title>

    <!-- LIBS -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/skulpt@1.2.0/dist/skulpt-stdlib.js"></script>

    <style>
        :root { --bg-canvas: #f8f9fa; --node-bg: #ffffff; --node-border: #212529; --accent: #0d6efd; --console-bg: #1e1e1e; }
        body { font-family: 'Inter', sans-serif; height: 100vh; overflow: hidden; background-color: #fff; margin: 0; }
        .wrapper { height: calc(100vh - 56px); display: flex; flex-direction: column; }
        .main-area { flex: 1; display: flex; overflow: hidden; }

        #palette { width: 230px; background: #fff; border-right: 1px solid #dee2e6; padding: 15px; overflow-y: auto; z-index: 10; box-shadow: 2px 0 10px rgba(0,0,0,0.05); }
        .palette-header { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; color: #adb5bd; font-weight: 800; margin-top: 15px; margin-bottom: 8px; }
        .palette-item { cursor: grab; user-select: none; margin-bottom: 8px; padding: 10px; border: 2px solid #dee2e6; border-radius: 8px; background: white; display: flex; align-items: center; gap: 10px; font-size: 0.85rem; font-weight: 600; transition: 0.2s; }
        .palette-item:hover { border-color: var(--accent); color: var(--accent); transform: translateY(-2px); }

        #canvas { flex: 1; background-color: var(--bg-canvas); position: relative; overflow: hidden; background-image: radial-gradient(#ced4da 1px, transparent 1px); background-size: 20px 20px; }
        svg#connections-layer { position: absolute; inset: 0; pointer-events: none; z-index: 1; width: 100%; height: 100%; }

        #output-panel { width: 450px; display: flex; flex-direction: column; border-left: 1px solid #dee2e6; background: #fff; }
        .code-display { flex: 1; padding: 20px; font-family: 'JetBrains Mono', monospace; font-size: 13px; color: #1e293b; overflow-y: auto; line-height: 1.6; white-space: pre; background: #fafafa; border-bottom: 1px solid #dee2e6; }
        #console { height: 220px; background: var(--console-bg); color: #fff; padding: 12px; font-family: 'JetBrains Mono', monospace; font-size: 13px; overflow-y: auto; border-top: 4px solid #343a40; }

        .node { position: absolute; background: var(--node-bg); border: 2px solid var(--node-border); text-align: center; font-size: 11px; font-weight: 700; user-select: none; cursor: pointer; z-index: 2; display: flex; align-items: center; justify-content: center; padding: 5px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); }
        .node.selected { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.25); }
        .node.running { background-color: #dcfce7 !important; border-color: #16a34a !important; transform: scale(1.05); transition: 0.2s; box-shadow: 0 0 15px rgba(22, 163, 74, 0.4); }
        
        .shape-start, .shape-end { 
            width: 90px; 
            height: 35px; 
            border-radius: 20px; 
        }   
        .shape-process, .shape-var { width: 110px; height: 45px; border-radius: 4px; }

        .shape-output, .shape-input { width: 120px; height: 45px; transform: skew(-15deg); border-radius: 2px; }
        .shape-output .inner-text, .shape-input .inner-text { transform: skew(15deg); width: 100%; }

        .dot { width: 10px; height: 10px; background: #fff; border: 2px solid #495057; border-radius: 50%; position: absolute; z-index: 5; cursor: crosshair; }
        .dot.in { top: -6px; left: 50%; transform: translateX(-50%); }
        .dot.out { bottom: -6px; left: 50%; transform: translateX(-50%); }

        .conn-label { position: absolute; font-size: 10px; font-weight: 800; background: white; padding: 1px 5px; border: 1px solid #cbd5e1; border-radius: 4px; z-index: 3; pointer-events: none; }

        /* New Diamond Shape Styling */
        .shape-decision { 
            width: 120px; 
            height: 100px; 
            background: transparent !important; 
            border: none !important; 
            box-shadow: none !important; 
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .decision-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            fill: #ffffff;
            stroke: #212529;
            stroke-width: 2px;
            z-index: -1;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.1));
        }

        /* Highlighting the SVG path during execution */
        .node.running .decision-svg {
            fill: #dcfce7 !important;
            stroke: #16a34a !important;
            stroke-width: 3px;
        }

        .node.selected .decision-svg {
            stroke: var(--accent);
            stroke-width: 3px;
        }

        .shape-decision .inner-text { 
            transform: none; 
            width: 70%; /* Keep text inside the diamond area */
            font-size: 11px;
            font-weight: 700;
            z-index: 2;
        }

        /* Specific Dot Placements for Diamond Points */
        .shape-decision .dot.in { 
            top: -5px; 
            left: 50%; 
            transform: translateX(-50%); 
        } 
        /* NO is usually the right side, YES usually the bottom */
        .shape-decision .dot.out-yes { 
            bottom: -5px; 
            left: 50%; 
            transform: translateX(-50%);
            background: #16a34a; 
        } 
        .shape-decision .dot.out-no { 
            top: 50%; 
            right: -5px; 
            transform: translateY(-50%);
            background: #dc2626; 
        }
        
        #nodes-layer, #connections-layer {
            transform-origin: 0 0;
        }

        /* LIST BLOCK STYLE */
        .shape-list {
            width: 130px;
            height: 45px;
            border-radius: 6px;
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
        }

        /* Optional visual identity (subtle blue accent stripe) */
        .shape-list::before {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: rgba(13, 110, 253, 0.35);
            border-top-left-radius: 4px;
            border-bottom-left-radius: 4px;
        }

        /* highlight and selection reuse your existing behaviour */
        .shape-list .inner-text {
            width: 100%;
            transform: none;
            font-weight: 700;
            font-size: 11px;
        }

        /* Running state inherits from .node.running automatically */
    </style>
</head>
<body>

<nav class="navbar navbar-dark bg-dark">
    <div class="container-fluid">
        <span class="navbar-brand fw-bold"><i class="fa-solid fa-code-branch me-2"></i>FlowCode<small class="text-muted">v3.2</small></span>
        <div class="d-flex gap-2">
            <!-- RUN button (shown when idle) -->
            <button id="run-btn"
                class="btn btn-success btn-sm px-4 fw-bold"
                onclick="App.runSim()">
                <i class="fa-solid fa-play me-1"></i> RUN
            </button>

            <!-- STOP button (hidden until running) -->
            <button id="stop-btn"
                class="btn btn-danger btn-sm px-4 fw-bold"
                style="display:none"
                onclick="App.stopSim()">
                <i class="fa-solid fa-stop me-1"></i> STOP
            </button>

            <button class="btn btn-primary btn-sm px-3 fw-bold" onclick="App.saveDiagram()"><i class="fa-solid fa-download me-1"></i> Save</button>
            <button class="btn btn-info btn-sm px-3 fw-bold" onclick="App.loadDiagram()"><i class="fa-solid fa-upload me-1"></i> Load</button>
            <div class="btn-group">
                <button class="btn btn-secondary btn-sm dropdown-toggle fw-bold" data-bs-toggle="dropdown">
                    Examples
                </button>
            
                <ul class="dropdown-menu">
                    <li><a class="dropdown-item" onclick="App.loadExampleFromFile('maxOfThree.json')">Max of Three</a></li>
                    <li><a class="dropdown-item" onclick="App.loadExampleFromFile('2loops.json')">Two Loops</a></li>
                    <li><a class="dropdown-item" onclick="App.loadExampleFromFile('whileloop.json')">While Loop</a></li>
                    <li><a class="dropdown-item" onclick="App.loadExampleFromFile('forloop.json')">For Loop</a></li>
                    <li><a class="dropdown-item" onclick="App.loadExampleFromFile('WhileTrue.json')">While True Loop</a></li>
                    <li><a class="dropdown-item" onclick="App.loadExampleFromFile('spaghettiLoop.json')">Spaghetti Loop</a></li>
                </ul>
            </div>
            
            <button class="btn btn-outline-light btn-sm" onclick="App.clearCanvas()">Clear All</button>
        </div>
    </div>
</nav>

<div class="wrapper">
    <div class="main-area">
        <div id="palette">
            <div class="palette-header">Flow</div>
            <div class="palette-item" draggable="true" data-type="start">Start</div>
            <div class="palette-item" draggable="true" data-type="end">End</div>

            <div class="palette-item" draggable="true" data-type="decision">Decision</div>
            
            <div class="palette-header">Logic</div>
            <div class="palette-item" draggable="true" data-type="var">Variable</div>
            <div class="palette-item" draggable="true" data-type="list">List</div>
            <div class="palette-item" draggable="true" data-type="process">Process</div>
            
            <div class="palette-header">I/O</div>
            <div class="palette-item" draggable="true" data-type="input">Input</div>
            <div class="palette-item" draggable="true" data-type="output">Print</div>

            <div class="palette-header">Functions</div>
            <div class="palette-item" draggable="true" data-type="function_def">Function Def</div>
            <div class="palette-item" draggable="true" data-type="function_call">Function Call</div>
            <div class="palette-item" draggable="true" data-type="return">Return</div>

            <div class="palette-header">Speed</div>
            <input type="range" class="form-range" id="speed-slider" min="100" max="2000" value="1600">
        </div>
        
        <div id="canvas">
            <svg id="connections-layer">
                <defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#555" /></marker></defs>
                <path id="drag-line" stroke="#0d6efd" stroke-width="2" stroke-dasharray="4,4" fill="none" style="display:none;"></path>
            </svg>
            <div id="nodes-layer"></div>
            <div id="zoom-controls" style="position:absolute; right:10px; bottom:10px; z-index:20;">
                <button onclick="App.zoomIn()" class="btn btn-sm btn-light">+</button>
                <button onclick="App.zoomOut()" class="btn btn-sm btn-light">−</button>
                <button onclick="App.resetView()" class="btn btn-sm btn-light">Reset</button>
            </div>
        </div>
        
        <div id="output-panel">
            <div class="code-display" id="code-python"></div>
            <div id="console"></div>
            <div id="varwatch" style="height:160px; overflow-y:auto; font-family:'JetBrains Mono', monospace; font-size:13px; padding:10px; border-top:1px solid #333; background:#111; color:#0f0">
                <strong>Variable Watch</strong>
                <div id="varwatch-table"></div>
            </div>
        </div>
    </div>
</div>

<!-- INPUT MODAL -->
<div class="modal fade" id="inputModal" tabindex="-1" data-bs-backdrop="static"><div class="modal-dialog modal-dialog-centered"><div class="modal-content"><div class="modal-body p-4"><h6 id="modal-prompt" class="fw-bold mb-3">Input:</h6><input type="text" id="modal-field" class="form-control mb-3"><button class="btn btn-primary w-100 fw-bold" id="modal-submit">Continue</button></div></div></div></div>

<div class="modal fade" id="editModal" tabindex="-1"><div class="modal-dialog modal-dialog-centered"><div class="modal-content"><div class="modal-header py-2 bg-light"><h6 class="modal-title fw-bold">Edit Node</h6></div><div class="modal-body" id="edit-modal-body"></div><div class="modal-footer py-2 bg-light"><button class="btn btn-primary btn-sm px-4 fw-bold" id="save-node-btn">Save Changes</button></div></div></div></div>

<!-- WELCOME / INSTRUCTIONS MODAL -->
<div class="modal fade" id="welcomeModal" tabindex="-1" data-bs-backdrop="static">
    <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content">

        <div class="modal-header bg-dark text-white py-2">
        <h5 class="modal-title fw-bold">Welcome to FlowCode Pro</h5>
        </div>

        <div class="modal-body">
        <p><strong>FlowCode Pro</strong> lets you build <em>flowcharts that actually run</em> and automatically generate Python code.</p>

        <h6 class="fw-bold mt-3">How to use</h6>
        <ol>
            <li>Drag blocks from the palette onto the canvas</li>
            <li>Connect them using the small circles (ports)</li>
            <li>Double-click a block to edit text / conditions / variables</li>
            <li>Click <strong>RUN</strong> to execute the flowchart step-by-step</li>
            <li>See the generated Python on the right</li>
        </ol>

        <h6 class="fw-bold mt-3">Supported features</h6>
        <ul>
            <li>Input / Output</li>
            <li>Variables and processes</li>
            <li>If / Elif / Else</li>
            <li>While and For loops (auto-detected)</li>
            <li>Functions (def / call / return)</li>
        </ul>

        <h6 class="fw-bold mt-3">Tips</h6>
        <ul>
            <li>Green arrows = YES paths</li>
            <li>Red arrows = NO paths</li>
            <li>Start block is required</li>
            <li>Save → JSON you can reload later</li>
        </ul>

        <div class="form-check mt-3">
            <input class="form-check-input" type="checkbox" id="dontShowAgainCheck">
            <label class="form-check-label" for="dontShowAgainCheck">
            Don’t show this again
            </label>
        </div>
        </div>

        <div class="modal-footer bg-light py-2">
        <button class="btn btn-primary fw-bold" id="welcomeCloseBtn">Get Started</button>
        </div>

    </div>
    </div>
</div>

<script>
    // Show welcome modal on first visit
    document.addEventListener("DOMContentLoaded", function () {
        if (localStorage.getItem("hideWelcomeModal") === "true") return;
        const welcomeModal = new bootstrap.Modal(document.getElementById('welcomeModal'));
        welcomeModal.show();
        document.getElementById("welcomeCloseBtn").onclick = function () {
            if (document.getElementById("dontShowAgainCheck").checked) {
                localStorage.setItem("hideWelcomeModal", "true");
            }
            welcomeModal.hide();
        };
    });

/**
 * ENHANCED FLOWCHART COMPILER
 * Handles nested loops, if/else, for/while loops, complex structures
 * NOW WITH FUNCTION SUPPORT
 */
class FlowchartCompiler {
    constructor(nodes, connections, useHighlighting = false) {
        this.nodes = nodes;
        this.connections = connections;
        this.useHighlighting = useHighlighting;
        
        this.outgoingMap = new Map();
        this.incomingMap = new Map();
        this.loopHeaderCache = new Map();
        this.loweredImplicitLoops = new Set();
        this.buildMaps();
    }
    
    getImplicitLoopBodyNodes(headerId) {

const bodyNodes = new Set();
const visited = new Set();

const headerNext = this.getSuccessor(headerId, 'next');

const dfs = (nodeId) => {
    if (!nodeId) return;
    if (visited.has(nodeId)) return;

    visited.add(nodeId);
    bodyNodes.add(nodeId);

    const succs = this.getAllSuccessors(nodeId);

    for (const {nodeId: nextId} of succs) {

        // stop if we reach header again (back-edge)
        if (nextId === headerId) continue;

        dfs(nextId);
    }
};

dfs(headerNext);
return bodyNodes;
}
getImplicitLoopExitEdges(headerId) {

const body = this.getImplicitLoopBodyNodes(headerId);
const exits = [];

for (const nid of body) {

    const succs = this.getAllSuccessors(nid);

    for (const {nodeId: nextId} of succs) {
        if (!nextId) continue;

        // ignore back edge
        if (nextId === headerId) continue;

        // edge leaves loop body
        if (!body.has(nextId)) {
            exits.push({
                from: nid,
                to: nextId
            });
        }
    }
}
return exits;
}


    buildMaps() {
        this.outgoingMap.clear();
        this.incomingMap.clear();
        if (this.loopHeaderCache) this.loopHeaderCache.clear();
        
        this.nodes.forEach(node => {
            this.outgoingMap.set(node.id, []);
            this.incomingMap.set(node.id, []);
        });
        
        this.connections.forEach(conn => {
            const outgoing = this.outgoingMap.get(conn.from) || [];
            outgoing.push({...conn, targetId: conn.to});
            this.outgoingMap.set(conn.from, outgoing);
            
            const incoming = this.incomingMap.get(conn.to) || [];
            incoming.push({...conn, sourceId: conn.from});
            this.incomingMap.set(conn.to, incoming);
        });
    }
    findBackEdges() {
    const backEdges = [];
    const visited = new Set();
    const stack = new Set();

    const dfs = (nodeId) => {
        if (!nodeId) return;
        if (visited.has(nodeId)) return;

        visited.add(nodeId);
        stack.add(nodeId);

        const succs = this.getAllSuccessors(nodeId);

        for (const {nodeId: nextId} of succs) {
            if (!nextId) continue;

            // back-edge found
            if (stack.has(nextId)) {
                backEdges.push({ from: nodeId, to: nextId });
            } else {
                dfs(nextId);
            }
        }

        stack.delete(nodeId);
    };

    const start = this.nodes.find(n => n.type === "start");
    if (start) dfs(start.id);

    return backEdges;
}

    getSuccessor(nodeId, port = 'next') {
        const outgoing = this.outgoingMap.get(nodeId) || [];
        const conn = outgoing.find(c => c.port === port);
        return conn ? conn.targetId : null;
    }

    getAllSuccessors(nodeId) {
        const outgoing = this.outgoingMap.get(nodeId) || [];
        return outgoing.map(c => ({port: c.port, nodeId: c.targetId}));
    }

    compile() {
        const startNode = this.nodes.find(n => n.type === 'start');
        if (!startNode) return "# Add a Start node.";
        this.buildMaps();
         // ---------- detect implicit loop headers ----------
    this.implicitLoopHeaders = new Set();

const backEdges = this.findBackEdges();
backEdges.forEach(edge => {
    const target = this.nodes.find(n => n.id === edge.to);

    // ignore decision-controlled loops (you already handle them)
    if (target && target.type !== 'decision') {
        this.implicitLoopHeaders.add(edge.to);
    }
});

// ---------------------------------------------------
        return this.compileNode(startNode.id, new Set(), [], 0);
    }

    compileImplicitForeverLoop(nodeId, visitedInPath, contextStack, indentLevel) {

const indent = "    ".repeat(indentLevel);
let code = "";

// emit loop header
code += `${indent}while True:\n`;

// highlighting
if (this.useHighlighting) {
    code += `${indent}    highlight('${nodeId}')\n`;
}

// --------------------------------------------
// IMPORTANT: compile header node INSIDE loop
// --------------------------------------------

// prevent re-enter lowering for this header
const saved = new Set(this.implicitLoopHeaders);
this.implicitLoopHeaders.delete(nodeId);

// fresh visited for loop body so it emits once
const bodyVisited = new Set();

// 1) compile the header node’s own statement
const headerCode =
    this.compileNode(
        nodeId,
        bodyVisited,
        [...contextStack, `implicit_${nodeId}`],
        indentLevel + 1
    );

// 2) compile from its successor onward
const nextId = this.getSuccessor(nodeId, "next");

const restCode =
    this.compileNode(
        nextId,
        bodyVisited,
        [...contextStack, `implicit_${nodeId}`],
        indentLevel + 1
    );

// restore set
this.implicitLoopHeaders = saved;

const body = (headerCode + restCode).trim()
    ? headerCode + restCode
    : `${indent}    pass\n`;

code += body;

return code;
}

    compileNode(nodeId, visitedInPath, contextStack, indentLevel, inLoopHeader = false) {
        // stop on implicit-loop back edges
// prevent infinite recursion on back-edges inside implicit loops
// only suppress SECOND visit to the implicit loop header
if (inLoopHeader && visitedInPath.has(nodeId)) {
    return "";
}



        if (!nodeId || nodeId === 'end') return "";
        
        const node = this.nodes.find(n => n.id === nodeId);
        if (!node) return "";
        


// IMPLICIT LOOP COMPILATION (with lowering guard)
if (this.implicitLoopHeaders && this.implicitLoopHeaders.has(nodeId)) {

// if we already lowered this loop -> do NOT lower again
if (this.loweredImplicitLoops.has(nodeId)) {
    // just continue normally from successor to avoid recursion
    const nextNodeId = this.getSuccessor(nodeId, 'next');
    return this.compileNode(nextNodeId, visitedInPath, contextStack, indentLevel);
}

// mark loop as lowered now
this.loweredImplicitLoops.add(nodeId);

return this.compileImplicitForeverLoop(
    nodeId,
    visitedInPath,
    contextStack,
    indentLevel
);
}


        
        const contextId = `${nodeId}_${contextStack.join('_')}_${indentLevel}`;
        if (visitedInPath.has(contextId)) return "";
        visitedInPath.add(contextId);
        
        const indent = "    ".repeat(indentLevel);
        let code = "";
        
        if (this.useHighlighting) {
            code += `${indent}highlight('${node.id}')\n`;
        }
        
        switch (node.type) {
            case 'function_def':
                return this.compileFunction(node, visitedInPath, contextStack, indentLevel);

            case 'function_call':
                if (node.text) code += `${indent}${node.text}\n`;
                break;

            case 'return':
                if (node.text) code += `${indent}${node.text}\n`;
                break;

            case 'decision':
                return this.compileDecision(node, visitedInPath, contextStack, indentLevel);
                
            case 'start':
                break;

            case 'end':
                code += `${indent}raise SystemExit\n`;
                break;    

            case 'output':
                code += `${indent}print(${node.text})\n`;
                break;
                
            case 'input':
                {
                    const wrap = node.dtype === 'int' ? 'int(input(' : 'input(';
                    code += `${indent}${node.varName} = ${wrap}"${node.prompt}")\n`;
                    if (node.dtype === 'int') code = code.trimEnd() + ")\n";
                }
                break;
                
            default:
                if (node.text) code += `${indent}${node.text}\n`;
                break;
        }
        // after compiling the header once,
// mark so that a second visit (back-edge) stops
if (inLoopHeader) {
    visitedInPath.add(nodeId);
}

        const nextNodeId = this.getSuccessor(nodeId, 'next');
        
        if (contextStack.length > 0) {
            for (const ctx of contextStack) {
                if (ctx.startsWith('loop_')) {
                    const loopHeaderId = ctx.replace('loop_', '');
                    if (nextNodeId === loopHeaderId) {
                        return code;
                    }
                }
            }
        }
        
        if (nextNodeId) {
            const nextNode = this.nodes.find(n => n.id === nextNodeId);
            if (nextNode && nextNode.type === 'decision') {
                const isAlreadyInStack = contextStack.some(ctx => ctx === `loop_${nextNodeId}`);
                if (isAlreadyInStack) return code;
            }
            const nextContextId = `${nextNodeId}_${contextStack.join('_')}_${indentLevel}`;
            if (visitedInPath.has(nextContextId)) return code;
        }
        
        code += this.compileNode(nextNodeId, visitedInPath, contextStack, indentLevel);
        return code;
    }

    /* ---- decision / loop logic (unchanged from your version) ---- */

    compileDecision(node, visitedInPath, contextStack, indentLevel) {
        const yesId = this.getSuccessor(node.id, 'yes');
        const noId  = this.getSuccessor(node.id, 'no');

        const isAlreadyLoop = contextStack.some(ctx => ctx === `loop_${node.id}`);
        if (isAlreadyLoop) {
            return this.compileIfElse(node, yesId, noId, visitedInPath, contextStack, indentLevel);
        }

        const isLoopYes = this.isLoopHeader(node.id, yesId);
        const isLoopNo  = noId ? this.isLoopHeader(node.id, noId) : false;
        const isLoop    = isLoopYes || isLoopNo;

        if (isLoop) {
            const loopBodyId  = isLoopYes ? yesId : noId;
            const exitId      = isLoopYes ? noId  : yesId;
            const useNoBranch = !isLoopYes && isLoopNo;

            return this.compileLoop(
                node,
                loopBodyId,
                exitId,
                visitedInPath,
                contextStack,
                indentLevel,
                useNoBranch
            );
        } else {
            return this.compileIfElse(node, yesId, noId, visitedInPath, contextStack, indentLevel);
        }
    }

    isLoopHeader(nodeId, branchId) {
        if (!branchId) return false;
        const MAX_DEPTH = 200;
        const visited = new Set();

        const dfs = (id, depth = 0) => {
            if (!id) return false;
            if (depth > MAX_DEPTH) return false;
            if (id === nodeId) return true;
            if (visited.has(id)) return false;
            visited.add(id);

            const outgoing = this.outgoingMap.get(id) || [];
            for (const edge of outgoing) {
                if (dfs(edge.targetId, depth + 1)) return true;
            }
            return false;
        };

        return dfs(branchId, 0);
    }

    compileLoop(node, loopBodyId, exitId, visitedInPath, contextStack, indentLevel, useNoBranch = false) {
        const indent = "    ".repeat(indentLevel);
        let code = "";

        const forLoopInfo = !useNoBranch ? this.detectForLoopPattern(node.id) : null;
        
        if (forLoopInfo) {
            let rangeStr = `range(${forLoopInfo.start}, ${forLoopInfo.end}`;
            if (forLoopInfo.step && Math.abs(forLoopInfo.step) !== 1) {
                rangeStr += `, ${forLoopInfo.step}`;
            }
            rangeStr += ')';
            
            code += `${indent}for ${forLoopInfo.variable} in ${rangeStr}:\n`;
            if (this.useHighlighting) {
                code += `${indent}    highlight('${node.id}')\n`;
            }
            
            const forBodyContext = [...contextStack, `loop_${node.id}`];
            const forVisited = new Set();
            code += this.compileNode(loopBodyId, forVisited, forBodyContext, indentLevel + 1)
                 || `${indent}    pass\n`;

            if (exitId) {
                code += this.compileNode(exitId, visitedInPath, contextStack, indentLevel);
            }
            return code;
        } else {
            let condition = node.text;
            if (useNoBranch) {
                condition = `not (${node.text})`;
            }
            
            code += `${indent}while ${condition}:\n`;
            if (this.useHighlighting) {
                code += `${indent}    highlight('${node.id}')\n`;
            }
            const whileBodyContext = [...contextStack, `loop_${node.id}`];
            const whileVisited = new Set();
            code += this.compileNode(loopBodyId, whileVisited, whileBodyContext, indentLevel + 1)
                 || `${indent}    pass\n`;

            if (exitId) {
                code += this.compileNode(exitId, visitedInPath, contextStack, indentLevel);
            }
            return code;
        }
    }

    detectForLoopPattern(decisionId) {
        const incoming = this.incomingMap.get(decisionId) || [];
        let initNode = null;
        let varName = null;
        let startValue = null;
        
        for (const conn of incoming) {
            const node = this.nodes.find(n => n.id === conn.sourceId);
            if (node && (node.type === 'var' || node.type === 'process')) {
                const match = node.text.match(/^\s*(\w+)\s*=\s*(\d+)\s*$/);
                if (match) {
                    initNode = node;
                    varName = match[1];
                    startValue = match[2];
                    break;
                }
            }
        }
        
        if (!varName) return null;
        
        const decisionNode = this.nodes.find(n => n.id === decisionId);
        const condition = decisionNode.text;
        
        let endValue = null;
        let comparisonOp = null;
        const patterns = [
            { regex: new RegExp(`${varName}\\s*<\\s*(\\d+)`), op: '<' },
            { regex: new RegExp(`${varName}\\s*<=\\s*(\\d+)`), op: '<=' },
            { regex: new RegExp(`${varName}\\s*>\\s*(\\d+)`), op: '>' },
            { regex: new RegExp(`${varName}\\s*>=\\s*(\\d+)`), op: '>=' }
        ];
        
        for (const pattern of patterns) {
            const match = condition.match(pattern.regex);
            if (match) {
                endValue = match[1];
                comparisonOp = pattern.op;
                break;
            }
        }
        
        if (!endValue) return null;
        
        const yesId = this.getSuccessor(decisionId, 'yes');
        const incrementInfo = this.findIncrementNodeBFS(yesId, decisionId, varName);
        
        if (incrementInfo) {
            let step = incrementInfo.step || 1;
            const isDecrement = incrementInfo.isDecrement || false;
            
            let finalStart = startValue;
            let finalEnd = endValue;
            let finalStep = step;
            
            if (comparisonOp === '>' || comparisonOp === '>=') {
                finalStart = startValue;
                if (comparisonOp === '>=') {
                    finalEnd = `${parseInt(endValue) - 1}`;
                } else {
                    finalEnd = endValue;
                }
                finalStep = -Math.abs(step);
            } else {
                finalStart = startValue;
                if (comparisonOp === '<=') {
                    finalEnd = `${parseInt(endValue) + 1}`;
                } else {
                    finalEnd = endValue;
                }
                finalStep = Math.abs(step);
            }
            
            return {
                variable: varName,
                start: finalStart,
                end: finalEnd,
                step: finalStep,
                incrementNodeId: incrementInfo.node.id
            };
        }
        
        return null;
    }

    findIncrementNodeBFS(startId, stopId, varName) {
        const queue = [{ nodeId: startId, visited: new Set() }];
        
        while (queue.length > 0) {
            const current = queue.shift();
            
            if (current.nodeId === stopId || current.visited.has(current.nodeId)) {
                continue;
            }
            
            current.visited.add(current.nodeId);
            
            const node = this.nodes.find(n => n.id === current.nodeId);
            if (node) {
                let incrementMatch = node.text.match(new RegExp(`^\\s*${varName}\\s*=\\s*${varName}\\s*([+-])\\s*(\\d+)\\s*$`));
                if (incrementMatch && (node.type === 'process' || node.type === 'var')) {
                    const op = incrementMatch[1];
                    const step = parseInt(incrementMatch[2]);
                    return {
                        node: node,
                        step: step,
                        isDecrement: op === '-'
                    };
                }
                
                incrementMatch = node.text.match(new RegExp(`^\\s*${varName}\\s*([+-])=\\s*(\\d+)\\s*$`));
                if (incrementMatch && (node.type === 'process' || node.type === 'var')) {
                    const op = incrementMatch[1];
                    const step = parseInt(incrementMatch[2]);
                    return {
                        node: node,
                        step: step,
                        isDecrement: op === '-'
                    };
                }
            }
            
            const nextId = this.getSuccessor(current.nodeId, 'next');
            if (nextId && !current.visited.has(nextId)) {
                queue.push({
                    nodeId: nextId,
                    visited: new Set([...current.visited])
                });
            }
            
            if (node && node.type === 'decision') {
                const yesId = this.getSuccessor(current.nodeId, 'yes');
                if (yesId && !current.visited.has(yesId)) {
                    queue.push({
                        nodeId: yesId,
                        visited: new Set([...current.visited])
                    });
                }
            }
        }
        
        return null;
    }

    compileIfElse(node, yesId, noId, visitedInPath, contextStack, indentLevel) {
        const indent = "    ".repeat(indentLevel);
        let code = `${indent}if ${node.text}:\n`;

        const ifContext = [...contextStack, `if_${node.id}`];
        const ifVisited = new Set(visitedInPath);
        const ifDecisionContextId = `${node.id}_${ifContext.join('_')}_${indentLevel + 1}`;
        ifVisited.add(ifDecisionContextId);

        const ifCode = this.compileNode(yesId, ifVisited, ifContext, indentLevel + 1);
        code += ifCode || `${indent}    pass\n`;

        if (noId) {
            const noNode = this.nodes.find(n => n.id === noId);

            if (noNode && noNode.type === 'decision') {
                const yesOfNo        = this.getSuccessor(noNode.id, 'yes');
                const noBranchIsLoop = this.isLoopHeader(noNode.id, yesOfNo);

                if (noBranchIsLoop) {
                    const elseContext = [...contextStack, `else_${node.id}`];
                    const elseVisited = new Set(visitedInPath);
                    const elseDecisionContextId = `${node.id}_${elseContext.join('_')}_${indentLevel + 1}`;
                    elseVisited.add(elseDecisionContextId);

                    code += `${indent}else:\n`;
                    const elseCode = this.compileNode(noId, elseVisited, elseContext, indentLevel + 1);
                    code += elseCode || `${indent}    pass\n`;
                } else {
                    code += this.compileElifChain(noNode, visitedInPath, contextStack, indentLevel);
                }
            } else {
                const elseContext = [...contextStack, `else_${node.id}`];
                const elseVisited = new Set(visitedInPath);
                const elseDecisionContextId = `${node.id}_${elseContext.join('_')}_${indentLevel + 1}`;
                elseVisited.add(elseDecisionContextId);

                code += `${indent}else:\n`;
                const elseCode = this.compileNode(noId, elseVisited, elseContext, indentLevel + 1);
                code += elseCode || `${indent}    pass\n`;
            }
        }

        return code;
    }

    compileElifChain(elifNode, visitedInPath, contextStack, indentLevel) {
        let code = "";
        const indent = "    ".repeat(indentLevel);

        let currentElif = elifNode;
        const seen = new Set();

        while (currentElif && currentElif.type === 'decision') {
            if (seen.has(currentElif.id)) break;
            seen.add(currentElif.id);

            const elifYesId = this.getSuccessor(currentElif.id, 'yes');
            const elifNoId  = this.getSuccessor(currentElif.id, 'no');

            code += `${indent}elif ${currentElif.text}:\n`;

            const elifContext = [...contextStack, `elif_${currentElif.id}`];
            const elifVisited = new Set(visitedInPath);

            const elifCode = this.compileNode(elifYesId, elifVisited, elifContext, indentLevel + 1);
            code += elifCode || `${indent}    pass\n`;

            if (!elifNoId) break;

            const nextNode = this.nodes.find(n => n.id === elifNoId);

            if (nextNode && nextNode.type === 'decision') {
                currentElif = nextNode;
                continue;
            }

            code += `${indent}else:\n`;
            const elseCode = this.compileNode(elifNoId, visitedInPath, contextStack, indentLevel + 1);
            code += elseCode || `${indent}    pass\n`;

            break;
        }

        return code;
    }

    /* ================== FUNCTION SUPPORT ================== */
    compileFunction(node, visitedInPath, contextStack, indentLevel) {
        const indent = "    ".repeat(indentLevel);
        const headerRaw = (node.text || "my_func()").trim();
        let funcName = "my_func";
        let params = "";

        const m = headerRaw.match(/^(\w+)\s*\((.*)\)$/);
        if (m) {
            funcName = m[1];
            params = m[2].trim();
        }

        let code = `${indent}def ${funcName}(${params}):\n`;
        if (this.useHighlighting) {
            code += `${indent}    highlight('${node.id}')\n`;
        }

        const bodyStart = this.getSuccessor(node.id, 'next') || this.getSuccessor(node.id, 'yes');

        const bodyVisited = new Set();
        const bodyCtx = [...contextStack, `func_${funcName}`];
        let body = this.compileNode(bodyStart, bodyVisited, bodyCtx, indentLevel + 1);

        if (!body.trim()) {
            body = `${indent}    pass\n`;
        } else if (!/\breturn\b/.test(body)) {
            body += `${indent}    # WARNING: function '${funcName}' has no return statement\n`;
        }

        code += body + "\n";

        const afterId = this.getSuccessor(node.id, 'next');
        code += this.compileNode(afterId, visitedInPath, contextStack, indentLevel);
        return code;
    }
}

/* ============================================================
   APP OBJECT
============================================================ */
const App = {
    nodes: [],
    connections: [],
    nextId: 1,
    isRunning: false,
    isConnecting: false,
    connStart: null,
    fullExecCode: "",
    editingNode: null,
    selectedNodeId: null,
    viewportScale: 1,
    viewportX: 0,
    viewportY: 0,
    minScale: 0.3,
    maxScale: 2.5,
    cancelExecution: false,
    skulptTask: null,
    skModule: null,

    updateVarWatch(varsObj) {
        const div = document.getElementById("varwatch-table");
        if (!div) return;

        let html = "<table style='width:100%; border-collapse: collapse;'>";
        let hasVars = false;

        for (const key in varsObj) {
            if (key.startsWith("__") || key === "highlight" || key === "input" || key === "print") continue;

            let val = varsObj[key];
            let displayVal = val;

            if (val !== null && typeof val === 'object') {
                if (val.v !== undefined) {
                    displayVal = val.v;
                } else if (val.tp$name !== undefined) {
                    displayVal = `[${val.tp$name}]`;
                }
            }

            html += `
                <tr style="border-bottom: 1px solid #333;">
                    <td style="color: #888; padding: 4px; font-weight: bold;">${key}</td>
                    <td style="color: #0f0; padding: 4px; text-align: right;">${displayVal}</td>
                </tr>`;
            hasVars = true;
        }

        html += "</table>";
        div.innerHTML = hasVars ? html : "<em>No variables set</em>";
    },

    stopSim() {
        if (!this.isRunning) return;

        this.cancelExecution = true;

        if (this.skulptTask && this.skulptTask.cancel) {
            try { this.skulptTask.cancel(); } catch (_) {}
        }

        this.isRunning = false;

        document.querySelectorAll('.node').forEach(n => n.classList.remove('running'));
        document.getElementById('run-btn').style.display = "inline-block";
        document.getElementById('stop-btn').style.display = "none";

        this.log("\n>>> Stopped.");
    },

    async loadExampleFromFile(filename) {
        try {
            const res = await fetch(`flows/${filename}`);
            if (!res.ok) {
                alert(`Could not load ${filename}`);
                return;
            }

            const diagram = await res.json();
            this.loadDiagramObject(diagram);

        } catch (err) {
            console.error(err);
            alert("Error loading example file");
        }
    },

    loadDiagramObject(diagram) {
        if (!diagram.nodes || !Array.isArray(diagram.nodes)) {
            alert("Invalid diagram file (missing nodes)");
            return;
        }

        if (!diagram.connections || !Array.isArray(diagram.connections)) {
            alert("Invalid diagram file (missing connections)");
            return;
        }

        this.nodes = [];
        this.connections = [];
        this.selectedNodeId = null;

        document.getElementById('nodes-layer').innerHTML = "";
        document.getElementById('console').innerHTML = "";
        document.getElementById('code-python').innerText = "";

        this.nextId = 1;

        diagram.nodes.forEach(node => {
            const num = parseInt(node.id.replace("n", "")) || 0;
            if (num >= this.nextId) this.nextId = num + 1;

            this.nodes.push(node);
            this.renderNode(node);
        });

        this.connections = diagram.connections;

        this.drawConns();
        this.updateCode();

        if (this.resetView) this.resetView();
    },

    zoomIn() {
        this.viewportScale = Math.min(this.maxScale, this.viewportScale * 1.2);
        this.applyViewportTransform();
    },

    zoomOut() {
        this.viewportScale = Math.max(this.minScale, this.viewportScale / 1.2);
        this.applyViewportTransform();
    },

    resetView() {
        this.viewportScale = 1;
        this.viewportX = 0;
        this.viewportY = 0;
        this.applyViewportTransform();
    },

    applyViewportTransform() {
        const t = `translate(${this.viewportX}px, ${this.viewportY}px) scale(${this.viewportScale})`;
        this.nodesLayer.style.transform = t;
        this.svgLayer.style.transform   = t;
    },

    init() {
        Sk.configure({ 
            output: (t) => this.log(t), 
            read: (x) => Sk.builtinFiles["files"][x], 
            inputfun: (p) => this.handleInput(p), 
            inputfunTakesPrompt: true 
        });
        this.canvas = document.getElementById('canvas');
        this.nodesLayer = document.getElementById('nodes-layer');
        this.svgLayer = document.getElementById('connections-layer');
        this.dragLine = document.getElementById('drag-line');
        this.setupGlobalEvents();
        this.setupDragDrop();
        this.createNode('start', 50, 50);
        document.getElementById('save-node-btn').onclick = () => this.saveNodeEdit();
        this.applyViewportTransform();
        this.dragLine = document.createElementNS("http://www.w3.org/2000/svg", "path");
        this.dragLine.setAttribute("stroke", "#666");
        this.dragLine.setAttribute("stroke-width", "3");
        this.dragLine.setAttribute("fill", "none");
        this.dragLine.style.display = "none";
        this.svgLayer.appendChild(this.dragLine);
    },

    log(t) { 
        const c = document.getElementById('console'); 
        const s = document.createElement('span'); 
        s.innerText = t; 
        c.appendChild(s); 
        c.scrollTop = c.scrollHeight; 
    },

    handleInput(prompt) {
        return new Promise((resolve) => {
            const modal = new bootstrap.Modal(document.getElementById('inputModal'));
            document.getElementById('modal-prompt').innerText = prompt || "Enter value:";
            const field = document.getElementById('modal-field');
            field.value = "";
            modal.show();
            const finish = () => { modal.hide(); resolve(field.value); };
            document.getElementById('modal-submit').onclick = finish;
            field.onkeydown = (e) => { if(e.key === 'Enter') finish(); };
        });
    },

    createNode(type, x, y) {
        const id = `n${this.nextId++}`;
        let text = '';
        let varName = "x";
        let prompt = "Enter value";
        let dtype = "int";
        
        switch(type) {
            case 'start': text = 'Start'; break;
            case 'end':   text = 'End'; break;
            case 'decision': text = 'x < 10'; break;
            case 'var': text = 'x = 0'; break;
            case 'list': text = 'myList = []'; break;
            case 'output': text = 'x'; break;
            case 'process': text = 'x = x + 1'; break;
            case 'input': text = ''; varName = "x"; prompt = "Enter value"; dtype = "int"; break;
            case 'function_def': text = 'my_func(a, b)'; break;
            case 'function_call': text = 'result = my_func(1, 2)'; break;
            case 'return': text = 'return x'; break;
        }

        const config = { id, type, x, y, text, varName, prompt, dtype };
        this.nodes.push(config); 
        this.renderNode(config); 
        this.updateCode();
    },

    renderNode(node) {
        const el = document.createElement('div');
        el.className = `node shape-${node.type}`; 
        el.id = node.id;
        el.style.left = node.x + 'px'; 
        el.style.top = node.y + 'px';
        
        let label = node.text;
        if (node.type === 'output') label = `print(${node.text})`;
        if (node.type === 'input') label = `${node.varName} = input()`;
        if (node.type === 'function_def') label = `def ${node.text}:`;
        if (node.type === 'return') {
            if (!label || !label.trim().startsWith('return')) {
                label = `return ${label}`;
            }
        }
        
        if (node.type === 'decision') {
            el.className = `node shape-decision`;
            el.innerHTML = `
                <svg class="decision-svg" viewBox="0 0 100 100" preserveAspectRatio="none">
                    <polygon points="50,0 100,50 50,100 0,50" />
                </svg>
                <div class="inner-text">${label}</div>
            `;
        } else {
            el.innerHTML = `<div class="inner-text">${label}</div>`;
        }
        
        if (node.type !== 'start') this.addDot(el, 'in', 'in');
        
        if (node.type === 'decision') { 
            this.addDot(el, 'out-yes', 'yes'); 
            this.addDot(el, 'out-no', 'no'); 
        } else if (node.type !== 'end') {
            this.addDot(el, 'out', 'next');
        }
        
        el.onpointerdown = (e) => {
            if (e.target.classList.contains('dot')) return;
            this.selectNode(node.id);
            const sX = e.clientX, sY = e.clientY, iX = node.x, iY = node.y;
            const move = (me) => {
                node.x = iX + (me.clientX - sX); 
                node.y = iY + (me.clientY - sY);
                el.style.left = node.x + 'px'; 
                el.style.top = node.y + 'px';
                this.drawConns();
            };
            window.addEventListener('pointermove', move);
            window.addEventListener('pointerup', () => { 
                window.removeEventListener('pointermove', move); 
                this.updateCode(); 
            }, {once: true});
        };
        
        el.ondblclick = () => this.openEditor(node);
        this.nodesLayer.appendChild(el);
    },

    selectNode(id) {
        this.selectedNodeId = id;
        document.querySelectorAll('.node').forEach(n => 
            n.classList.toggle('selected', n.id === id));
    },

    getPortPos(id, type) {
        const el = document.getElementById(id);
        if (!el) return { x: 0, y: 0 };

        let dotClass = 'out';
        if (type === 'yes') dotClass = 'out-yes';
        else if (type === 'no') dotClass = 'out-no';
        else if (type === 'in') dotClass = 'in';

        const dot = el.querySelector(`.dot.${dotClass}`);

        const canvasRect = this.canvas.getBoundingClientRect();
        const rect = (dot || el).getBoundingClientRect();

        const rawX = rect.left - canvasRect.left + 5;
        const rawY = rect.top  - canvasRect.top  + 5;

        const x = (rawX - this.viewportX) / this.viewportScale;
        const y = (rawY - this.viewportY) / this.viewportScale;

        return { x, y };
    },

    drawConns() {
        document.querySelectorAll('.conn-label').forEach(l => l.remove());

        const d = this.svgLayer.querySelector('defs');
        this.svgLayer.innerHTML = "";
        this.svgLayer.appendChild(d);
        this.svgLayer.appendChild(this.dragLine);

        const orthogonal = (p1, p2) => {
            const GAP = 25;
            const SIDE = 90;

            if (p2.y >= p1.y) {
                const y1 = p1.y + GAP;
                const midY = (y1 + p2.y - GAP) / 2;

                return `
                    M ${p1.x} ${p1.y}
                    V ${y1}
                    V ${midY}
                    H ${p2.x}
                    V ${p2.y - GAP}
                    V ${p2.y}
                `.replace(/\s+/g, ' ');
            }

            const sideX = p1.x < p2.x ? p1.x - SIDE : p1.x + SIDE;

            return `
                M ${p1.x} ${p1.y}
                V ${p1.y + GAP}
                H ${sideX}
                V ${p2.y - GAP}
                H ${p2.x}
                V ${p2.y}
            `.replace(/\s+/g, ' ');
        };

        this.connections.forEach(c => {
            const p1 = this.getPortPos(c.from, c.port);
            const p2 = this.getPortPos(c.to, 'in');

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const dStr = orthogonal(p1, p2);
            path.setAttribute('d', dStr);
            path.setAttribute(
                'stroke',
                c.port === 'yes' ? '#16a34a' :
                c.port === 'no'  ? '#dc2626' :
                                   '#444'
            );
            path.setAttribute('stroke-width', 2.5);
            path.setAttribute('fill', 'none');
            path.setAttribute('marker-end', 'url(#arrowhead)');
            path.setAttribute('stroke-linejoin', 'round');
            path.setAttribute('stroke-linecap', 'round');

            this.svgLayer.appendChild(path);

            if (c.port === 'yes' || c.port === 'no') {
                const l = document.createElement('div');
                l.className = 'conn-label';
                l.innerText = c.port.toUpperCase();
                l.style.left = (p1.x + 8) + 'px';
                l.style.top  = (p1.y + 8) + 'px';
                this.nodesLayer.appendChild(l);
            }
        });
    },

    updateCode() {
    try {
        const comp = new FlowchartCompiler(this.nodes, this.connections, false);
        const execComp = new FlowchartCompiler(this.nodes, this.connections, true);

        // normal compilation
        const code = comp.compile();
        document.getElementById('code-python').innerText = code;
        this.fullExecCode = execComp.compile();

        // ================================
        // STATIC LOOP EXIT ANALYSIS HERE
        // ================================
        const consoleEl = document.getElementById("console");

        // clear previous suggestions (but not runtime output)
        consoleEl.innerHTML = ">>> Analysis\n";

        // 1. find *implicit* loop headers
        if (!comp.implicitLoopHeaders) return;

        comp.implicitLoopHeaders.forEach(headerId => {

            // 2. compute exit edges for this header
            const exits = comp.getImplicitLoopExitEdges(headerId);

            if (exits.length === 0) {
                consoleEl.innerHTML +=
                    `⚠️ Loop at ${headerId} has NO exits. Program will run forever unless 'break' or 'return' is used.<br>`;
            } else {
                consoleEl.innerHTML +=
                    `💡 Loop at ${headerId} has exits leaving the loop body. You may need a 'break' statement.<br>`;
            }
        });

    } catch (error) {
        console.error('Compilation error:', error);
        document.getElementById('code-python').innerText =
            `# Compilation Error: ${error.message}\n# Check console for details.`;
        this.fullExecCode = "";
    }
}
,

    async runSim() {
        if (this.isRunning) return;

        this.isRunning = true;
        this.cancelExecution = false;

        document.getElementById('run-btn').style.display = "none";
        document.getElementById('stop-btn').style.display = "inline-block";
        document.getElementById('console').innerHTML = ">>> Running...<br/>";

        this.updateVarWatch({});

        Sk.builtins.highlight = new Sk.builtin.func((id) => {
            if (this.cancelExecution) throw new Error("Execution stopped.");

            const nid = (typeof id === "string") ? id : id.v;

            document.querySelectorAll('.node').forEach(n => n.classList.remove('running'));
            const activeNode = document.getElementById(nid);
            if (activeNode) activeNode.classList.add('running');

            if (Sk.globals) {
                this.updateVarWatch(Sk.globals);
            }

            const delay = 2100 - document.getElementById('speed-slider').value;
            return new Sk.misceval.promiseToSuspension(
                new Promise(resolve => setTimeout(resolve, delay))
            );
        });

        try {
            this.skulptTask = Sk.misceval.asyncToPromise(() =>
                Sk.importMainWithBody("<stdin>", false, this.fullExecCode, true)
            );
            await this.skulptTask;
        } catch (e) {
            if (!this.cancelExecution) this.log(String(e));
        }

        this.isRunning = false;
        document.querySelectorAll('.node').forEach(n => n.classList.remove('running'));
        document.getElementById('run-btn').style.display = "inline-block";
        document.getElementById('stop-btn').style.display = "none";
        if (!this.cancelExecution) this.log("\n>>> Finished.");
    },

    setupGlobalEvents() {
        this.canvas.addEventListener("wheel", (e) => {
            e.preventDefault();

            const scaleBefore = this.viewportScale;

            if (e.deltaY < 0) this.viewportScale *= 1.1;
            else this.viewportScale /= 1.1;

            this.viewportScale = Math.min(this.maxScale, Math.max(this.minScale, this.viewportScale));

            const rect = this.canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            this.viewportX = mx - (mx - this.viewportX) * (this.viewportScale / scaleBefore);
            this.viewportY = my - (my - this.viewportY) * (this.viewportScale / scaleBefore);

            this.applyViewportTransform();
        }, { passive: false });

        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;

        this.canvas.addEventListener("pointerdown", (e) => {
            if (e.target.id === "canvas" || e.target.id === "connections-layer") {
                isPanning = true;
                panStartX = e.clientX - this.viewportX;
                panStartY = e.clientY - this.viewportY;
            }
        });

        window.addEventListener("pointermove", (e) => {
            if (!isPanning) return;
            this.viewportX = e.clientX - panStartX;
            this.viewportY = e.clientY - panStartY;
            this.applyViewportTransform();
        });

        window.addEventListener("pointerup", () => {
            isPanning = false;
        });

        window.onkeydown = (e) => {
            if ((e.key === "Delete" || e.key === "Backspace") && this.selectedNodeId) {
                if (document.activeElement.tagName === "INPUT") return;
                const n = this.nodes.find(x => x.id === this.selectedNodeId); 
                if(n?.type === 'start') return;
                
                this.nodes = this.nodes.filter(x => x.id !== this.selectedNodeId);
                this.connections = this.connections.filter(c => 
                    c.from !== this.selectedNodeId && c.to !== this.selectedNodeId);
                
                document.getElementById(this.selectedNodeId)?.remove(); 
                this.selectedNodeId = null; 
                this.drawConns(); 
                this.updateCode();
            }
        };
        
        window.onpointermove = (e) => {
            if (!this.isConnecting) return;
            const r = this.canvas.getBoundingClientRect();
            const start = this.getPortPos(this.connStart.nodeId, this.connStart.portType);
            this.dragLine.setAttribute('d', 
                `M ${start.x} ${start.y} L ${e.clientX - r.left} ${e.clientY - r.top}`);
        };
        
        window.onpointerup = (e) => {
            if (!this.isConnecting) return;
            this.isConnecting = false; 
            this.dragLine.style.display = 'none';
            
            const target = document.elementFromPoint(e.clientX, e.clientY)?.closest('.node');
            if (target && target.id !== this.connStart.nodeId) {
                this.connections = this.connections.filter(c => 
                    !(c.from === this.connStart.nodeId && c.port === this.connStart.portType));
                
                this.connections.push({ 
                    from: this.connStart.nodeId, 
                    port: this.connStart.portType, 
                    to: target.id 
                });
                
                this.drawConns(); 
                this.updateCode();
            }
        };
    },

    setupDragDrop() {
        document.querySelectorAll('.palette-item').forEach(p => 
            p.ondragstart = (e) => e.dataTransfer.setData('type', p.dataset.type));
        
        this.canvas.ondragover = (e) => e.preventDefault();
        this.canvas.ondrop = (e) => {
            const r = this.canvas.getBoundingClientRect();
            this.createNode(
                e.dataTransfer.getData('type'), 
                e.clientX - r.left - 50, 
                e.clientY - r.top - 20
            );
        };
    },

    openEditor(node) {
        if (node.type === 'start' || node.type === 'end') return;

        this.editingNode = node;
        const body = document.getElementById('edit-modal-body');

        if (node.type === 'output') {
            body.innerHTML = `
                <label class="small fw-bold mb-1">Output value (inside print)</label>
                <div class="input-group">
                    <span class="input-group-text">print(</span>
                    <input id="edit-output-text" class="form-control" value="${node.text}">
                    <span class="input-group-text">)</span>
                </div>
            `;
        }
        else if (node.type === 'decision') {
            body.innerHTML = `
                <label class="small fw-bold mb-1">Decision condition</label>
                <div class="input-group">
                    <span class="input-group-text">if</span>
                    <input id="edit-decision-text" class="form-control" value="${node.text}">
                    <span class="input-group-text">:</span>
                </div>
                <div class="form-text">Examples: x &lt; 10, total == 0, name != ""</div>
            `;
        }
        else if (node.type === 'input') {
            body.innerHTML = `
                <label class="small fw-bold">Variable name</label>
                <input id="edit-input-var" class="form-control mb-2" value="${node.varName}">

                <label class="small fw-bold">Prompt text</label>
                <input id="edit-input-prompt" class="form-control mb-2" value="${node.prompt}">

                <label class="small fw-bold">Input type</label>
                <select id="edit-input-dtype" class="form-select">
                    <option value="int" ${node.dtype === 'int' ? 'selected' : ''}>Number</option>
                    <option value="str" ${node.dtype === 'str' ? 'selected' : ''}>Text</option>
                </select>

                <div class="mt-2 small text-muted">
                    Preview:
                    <code id="input-preview"></code>
                </div>
            `;

            setTimeout(() => {
                const updatePreview = () => {
                    const v = document.getElementById("edit-input-var").value || "x";
                    const p = document.getElementById("edit-input-prompt").value || "";
                    const t = document.getElementById("edit-input-dtype").value;

                    document.getElementById("input-preview").innerText =
                        t === "int"
                            ? `${v} = int(input("${p}"))`
                            : `${v} = input("${p}")`;
                };

                document.getElementById("edit-input-var").oninput = updatePreview;
                document.getElementById("edit-input-prompt").oninput = updatePreview;
                document.getElementById("edit-input-dtype").onchange = updatePreview;

                updatePreview();
            }, 0);
        }
        else if (node.type === 'var') {
            let varName = "x";
            let varValue = "";

            if (node.text && node.text.includes("=")) {
                const parts = node.text.split("=");
                varName = parts[0].trim();
                varValue = parts.slice(1).join("=").trim();
            }

            body.innerHTML = `
                <label class="small fw-bold">Variable name</label>
                <input id="edit-var-name" class="form-control mb-2" value="${varName}">

                <label class="small fw-bold">Value or expression</label>
                <input id="edit-var-value" class="form-control mb-2" value="${varValue}">

                <div class="mt-2 small text-muted">
                    Preview:
                    <code id="var-preview"></code>
                </div>
            `;

            setTimeout(() => {
                const updatePreview = () => {
                    const n = document.getElementById("edit-var-name").value || "x";
                    const v = document.getElementById("edit-var-value").value || "0";
                    document.getElementById("var-preview").innerText = `${n} = ${v}`;
                };

                document.getElementById("edit-var-name").oninput = updatePreview;
                document.getElementById("edit-var-value").oninput = updatePreview;

                updatePreview();
            }, 0);
        }
        else if (node.type === 'list') {
            let listName = "myList";
            let values = [];

            if (node.text && node.text.includes("=")) {
                const parts = node.text.split("=");
                listName = parts[0].trim();

                try {
                    values = JSON.parse(parts[1].trim().replace(/'/g,'"'));
                } catch {
                    values = [];
                }
            }

            const length = values.length || 3;

            let elementsHtml = "";
            for (let i = 0; i < length; i++) {
                elementsHtml += `
                    <input class="form-control mb-1 list-element"
                           value="${values[i] ?? ''}"
                           placeholder="Element ${i}">
                `;
            }

            body.innerHTML = `
                <label class="small fw-bold">List name</label>
                <input id="edit-list-name" class="form-control mb-2" value="${listName}">

                <label class="small fw-bold">List length</label>
                <input id="edit-list-length" type="number"
                       min="0" class="form-control mb-2" value="${length}">

                <label class="small fw-bold">Elements</label>
                <div id="list-elements-box">${elementsHtml}</div>

                <div class="mt-2 small text-muted">
                    Preview:
                    <code id="list-preview"></code>
                </div>
            `;

            setTimeout(() => {
                const listBox = document.getElementById("list-elements-box");

                const rebuild = () => {
                    const len = parseInt(document.getElementById("edit-list-length").value) || 0;

                    listBox.innerHTML = "";
                    for (let i = 0; i < len; i++) {
                        listBox.innerHTML += `
                            <input class="form-control mb-1 list-element"
                                   placeholder="Element ${i}">
                        `;
                    }
                    updatePreview();
                };

                const updatePreview = () => {
                    const name = document.getElementById("edit-list-name").value || "myList";
                    const elems = [...document.querySelectorAll(".list-element")].map(e => e.value);

                    const quoted = elems.map(v =>
                        isNaN(v) || v === "" ? `"${v}"` : v
                    );

                    document.getElementById("list-preview").innerText =
                        `${name} = [${quoted.join(", ")}]`;
                };

                document.getElementById("edit-list-length").oninput = rebuild;
                document.getElementById("edit-list-name").oninput = updatePreview;
                listBox.oninput = updatePreview;

                updatePreview();
            }, 0);
        }
        else if (node.type === 'function_def') {
            body.innerHTML = `
                <label class="small fw-bold">Function name and parameters</label>
                <div class="input-group mb-2">
                    <span class="input-group-text">def</span>
                    <input id="edit-func-header" class="form-control" value="${node.text}">
                    <span class="input-group-text">:</span>
                </div>
                <div class="mt-1 small text-muted">
                    Preview: <code id="func-preview"></code>
                </div>
            `;
            setTimeout(() => {
                const inp = document.getElementById("edit-func-header");
                const prev = document.getElementById("func-preview");
                const update = () => {
                    const h = (inp.value || "my_func()").trim();
                    prev.innerText = `def ${h}:`;
                };
                inp.oninput = update;
                update();
            }, 0);
        }
        else if (node.type === 'function_call') {
            body.innerHTML = `
                <label class="small fw-bold">Function call</label>
                <input id="edit-call-text" class="form-control mb-2" value="${node.text}">
                <div class="small text-muted">
                    Example: <code>result = my_func(1, 2)</code>
                </div>
            `;
        }
        else if (node.type === 'return') {
            const expr = (node.text || "").replace(/^return\s+/, "");
            body.innerHTML = `
                <label class="small fw-bold">Return expression</label>
                <div class="input-group">
                    <span class="input-group-text">return</span>
                    <input id="edit-return-expr" class="form-control" value="${expr}">
                </div>
            `;
        }
        else {
            body.innerHTML = `
                <label class="small fw-bold">Code Text</label>
                <input id="edit-generic-text" class="form-control" value="${node.text ?? ""}">
            `;
        }

        new bootstrap.Modal(document.getElementById('editModal')).show();
    },

    saveNodeEdit() {
        const n = this.editingNode;

        if (n.type === 'output') {
            n.text = document.getElementById('edit-output-text').value;
        }
        else if (n.type === 'decision') {
            n.text = document.getElementById('edit-decision-text').value;
        }
        else if (n.type === 'input') {
            n.varName = document.getElementById('edit-input-var').value;
            n.prompt  = document.getElementById('edit-input-prompt').value;
            n.dtype   = document.getElementById('edit-input-dtype').value;
        }
        else if (n.type === 'var') {
            const name  = document.getElementById('edit-var-name').value || "x";
            const value = document.getElementById('edit-var-value').value || "0";
            n.text = `${name} = ${value}`;
        }
        else if (n.type === 'list') {
            const name = document.getElementById("edit-list-name").value || "myList";
            const elems = [...document.querySelectorAll(".list-element")].map(e => e.value);
            const formatted = elems.map(v =>
                isNaN(v) || v === "" ? `"${v}"` : v
            );
            n.text = `${name} = [${formatted.join(", ")}]`;
        }
        else if (n.type === 'function_def') {
            const header = document.getElementById('edit-func-header').value.trim() || "my_func()";
            n.text = header;
        }
        else if (n.type === 'function_call') {
            const callText = document.getElementById('edit-call-text').value.trim() || "my_func()";
            n.text = callText;
        }
        else if (n.type === 'return') {
            const expr = document.getElementById('edit-return-expr').value.trim() || "None";
            n.text = `return ${expr}`;
        }
        else {
            n.text = document.getElementById('edit-generic-text').value;
        }

        bootstrap.Modal.getInstance(document.getElementById('editModal')).hide();

        document.getElementById(n.id).remove();
        this.renderNode(n);
        this.drawConns();
        this.updateCode();
    },

    addDot(parent, cls, portType) {
        const d = document.createElement('div'); 
        d.className = `dot ${cls}`;
        d.onpointerdown = (e) => { 
            e.stopPropagation(); 
            this.isConnecting = true; 
            this.connStart = { nodeId: parent.id, portType }; 
            this.dragLine.style.display = 'block'; 
        };
        parent.appendChild(d);
    },

    saveDiagram() {
        const diagram = {
            nodes: this.nodes,
            connections: this.connections,
            version: "3.0"
        };
        
        const json = JSON.stringify(diagram, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'flowchart.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    },

    loadDiagram() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const diagram = JSON.parse(event.target.result);
                    
                    if (!diagram.nodes || !Array.isArray(diagram.nodes)) {
                        alert('Invalid diagram file: missing nodes array');
                        return;
                    }
                    if (!diagram.connections || !Array.isArray(diagram.connections)) {
                        alert('Invalid diagram file: missing connections array');
                        return;
                    }
                    
                    this.nodes = [];
                    this.connections = [];
                    this.selectedNodeId = null;
                    document.getElementById('nodes-layer').innerHTML = "";
                    document.getElementById('code-python').innerText = "";
                    document.getElementById('console').innerHTML = "";
                    
                    this.nextId = 1;
                    diagram.nodes.forEach(node => {
                        const nodeNum = parseInt(node.id.replace('n', '')) || 0;
                        if (nodeNum >= this.nextId) {
                            this.nextId = nodeNum + 1;
                        }
                        this.nodes.push(node);
                        this.renderNode(node);
                    });
                    
                    this.connections = diagram.connections;
                    
                    this.drawConns();
                    try {
                        this.updateCode();
                    } catch (compileError) {
                        console.error('Compilation error after load:', compileError);
                        document.getElementById('code-python').innerText = `# Error compiling loaded diagram: ${compileError.message}`;
                    }
                } catch (error) {
                    alert('Error loading diagram: ' + error.message);
                    console.error('Load error:', error);
                    console.error('Stack:', error.stack);
                }
            };
            reader.readAsText(file);
        };
        input.click();
    },

    clearCanvas() { 
        if(confirm("Clear all?")) { 
            this.nodes=[]; 
            this.connections=[]; 
            this.selectedNodeId=null; 
            document.getElementById('nodes-layer').innerHTML=""; 
            document.getElementById('code-python').innerText=""; 
            document.getElementById('console').innerHTML=""; 
            this.drawConns(); 
            this.updateCode(); 
        } 
    }
};

App.init();
</script>
</body>
</html>
